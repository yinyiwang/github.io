<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>解决同一台电脑生成过个SSH的问题</title>
    <url>/yinyiwang/2020/04/09/%E8%A7%A3%E5%86%B3%E5%90%8C%E4%B8%80%E5%8F%B0%E7%94%B5%E8%84%91%E7%94%9F%E6%88%90%E8%BF%87%E4%B8%AASSH%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>解决同一台电脑生成两份或多份ssh密钥、公钥映射两个或多个GitHub账号</p>
<p>需求描述</p>
<p>本人注册一个GitHub账户，用来分享本人自己的开源项目或者代码，同时，公司注册了一个GitHub账户，用来分享公司的开源项目。如果按照单个ssh公钥生成的方法则会把之前的公钥覆盖掉，这样将导致其中一方在下一次上传代码，本机和GitHub无法映射成功。</p>
<a id="more"></a>

<p>需求分析</p>
<p>解决这个问题首先要明确如何生成单个ssh公钥。<br>ssh生成单个公钥命令：ssh-keygen -t rsa -b 4096 -C “<a href="mailto:your_email@example.com">your_email@example.com</a>“。如何生成ssh公钥<br>上述命令会在当前~/.ssh目录下生成id_rsa和id_rsa.pub两个文件。其中id_rsa是私钥文件，id_rsa_.pub是公钥文件。<br>id_rsa和id_rsa_.pub文件都是通过一个邮箱号生成的，同一个公钥文件不可以配置两个不同GitHub账户（已测试）。<br>那么两个GitHub账户就需要两个不同的邮箱号，来生成两组不同的公钥文件。</p>
<p>解决方案</p>
<p>分别指定ssh公钥文件的名称即可。</p>
<p>命令：ssh-keygen -t rsa -C “<a href="mailto:your_email@example.com">your_email@example.com</a>“ -f <del>/.ssh/id_rsa_example<br>示例：分别以<a href="mailto:791815567@qq.com">791815567@qq.com</a>和galaxysoft@sina.cn两个邮箱在</del>/.ssh目录下生成两级不同的公钥文件。<br><a href="mailto:791815567@qq.com">791815567@qq.com</a>邮箱：ssh-keygen -t rsa -C “<a href="mailto:791815567@qq.com">791815567@qq.com</a>“ -f <del>/.ssh/id_rsa_me<br><a href="mailto:galaxysoft@sina.cn">galaxysoft@sina.cn</a>邮箱：ssh-keygen -t rsa -C “<a href="mailto:galaxysoft@sina.cn">galaxysoft@sina.cn</a>“ -f ~/.ssh/id_rsa_galaxysoft<br>生成过程可参考如何生成单个ssh公钥 这篇文章。<br>执行完成后，会以</del>/.ssh目录下看<a href="mailto:791815567@qq.com">791815567@qq.com</a>邮箱对应的私钥文件id_rsa_me、公钥文件id_rsa_me.pub和<a href="mailto:galaxysoft@sina.cn">galaxysoft@sina.cn</a>邮箱对应的私钥文件id_rsa_galaxysoft、公钥文件id_rsa_galaxysoft.pub<br>分别在两个GitHub账户中添加对应的公钥信息即可，可参考如何生成单个ssh公钥 这篇文章</p>
<p>通过ssh-add添加密钥至ssh-agent中</p>
<p>命令：ssh-add ~/.ssh/id_rsa_example;<br>示例：添加本文中的两个密钥：ssh-add ~/.ssh/id_rsa_me; ssh-add ~/.ssh/id_rsa_galaxysoft;</p>
<p>添加config配置文件分别映射不同的GitHub账户</p>
<p>进入~/.ssh目录，新建config文件，并添加相应的内容：</p>
<h1 id="个人的GitHub公钥"><a href="#个人的GitHub公钥" class="headerlink" title="个人的GitHub公钥"></a>个人的GitHub公钥</h1><p>Host github.com<br>HostName github.com<br>PreferredAuthentications publickey<br>IdentityFile ~/.ssh/id_rsa_me  # 指定特定的ssh私钥文件</p>
<h1 id="BitMan’s-GitHub"><a href="#BitMan’s-GitHub" class="headerlink" title="BitMan’s GitHub"></a>BitMan’s GitHub</h1><p>Host github.com<br>HostName github.com<br>PreferredAuthentications publickey<br>IdentityFile ~/.ssh/id_rsa_galaxysoft  # 指定特定的ssh私钥文件<br>测试配置是否成功</p>
<p>测试命令：ssh -T <a href="mailto:git@github.com">git@github.com</a><br>如果出现如下信息，表示配置成功：</p>
<p><code>Hi myNameIssls!</code> You’ve successfully authenticated, but GitHub does not provide shell access.<br>1<br>小提示：由于配置了两个GitHub的公、私钥映射信息，测试结果并不会把两个GitHub的信息都显示出来，只会显示第一个配置的映射成功信息。例如本例中只显示了Hi myNameIssls!账户信息。</p>
]]></content>
      <categories>
        <category>HEXO</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Github和HEXO搭建个人博客</title>
    <url>/yinyiwang/2020/04/09/%E4%BD%BF%E7%94%A8Github%E5%92%8CHEXO%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用github pages服务搭建博客的好处有：</p>
<ol>
<li>全是静态文件，访问速度快；</li>
<li>免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；</li>
<li>可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；</li>
<li>数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；</li>
<li>博客内容可以轻松打包、转移、发布到其它平台；</li>
<li>等等；</li>
</ol>
<a id="more"></a>

<h2 id="1-1-准备工作"><a href="#1-1-准备工作" class="headerlink" title="1.1. 准备工作"></a>1.1. 准备工作</h2><p>在开始一切之前，你必须已经：</p>
<ul>
<li>有一个github账号，没有的话去注册一个；</li>
<li>安装了node.js、npm，并了解相关基础知识；</li>
<li>安装了git for windows（或者其它git客户端）</li>
</ul>
<h1 id="搭建github博客"><a href="#搭建github博客" class="headerlink" title="搭建github博客"></a>搭建github博客</h1><h2 id="2-1-创建仓库"><a href="#2-1-创建仓库" class="headerlink" title="2.1. 创建仓库"></a>2.1. 创建仓库</h2><p>新建一个名为<code>你的用户名.github.io</code>的仓库，比如说，如果你的github用户名是test，那么你就新建<code>test.github.io</code>的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 <a href="http://test.github.io/" target="_blank" rel="noopener">http://test.github.io</a> 了，是不是很方便？</p>
<p>由此可见，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。</p>
<p>几个注意的地方：</p>
<ol>
<li>注册的邮箱一定要验证，否则不会成功；</li>
<li>仓库名字必须是：<code>username.github.io</code>，其中<code>username</code>是你的用户名；</li>
<li>仓库创建成功不会立即生效，需要过一段时间，大概10-30分钟，或者更久，我的等了半个小时才生效；</li>
</ol>
<p>创建成功后，默认会在你这个仓库里生成一些示例页面，以后你的网站所有代码都是放在这个仓库里啦。</p>
<h2 id="2-2-绑定域名"><a href="#2-2-绑定域名" class="headerlink" title="2.2. 绑定域名"></a>2.2. 绑定域名</h2><p>当然，你不绑定域名肯定也是可以的，就用默认的 <code>xxx.github.io</code> 来访问，如果你想更个性一点，想拥有一个属于自己的域名，那也是OK的。</p>
<p>首先你要注册一个域名，域名注册以前总是推荐去<code>godaddy</code>，现在觉得其实国内的阿里云也挺不错的，价格也不贵，毕竟是大公司，放心！</p>
<p>绑定域名分2种情况：带www和不带www的。</p>
<p>域名配置最常见有2种方式，CNAME和A记录，CNAME填写域名，A记录填写IP，由于不带www方式只能采用A记录，所以必须先ping一下<code>你的用户名.github.io</code>的IP，然后到你的域名DNS设置页，将A记录指向你ping出来的IP，将CNAME指向<code>你的用户名.github.io</code>，这样可以保证无论是否添加www都可以访问，如下：</p>
<p><img src="http://image.liuxianan.com/201608/20160823_191336_238_8683.png" alt="img"></p>
<p>然后到你的github项目根目录新建一个名为CNAME的文件（无后缀），里面填写你的域名，加不加www看你自己喜好，因为经测试：</p>
<ul>
<li>如果你填写的是没有www的，比如 mygit.me，那么无论是访问 <a href="http://www.mygit.me/" target="_blank" rel="noopener">http://www.mygit.me</a> 还是 <a href="http://mygit.me/" target="_blank" rel="noopener">http://mygit.me</a> ，都会自动跳转到 <a href="http://mygit.me/" target="_blank" rel="noopener">http://mygit.me</a></li>
<li>如果你填写的是带www的，比如 <a href="http://www.mygit.me" target="_blank" rel="noopener">www.mygit.me</a> ，那么无论是访问 <a href="http://www.mygit.me/" target="_blank" rel="noopener">http://www.mygit.me</a> 还是 <a href="http://mygit.me/" target="_blank" rel="noopener">http://mygit.me</a> ，都会自动跳转到 <a href="http://www.mygit.me/" target="_blank" rel="noopener">http://www.mygit.me</a></li>
<li>如果你填写的是其它子域名，比如 abc.mygit.me，那么访问 <a href="http://abc.mygit.me/" target="_blank" rel="noopener">http://abc.mygit.me</a> 没问题，但是访问 <a href="http://mygit.me/" target="_blank" rel="noopener">http://mygit.me</a> ，不会自动跳转到 <a href="http://abc.mygit.me/" target="_blank" rel="noopener">http://abc.mygit.me</a></li>
</ul>
<p>另外说一句，在你绑定了新域名之后，原来的<code>你的用户名.github.io</code>并没有失效，而是会自动跳转到你的新域名。</p>
<h1 id="配置SSH-key"><a href="#配置SSH-key" class="headerlink" title="配置SSH key"></a>配置SSH key</h1><p>为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。</p>
<p>用git bash执行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/. ssh <span class="comment">#检查本机已存在的ssh密钥</span></span><br></pre></td></tr></table></figure>

<p>如果提示：No such file or directory 说明你是第一次使用git。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;邮件地址&quot;</span><br></pre></td></tr></table></figure>

<p>然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到<code>.ssh\id_rsa.pub</code>文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key：</p>
<p><img src="http://image.liuxianan.com/201608/20160818_143914_495_9084.png" alt="img"></p>
<p>将刚复制的内容粘贴到key那里，title随便填，保存。</p>
<h2 id="3-1-测试是否成功"><a href="#3-1-测试是否成功" class="headerlink" title="3.1. 测试是否成功"></a>3.1. 测试是否成功</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ssh -T git@github.com # 注意邮箱地址不用改</span><br></pre></td></tr></table></figure>

<p>如果提示<code>Are you sure you want to continue connecting (yes/no)?</code>，输入yes，然后会看到：</p>
<blockquote>
<p>Hi liuxianan! You’ve successfully authenticated, but GitHub does not provide shell access.</p>
</blockquote>
<p>看到这个信息说明SSH已配置成功！</p>
<p>此时你还需要配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name &quot;liuxianan&quot;&#x2F;&#x2F; 你的github用户名，非昵称</span><br><span class="line">$ git config --global user.email  &quot;xxx@qq.com&quot;&#x2F;&#x2F; 填写你的github注册邮箱</span><br></pre></td></tr></table></figure>

<p>具体这个配置是干嘛的我没仔细深究。</p>
<h1 id="使用hexo写博客"><a href="#使用hexo写博客" class="headerlink" title="使用hexo写博客"></a>使用hexo写博客</h1><h2 id="4-1-hexo简介"><a href="#4-1-hexo简介" class="headerlink" title="4.1. hexo简介"></a>4.1. hexo简介</h2><p>Hexo是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题。</p>
<p>官网： <a href="http://hexo.io/" target="_blank" rel="noopener">http://hexo.io</a><br>github: <a href="https://github.com/hexojs/hexo" target="_blank" rel="noopener">https://github.com/hexojs/hexo</a></p>
<h2 id="4-2-原理"><a href="#4-2-原理" class="headerlink" title="4.2. 原理"></a>4.2. 原理</h2><p>由于github pages存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，假如每次写完一篇文章都要手动更新博文目录和相关链接信息，相信谁都会疯掉，所以hexo所做的就是将这些md文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到github。</p>
<h2 id="4-3-注意事项"><a href="#4-3-注意事项" class="headerlink" title="4.3. 注意事项"></a>4.3. 注意事项</h2><p>安装之前先来说几个注意事项：</p>
<ol>
<li>很多命令既可以用Windows的cmd来完成，也可以使用git bash来完成，但是部分命令会有一些问题，为避免不必要的问题，建议全部使用git bash来执行；</li>
<li>hexo不同版本差别比较大，网上很多文章的配置信息都是基于2.x的，所以注意不要被误导；</li>
<li>hexo有2种<code>_config.yml</code>文件，一个是根目录下的全局的<code>_config.yml</code>，一个是各个<code>theme</code>下的；</li>
</ol>
<h2 id="4-4-安装"><a href="#4-4-安装" class="headerlink" title="4.4. 安装"></a>4.4. 安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo</span><br></pre></td></tr></table></figure>

<h2 id="4-5-初始化"><a href="#4-5-初始化" class="headerlink" title="4.5. 初始化"></a>4.5. 初始化</h2><p>在电脑的某个地方新建一个名为hexo的文件夹（名字可以随便取），比如我的是<code>F:\Workspaces\hexo</code>，由于这个文件夹将来就作为你存放代码的地方，所以最好不要随便放。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /f/Workspaces/hexo/</span><br><span class="line">$ hexo init</span><br></pre></td></tr></table></figure>

<p>hexo会自动下载一些文件到这个目录，包括node_modules，目录结构如下图：</p>
<p><img src="http://image.liuxianan.com/201608/20160818_115922_773_1148.png" alt="img"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo g <span class="comment"># 生成</span></span><br><span class="line">$ hexo s <span class="comment"># 启动服务</span></span><br></pre></td></tr></table></figure>

<p>执行以上命令之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github去的：</p>
<p><img src="http://image.liuxianan.com/201608/20160818_120700_028_2426.png" alt="img"></p>
<p><code>hexo s</code>是开启本地预览服务，打开浏览器访问 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000</a> 即可看到内容，很多人会碰到浏览器一直在转圈但是就是加载不出来的问题，一般情况下是因为端口占用的缘故，因为4000这个端口太常见了，解决端口冲突问题请参考这篇文章：</p>
<p><a href="http://blog.liuxianan.com/windows-port-bind.html" target="_blank" rel="noopener">http://blog.liuxianan.com/windows-port-bind.html</a></p>
<p>第一次初始化的时候hexo已经帮我们写了一篇名为 Hello World 的文章，默认的主题比较丑。</p>
<h2 id="4-6-修改主题"><a href="#4-6-修改主题" class="headerlink" title="4.6. 修改主题"></a>4.6. 修改主题</h2><p>既然默认主题很丑，那我们别的不做，首先来替换一个好看点的主题。这是 <a href="https://hexo.io/themes/" target="_blank" rel="noopener">官方主题</a>。</p>
<p>以hexo-theme-next为例</p>
<p>首先下载这个主题：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /f/Workspaces/hexo/</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

<p>下载后的主题都在这里：</p>
<p><img src="http://image.liuxianan.com/201608/20160818_134500_245_0912.png" alt="img"></p>
<p>修改<code>_config.yml</code>中的<code>theme: landscape</code>改为<code>theme: yilia</code>，然后重新执行<code>hexo g</code>来重新生成。</p>
<p>如果出现一些莫名其妙的问题，可以先执行<code>hexo clean</code>来清理一下public的内容，然后再来重新生成和发布。</p>
<h2 id="4-7-上传之前"><a href="#4-7-上传之前" class="headerlink" title="4.7. 上传之前"></a>4.7. 上传之前</h2><p>在上传代码到github之前，一定要记得先把你以前所有代码下载下来（虽然github有版本管理，但备份一下总是好的），因为从hexo提交代码时会把你以前的所有代码都删掉。</p>
<h2 id="4-8-上传到github"><a href="#4-8-上传到github" class="headerlink" title="4.8. 上传到github"></a>4.8. 上传到github</h2><p>如果你一切都配置好了，发布上传很容易，一句<code>hexo d</code>就搞定，当然关键还是你要把所有东西配置好。</p>
<p>首先，<code>ssh key</code>肯定要配置好。</p>
<p>其次，配置<code>_config.yml</code>中有关deploy的部分：</p>
<p>正确写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:liuxianan&#x2F;liuxianan.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>错误写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: github</span><br><span class="line">  repository: https:&#x2F;&#x2F;github.com&#x2F;liuxianan&#x2F;liuxianan.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>后面一种写法是hexo2.x的写法，现在已经不行了，无论是哪种写法，此时直接执行<code>hexo d</code>的话一般会报如下错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Deployer not found: github 或者 Deployer not found: git</span><br></pre></td></tr></table></figure>

<p>原因是还需要安装一个插件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>其它命令不确定，部署这个命令一定要用git bash，否则会提示<code>Permission denied (publickey).</code></p>
<p>打开你的git bash，输入<code>hexo d</code>就会将本次有改动的代码全部提交，没有改动的不会：</p>
<p><img src="http://image.liuxianan.com/201608/20160818_140441_769_5024.png" alt="img"></p>
<h2 id="4-9-保留CNAME、README-md等文件"><a href="#4-9-保留CNAME、README-md等文件" class="headerlink" title="4.9. 保留CNAME、README.md等文件"></a>4.9. 保留CNAME、README.md等文件</h2><p>提交之后网页上一看，发现以前其它代码都没了，此时不要慌，一些非md文件可以把他们放到source文件夹下，这里的所有文件都会原样复制（除了md文件）到public目录的：</p>
<p><img src="http://image.liuxianan.com/201608/20160818_141037_580_8035.png" alt="img"></p>
<p>由于hexo默认会把所有md文件都转换成html，包括README.md，所有需要每次生成之后、上传之前，手动将README.md复制到public目录，并删除README.html。</p>
<h2 id="4-10-常用hexo命令"><a href="#4-10-常用hexo命令" class="headerlink" title="4.10. 常用hexo命令"></a>4.10. 常用hexo命令</h2><p>常见命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &quot;postName&quot; #新建文章</span><br><span class="line">hexo new page &quot;pageName&quot; #新建页面</span><br><span class="line">hexo generate #生成静态页面至public目录</span><br><span class="line">hexo server #开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server）</span><br><span class="line">hexo deploy #部署到GitHub</span><br><span class="line">hexo help  # 查看帮助</span><br><span class="line">hexo version  #查看Hexo的版本</span><br></pre></td></tr></table></figure>

<p>缩写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo n &#x3D;&#x3D; hexo new</span><br><span class="line">hexo g &#x3D;&#x3D; hexo generate</span><br><span class="line">hexo s &#x3D;&#x3D; hexo server</span><br><span class="line">hexo d &#x3D;&#x3D; hexo deploy</span><br></pre></td></tr></table></figure>

<p>组合命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s -g #生成并本地预览</span><br><span class="line">hexo d -g #生成并上传</span><br></pre></td></tr></table></figure>

<h2 id="4-11-config-yml"><a href="#4-11-config-yml" class="headerlink" title="4.11. _config.yml"></a>4.11. _config.yml</h2><p>这里面都是一些全局配置，每个参数的意思都比较简单明了，所以就不作详细介绍了。</p>
<p>需要特别注意的地方是，冒号后面必须有一个空格，否则可能会出问题。</p>
<h2 id="4-12-写博客"><a href="#4-12-写博客" class="headerlink" title="4.12. 写博客"></a>4.12. 写博客</h2><p>定位到我们的hexo根目录，执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &#39;my-first-blog&#39;</span><br></pre></td></tr></table></figure>

<p>hexo会帮我们在<code>_posts</code>下生成相关md文件：</p>
<p><img src="http://image.liuxianan.com/201608/20160823_183047_352_1475.png" alt="img"></p>
<p>我们只需要打开这个文件就可以开始写博客了，默认生成如下内容：</p>
<p><img src="http://image.liuxianan.com/201608/20160823_183325_470_9306.png" alt="img"></p>
<p>当然你也可以直接自己新建md文件，用这个命令的好处是帮我们自动生成了时间。</p>
<p>一般完整格式如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: postName #文章页面上的显示名称，一般是中文</span><br><span class="line">date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改</span><br><span class="line">categories: 默认分类 #分类</span><br><span class="line">tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格</span><br><span class="line">description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">以下是正文</span><br></pre></td></tr></table></figure>

<p>那么<code>hexo new page &#39;postName&#39;</code>命令和<code>hexo new &#39;postName&#39;</code>有什么区别呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;my-second-blog&quot;</span><br></pre></td></tr></table></figure>

<p>生成如下：</p>
<p><img src="http://image.liuxianan.com/201608/20160823_184852_854_6502.png" alt="img"></p>
<p>最终部署时生成：<code>hexo\public\my-second-blog\index.html</code>，但是它不会作为文章出现在博文目录。</p>
<h3 id="4-12-1-写博客工具"><a href="#4-12-1-写博客工具" class="headerlink" title="4.12.1. 写博客工具"></a>4.12.1. 写博客工具</h3><p>VSCode和Typora</p>
<h3 id="4-12-2-如何让博文列表不显示全部内容"><a href="#4-12-2-如何让博文列表不显示全部内容" class="headerlink" title="4.12.2. 如何让博文列表不显示全部内容"></a>4.12.2. 如何让博文列表不显示全部内容</h3><p>默认情况下，生成的博文目录会显示全部的文章内容，如何设置文章摘要的长度呢？</p>
<p>答案是在合适的位置加上<code>&lt;!--more--&gt;</code>即可，例如：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 前言</span></span><br><span class="line"></span><br><span class="line">使用github pages服务搭建博客的好处有：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1. </span>全是静态文件，访问速度快；</span><br><span class="line"><span class="bullet">2. </span>免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；</span><br><span class="line"><span class="bullet">3. </span>可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--more--&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="bullet">4. </span>数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；</span><br><span class="line"><span class="bullet">5. </span>博客内容可以轻松打包、转移、发布到其它平台；</span><br><span class="line"><span class="bullet">6. </span>等等；</span><br></pre></td></tr></table></figure>

<p>最终效果：</p>
<p><img src="http://image.liuxianan.com/201608/20160823_184633_653_1893.png" alt="img"></p>
<h1 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h1><p><strong>文章头设置</strong></p>
<p>首先为了新建文章方便，建议将<code>/scaffolds/post.md</code>修改为如下代码：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">top: false</span><br><span class="line">cover: false</span><br><span class="line">password:</span><br><span class="line">toc: true</span><br><span class="line">mathjax: true</span><br><span class="line">summary:</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p><strong>添加404页面</strong></p>
<p>原来的主题没有404页面，加一个也不是什么难事。首先在<code>/source/</code>目录下新建一个<code>404.md</code>，内容如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 404</span><br><span class="line">date: 2019-07-19 16:41:10</span><br><span class="line">type: "404"</span><br><span class="line">layout: "404"</span><br><span class="line">description: "你来到了没有知识的荒原 :("</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>然后在<code>/themes/matery/layout/</code>目录下新建一个<code>404.ejs</code>文件，内容如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="comment">/* don't remove. */</span></span></span><br><span class="line"><span class="css">    <span class="selector-class">.about-cover</span> &#123;</span></span><br><span class="line">        height: 75vh;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"bg-cover pd-header about-cover"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col s10 offset-s1 m8 offset-m2 l8 offset-l2"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"brand"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"title center-align"</span>&gt;</span></span><br><span class="line">                        404</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"description center-align"</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">%=</span> <span class="attr">page.description</span> %&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 每天切换 banner 图.  Switch banner image every day.</span></span></span><br><span class="line"><span class="javascript">    $(<span class="string">'.bg-cover'</span>).css(<span class="string">'background-image'</span>, <span class="string">'url(/medias/banner/'</span> + <span class="keyword">new</span> <span class="built_in">Date</span>().getDay() + <span class="string">'.jpg)'</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>增加建站时间</strong></p>
<p>修改<code>/themes/matery/layout/_partial/footer.ejs</code>文件，在最后加上</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script language=javascript&gt;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">siteTime</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">window</span>.setTimeout(<span class="string">"siteTime()"</span>, <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">var</span> seconds = <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">var</span> minutes = seconds * <span class="number">60</span>;</span><br><span class="line">        <span class="keyword">var</span> hours = minutes * <span class="number">60</span>;</span><br><span class="line">        <span class="keyword">var</span> days = hours * <span class="number">24</span>;</span><br><span class="line">        <span class="keyword">var</span> years = days * <span class="number">365</span>;</span><br><span class="line">        <span class="keyword">var</span> today = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">        <span class="keyword">var</span> todayYear = today.getFullYear();</span><br><span class="line">        <span class="keyword">var</span> todayMonth = today.getMonth() + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">var</span> todayDate = today.getDate();</span><br><span class="line">        <span class="keyword">var</span> todayHour = today.getHours();</span><br><span class="line">        <span class="keyword">var</span> todayMinute = today.getMinutes();</span><br><span class="line">        <span class="keyword">var</span> todaySecond = today.getSeconds();</span><br><span class="line">        <span class="comment">/* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)</span></span><br><span class="line"><span class="comment">        year - 作为date对象的年份，为4位年份值</span></span><br><span class="line"><span class="comment">        month - 0-11之间的整数，做为date对象的月份</span></span><br><span class="line"><span class="comment">        day - 1-31之间的整数，做为date对象的天数</span></span><br><span class="line"><span class="comment">        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数</span></span><br><span class="line"><span class="comment">        minutes - 0-59之间的整数，做为date对象的分钟数</span></span><br><span class="line"><span class="comment">        seconds - 0-59之间的整数，做为date对象的秒数</span></span><br><span class="line"><span class="comment">        microseconds - 0-999之间的整数，做为date对象的毫秒数 */</span></span><br><span class="line">        <span class="keyword">var</span> t1 = <span class="built_in">Date</span>.UTC(<span class="number">2017</span>, <span class="number">09</span>, <span class="number">11</span>, <span class="number">00</span>, <span class="number">00</span>, <span class="number">00</span>); <span class="comment">//北京时间2018-2-13 00:00:00</span></span><br><span class="line">        <span class="keyword">var</span> t2 = <span class="built_in">Date</span>.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);</span><br><span class="line">        <span class="keyword">var</span> diff = t2 - t1;</span><br><span class="line">        <span class="keyword">var</span> diffYears = <span class="built_in">Math</span>.floor(diff / years);</span><br><span class="line">        <span class="keyword">var</span> diffDays = <span class="built_in">Math</span>.floor((diff / days) - diffYears * <span class="number">365</span>);</span><br><span class="line">        <span class="keyword">var</span> diffHours = <span class="built_in">Math</span>.floor((diff - (diffYears * <span class="number">365</span> + diffDays) * days) / hours);</span><br><span class="line">        <span class="keyword">var</span> diffMinutes = <span class="built_in">Math</span>.floor((diff - (diffYears * <span class="number">365</span> + diffDays) * days - diffHours * hours) / minutes);</span><br><span class="line">        <span class="keyword">var</span> diffSeconds = <span class="built_in">Math</span>.floor((diff - (diffYears * <span class="number">365</span> + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds);</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">"sitetime"</span>).innerHTML = <span class="string">"本站已运行 "</span> +diffYears+<span class="string">" 年 "</span>+diffDays + <span class="string">" 天 "</span> + diffHours + <span class="string">" 小时 "</span> + diffMinutes + <span class="string">" 分钟 "</span> + diffSeconds + <span class="string">" 秒"</span>;</span><br><span class="line">    &#125;<span class="comment">/*因为建站时间还没有一年，就将之注释掉了。需要的可以取消*/</span></span><br><span class="line">    siteTime();</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后在合适的地方（比如copyright声明后面）加上下面的代码就行了：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"sitetime"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>HEXO</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>获取网址的真实ip</title>
    <url>/yinyiwang/2020/04/18/%E8%8E%B7%E5%8F%96%E7%BD%91%E5%9D%80%E7%9A%84%E7%9C%9F%E5%AE%9Eip/</url>
    <content><![CDATA[<h1 id="HOSTS文件是做什么的？"><a href="#HOSTS文件是做什么的？" class="headerlink" title="HOSTS文件是做什么的？"></a>HOSTS文件是做什么的？</h1><p>Hosts是将一些常用的网址域名与其对应的IP地址建立关联的”数据库”——用户在浏览器输入网址时，系统优先从Hosts文件中寻找对应的IP地址，找到后自动打开对应网页；若没有找到，则再将网址提交DNS域名解析服务器进行IP地址的解析。</p>
]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>获取ip</tag>
      </tags>
  </entry>
  <entry>
    <title>peixun培训</title>
    <url>/yinyiwang/2020/04/09/peixun%E5%9F%B9%E8%AE%AD/</url>
    <content><![CDATA[<h1 id="今天是搭建个人博客的培训"><a href="#今天是搭建个人博客的培训" class="headerlink" title="今天是搭建个人博客的培训"></a>今天是搭建个人博客的培训</h1>]]></content>
      <categories>
        <category>培训</category>
      </categories>
      <tags>
        <tag>培训</tag>
        <tag>peixun</tag>
      </tags>
  </entry>
  <entry>
    <title>1</title>
    <url>/yinyiwang/2020/05/30/1/</url>
    <content><![CDATA[// routes/index.js
module.exports = function (app) {
    app.get('/', function (req, res) {
        res.send('Hello world');
    });
    app.get('/customer', function (req, res) {
        res.send('customer page');
    });
    app.get('/admin', function (req, res) {
        res.send('admin page');
    });
};]]></content>
  </entry>
  <entry>
    <title>前端插件化（模块化）方案调研</title>
    <url>/yinyiwang/2020/04/17/%E5%89%8D%E7%AB%AF%E6%8F%92%E4%BB%B6%E5%8C%96%EF%BC%88%E6%A8%A1%E5%9D%97%E5%8C%96%EF%BC%89%E6%96%B9%E6%A1%88%E8%B0%83%E7%A0%94/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>随着前端功能越来越复杂，前端代码日益膨胀，为了减少维护成本，提高代码的可复用性，前端模块化势在必行。</p>
<p>所有js文件都在一个html中引入，造成以下不良影响：</p>
<ol>
<li><strong>请求过多</strong>。首先我们要依赖多个模块，那样就会发送多个请求，导致请求过多</li>
<li><strong>依赖模糊</strong>。我们不知道他们的具体依赖关系是什么，也就是说很容易因为不了解他们之间的依赖关系导致加载先后顺序出错。</li>
<li><strong>难以维护</strong>。以上两种原因就导致了很难维护，很可能出现牵一发而动全身的情况导致项目出现严重的问题。</li>
</ol>
<a id="more"></a>

<h2 id="模块的概念"><a href="#模块的概念" class="headerlink" title="模块的概念"></a>模块的概念</h2><p>webpack中是这样定义的：</p>
<blockquote>
<p>在模块化编程中，开发者将程序分解成离散功能块(discrete chunks of functionality)，并称之为模块。 每个模块具有比完整程序更小的接触面，使得校验、调试、测试轻而易举。 精心编写的模块提供了可靠的抽象和封装界限，使得应用程序中每个模块都具有条理清楚的设计和明确的目的。</p>
</blockquote>
<p>模块应该是职责单一、相互独立、低耦合的、高度内聚且可替换的离散功能块。</p>
<h2 id="模块化的概念"><a href="#模块化的概念" class="headerlink" title="模块化的概念"></a>模块化的概念</h2><blockquote>
<p>模块化是一种处理复杂系统分解成为更好的可管理模块的方式，它可以把系统代码划分为一系列职责单一，高度解耦且可替换的模块，系统中某一部分的变化将如何影响其它部分就会变得显而易见，系统的可维护性更加简单易得。</p>
</blockquote>
<p>模块化是一种分治的思想，通过分解复杂系统为独立的模块实现细粒度的精细控制，对于复杂系统的维护和管理十分有益。模块化也是组件化的基石，是构成现在色彩斑斓的前端世界的前提条件。</p>
<h2 id="为什么需要模块化"><a href="#为什么需要模块化" class="headerlink" title="为什么需要模块化"></a>为什么需要模块化</h2><p>前端开发和其他开发工作的主要区别，首先是前端是<strong>基于多语言</strong>、<strong>多层次的编码和组织工作</strong>，其次前端产品的交付是<strong>基于浏览器</strong>，这些资源是通过增量加载的方式运行到浏览器端，如何在开发环境组织好这些碎片化的代码和资源，并且保证他们在浏览器端快速、优雅的加载和更新，就需要一个模块化系统。</p>
<h2 id="模块化的好处"><a href="#模块化的好处" class="headerlink" title="模块化的好处"></a>模块化的好处</h2><ol>
<li><p><strong>可维护性。</strong> 因为模块是独立的，一个设计良好的模块会让外面的代码对自己的依赖越少越好，这样自己就可以独立去更新和改进。</p>
</li>
<li><p><strong>命名空间。</strong> 在 JavaScript 里面，如果一个变量在最顶级的函数之外声明，它就直接变成全局可用。因此，常常不小心出现命名冲突的情况。使用模块化开发来封装变量，可以避免污染全局环境。</p>
</li>
<li><p><strong>重用代码。</strong> 我们有时候会喜欢从之前写过的项目中拷贝代码到新的项目，这没有问题，但是更好的方法是，通过模块引用的方式，来避免重复的代码库。我们可以在更新了模块之后，让引用了该模块的所有项目都同步更新，还能指定版本号，避免 API 变更带来的麻烦。</p>
</li>
</ol>
<h2 id="模块化简史"><a href="#模块化简史" class="headerlink" title="模块化简史"></a>模块化简史</h2><h3 id="1-最简单粗暴的方式"><a href="#1-最简单粗暴的方式" class="headerlink" title="1. 最简单粗暴的方式"></a>1. 最简单粗暴的方式</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 script 标签引入文件，调用相关的函数。这样需要手动去管理依赖顺序，容易造成命名冲突，污染全局，随着项目的复杂度增加维护成本也越来越高。</p>
<h3 id="2-用对象来模拟命名空间"><a href="#2-用对象来模拟命名空间" class="headerlink" title="2. 用对象来模拟命名空间"></a>2. 用对象来模拟命名空间</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> output = &#123;</span><br><span class="line">  _count: <span class="number">0</span>,</span><br><span class="line">  fn1: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样可以解决上面的全局污染的问题，有那么点命名空间的意思，但是随着项目复杂度增加需要越来越多的这样的对象需要维护，不说别的，取名字都是个问题。最关键的还是内部的属性还是可以被直接访问和修改。</p>
<h3 id="3-闭包"><a href="#3-闭包" class="headerlink" title="3. 闭包"></a>3. 闭包</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> fn1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> fn2 = <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    fn1: fn1,</span><br><span class="line">    fn2: fn2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.fn1();</span><br><span class="line"><span class="built_in">module</span>._count; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>这样就拥有独立的词法作用域，内存中只会存在一份 copy。这不仅避免了外界访问此 <code>IIFE</code> 中的变量，而且又不会污染全局作用域，通过 <code>return</code> 暴露出公共接口供外界调用。这其实就是现代模块化实现的基础。</p>
<h3 id="4-更多"><a href="#4-更多" class="headerlink" title="4. 更多"></a>4. 更多</h3><p>还有基于闭包实现的松耦合拓展、紧耦合拓展、继承、子模块、跨文件共享私有对象、基于 new 构造的各种方式，这种方式在现在看来都不再优雅。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 松耦合拓展</span></span><br><span class="line"><span class="comment">// 这种方式使得可以在不同的文件中以相同结构共同实现一个功能块，且不用考虑在引入这些文件时候的顺序问题。</span></span><br><span class="line"><span class="comment">// 缺点是没办法重写你的一些属性或者函数，也不能在初始化的时候就是用module的属性。</span></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = (<span class="function"><span class="keyword">function</span>(<span class="params">my</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> my</span><br><span class="line">&#125;)(<span class="built_in">module</span> || &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 紧耦合拓展（没有传默认参数）</span></span><br><span class="line"><span class="comment">// 加载顺序不再自由，但是可以重载</span></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = (<span class="function"><span class="keyword">function</span>(<span class="params">my</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> old = my.someOldFunc</span><br><span class="line">  </span><br><span class="line">  my.someOldFunc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 重载方法，依然可通过old调用旧的方法...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> my</span><br><span class="line">&#125;)(<span class="built_in">module</span>)</span><br></pre></td></tr></table></figure>



<h2 id="实现模块化的方案规范总览"><a href="#实现模块化的方案规范总览" class="headerlink" title="实现模块化的方案规范总览"></a>实现模块化的方案规范总览</h2><p>历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的<code>require</code>、Python 的<code>import</code>，甚至就连 CSS 都有<code>@import</code>，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。</p>
<p>在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</p>
<p>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。</p>
<p>目前实现模块化的规范主要有：</p>
<ul>
<li>CommonJS</li>
<li>CMD</li>
<li>AMD</li>
<li>ES6模块</li>
</ul>
<h2 id="CommonJS（）"><a href="#CommonJS（）" class="headerlink" title="CommonJS（）"></a>CommonJS（）</h2><p>CommonJS 是以在浏览器环境之外构建 JavaScript 生态系统为目标而产生的项目，比如在服务器和桌面环境中。</p>
<p>采用同步加载模块的方式，也就是说只有加载完成，才能执行后面的操作。CommonJS 代表：Node 应用中的模块，通俗的说就是你用 npm 安装的模块。</p>
<p>它使用 require 引用和加载模块，exports 定义和导出模块，module 标识模块。使用 require 时需要去读取并执行该文件，然后返回 exports 导出的内容。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义模块 math.js</span></span><br><span class="line"> <span class="keyword">var</span> random=<span class="built_in">Math</span>.random()*<span class="number">10</span>;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">printRandom</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(random)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">printIntRandom</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="built_in">Math</span>.floor(random))</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//模块输出</span></span><br><span class="line"> <span class="built_in">module</span>.exports=&#123;</span><br><span class="line">     printRandom:printRandom,</span><br><span class="line">     printIntRandom:printIntRandom</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//加载模块 math.js</span></span><br><span class="line"> <span class="keyword">var</span> math=<span class="built_in">require</span>(<span class="string">'math'</span>)</span><br><span class="line"> <span class="comment">//调用模块提供的方法</span></span><br><span class="line"> math.printIntRandom()</span><br><span class="line"> math.printRandom()</span><br></pre></td></tr></table></figure>

<h3 id="CommonJS主要用于服务端的模块化，不适用于前端模块化的原因在于："><a href="#CommonJS主要用于服务端的模块化，不适用于前端模块化的原因在于：" class="headerlink" title="CommonJS主要用于服务端的模块化，不适用于前端模块化的原因在于："></a>CommonJS主要用于服务端的模块化，不适用于前端模块化的原因在于：</h3><ul>
<li>服务端加载一个模块，直接就从硬盘或者内存中读取了，消耗时间可以忽略不计</li>
<li>浏览器需要从服务端下载这个文件，所以说如果用CommonJS的require方式加载模块，需要等代码模块下载完毕，并运行之后才能得到所需要的API。</li>
<li>如果我们在某个代码模块里使用CommonJS的方法require了一个模块，而这个模块需要通过http请求从服务器去取，如果网速很慢，而CommonJS又是同步的，所以将阻塞后面代码的执行，从而阻塞浏览器渲染页面，使得页面出现假死状态。</li>
</ul>
<h3 id="CommonJS在浏览器端实现的步骤："><a href="#CommonJS在浏览器端实现的步骤：" class="headerlink" title="CommonJS在浏览器端实现的步骤："></a>CommonJS在浏览器端实现的步骤：</h3><h4 id="1-创建项目结构"><a href="#1-创建项目结构" class="headerlink" title="1. 创建项目结构"></a>1. 创建项目结构</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">|-js</span><br><span class="line">  |-dist <span class="comment">//打包生成文件的目录</span></span><br><span class="line">  |-src <span class="comment">//源码所在的目录</span></span><br><span class="line">    |-module1.js</span><br><span class="line">    |-module2.js</span><br><span class="line">    |-module3.js</span><br><span class="line">    |-app.js <span class="comment">//应用主源文件</span></span><br><span class="line">|-index.html <span class="comment">//运行于浏览器上</span></span><br><span class="line">|-package.json</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"browserify-test"</span>,</span><br><span class="line">    <span class="string">"version"</span>: <span class="string">"1.0.0"</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-下载browserify"><a href="#2-下载browserify" class="headerlink" title="2. 下载browserify"></a>2. 下载browserify</h4><ul>
<li>全局: npm install browserify -g</li>
<li>局部: npm install browserify –save-dev</li>
</ul>
<h4 id="3-定义模块代码-同服务器端"><a href="#3-定义模块代码-同服务器端" class="headerlink" title="3. 定义模块代码(同服务器端)"></a>3. 定义模块代码(同服务器端)</h4><p>注意：<code>index.html</code>文件要运行在浏览器上，需要借助browserify将<code>app.js</code>文件打包编译，如果直接在<code>index.html</code>引入<code>app.js</code>就会报错！</p>
<h4 id="4-打包处理js"><a href="#4-打包处理js" class="headerlink" title="4. 打包处理js"></a>4. 打包处理js</h4><p>根目录下运行<code>browserify js/src/app.js -o js/dist/bundle.js</code></p>
<h4 id="5-页面使用引入"><a href="#5-页面使用引入" class="headerlink" title="5. 页面使用引入"></a>5. 页面使用引入</h4><p>在index.html文件中引入<code>&lt;script type=&quot;text/javascript&quot; src=&quot;js/dist/bundle.js&quot;&gt;&lt;/script&gt;</code></p>
<h2 id="AMD（Asynchronous-Module-Definition）"><a href="#AMD（Asynchronous-Module-Definition）" class="headerlink" title="AMD（Asynchronous Module Definition）"></a>AMD（Asynchronous Module Definition）</h2><p>异步模块定义，所谓异步是指模块和模块的依赖可以被异步加载，他们的加载不会影响它后面语句的运行。有效避免了采用同步加载方式中导致的页面假死现象。AMD代表：RequireJS。</p>
<p>AMD一开始是CommonJS规范中的一个草案，全称是Asynchronous Module Definition，即异步模块加载机制。后来由该草案的作者以RequireJS实现了AMD规范，所以一般说AMD也是指RequireJS。</p>
<p>RequireJS是一个工具库，主要用于客户端的模块管理。它的模块管理遵守AMD规范，<strong>RequireJS的基本思想是，通过define方法，将代码定义为模块；通过require方法，实现代码的模块加载</strong>。 </p>
<p>它主要有两个接口：<strong>define</strong> 和 <strong>require</strong>。define 是模块开发者关注的方法，而 require 则是模块使用者关注的方法。</p>
<h3 id="define-函数："><a href="#define-函数：" class="headerlink" title="define() 函数："></a>define() 函数：</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">define(id?, dependencies?, factory);</span><br><span class="line"><span class="comment">//id ：可选参数，它指的是模块的名字。</span></span><br><span class="line"><span class="comment">//dependencies：可选参数，定义中模块所依赖模块的数组。</span></span><br><span class="line"><span class="comment">//factory：模块初始化要执行的函数或对象</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，dependencies有多少个元素，factory就有多少个传参，位置一一对应。<br>使用栗子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">define(<span class="string">"alpha"</span>, [<span class="string">"require"</span>, <span class="string">"exports"</span>, <span class="string">"beta"</span>], <span class="function"><span class="keyword">function</span> (<span class="params">require, exports, beta</span>) </span>&#123;  </span><br><span class="line">    exports.verb = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;            </span><br><span class="line">        <span class="keyword">return</span> beta.verb();            </span><br><span class="line">        <span class="comment">//Or:</span></span><br><span class="line">        <span class="comment">//return require("beta").verb();        </span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="require-函数"><a href="#require-函数" class="headerlink" title="require() 函数"></a>require() 函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="built_in">module</span>], callback);</span><br><span class="line"><span class="comment">//module：一个数组，里面的成员就是要加载的模块.</span></span><br><span class="line"><span class="comment">//callback：模块加载成功之后的回调函数。</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是 ，module 有多少个元素，callback 就有多少个传参，位置一一对应。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>],<span class="function"><span class="keyword">function</span>(<span class="params">a,b,c</span>)</span>&#123;    <span class="comment">//code here &#125;);</span></span><br></pre></td></tr></table></figure>

<h3 id="AMD的优缺点"><a href="#AMD的优缺点" class="headerlink" title="AMD的优缺点"></a>AMD的优缺点</h3><p>AMD 运行时核心思想是「Early Executing」，也就是提前执行依赖 AMD 的这个特性有好有坏：</p>
<ul>
<li><p>首先，尽早执行依赖可以尽早发现错误。　　</p>
</li>
<li><p>另外，尽早执行依赖通常可以带来更好的用户体验，也容易产生浪费。</p>
</li>
<li><p>引用AMD的Javscript库： 目前，主要有两个Javascript库实现了AMD规范：require.js和curl.js</p>
</li>
<li><p>在浏览器环境中异步加载模块；并行加载多个模块；</p>
</li>
<li><p>开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅；不符合通用的模块化思维方式，是一种妥协的实现。</p>
</li>
</ul>
<h3 id="AMD在浏览器端的实现步骤"><a href="#AMD在浏览器端的实现步骤" class="headerlink" title="AMD在浏览器端的实现步骤"></a>AMD在浏览器端的实现步骤</h3><h4 id="1-下载require-js-并引入"><a href="#1-下载require-js-并引入" class="headerlink" title="1. 下载require.js, 并引入"></a>1. 下载require.js, 并引入</h4><ul>
<li>官网: <code>http://www.requirejs.cn/</code></li>
<li>github : <code>https://github.com/requirejs/requirejs</code></li>
</ul>
<p>然后将require.js导入项目: js/libs/require.js</p>
<h4 id="2-创建项目结构"><a href="#2-创建项目结构" class="headerlink" title="2. 创建项目结构"></a>2. 创建项目结构</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">|-js</span><br><span class="line">  |-libs</span><br><span class="line">    |-<span class="built_in">require</span>.js</span><br><span class="line">  |-modules</span><br><span class="line">    |-alerter.js</span><br><span class="line">    |-dataService.js</span><br><span class="line">  |-main.js</span><br><span class="line">|-index.html</span><br></pre></td></tr></table></figure>



<h4 id="3-定义require-js的模块"><a href="#3-定义require-js的模块" class="headerlink" title="3. 定义require.js的模块"></a>3. 定义require.js的模块</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dataService.js文件</span></span><br><span class="line"><span class="comment">// 定义没有依赖的模块</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> msg = <span class="string">'www.baidu.com'</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getMsg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> msg.toUpperCase()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123; getMsg &#125; <span class="comment">// 暴露模块</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//alerter.js文件</span></span><br><span class="line"><span class="comment">// 定义有依赖的模块</span></span><br><span class="line">define([<span class="string">'dataService'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">dataService</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">'Tom'</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">showMsg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(dataService.getMsg() + <span class="string">', '</span> + name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 暴露模块</span></span><br><span class="line">  <span class="keyword">return</span> &#123; showMsg &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js文件</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">require</span>.config(&#123;</span><br><span class="line">    baseUrl: <span class="string">'js/'</span>, <span class="comment">//基本路径 出发点在根目录下</span></span><br><span class="line">    paths: &#123;</span><br><span class="line">      <span class="comment">//映射: 模块标识名: 路径</span></span><br><span class="line">      alerter: <span class="string">'./modules/alerter'</span>, <span class="comment">//此处不能写成alerter.js,会报错</span></span><br><span class="line">      dataService: <span class="string">'./modules/dataService'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">require</span>([<span class="string">'alerter'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">alerter</span>) </span>&#123;</span><br><span class="line">    alerter.showMsg()</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.html文件</span></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;Modular Demo&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;!-- 引入<span class="built_in">require</span>.js并指定js主文件的入口 --&gt;</span><br><span class="line">    &lt;script data-main=<span class="string">"js/main"</span> src=<span class="string">"js/libs/require.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="4-页面引入require-js模块"><a href="#4-页面引入require-js模块" class="headerlink" title="4. 页面引入require.js模块:"></a>4. 页面引入require.js模块:</h4><p>在index.html引入 <code>&lt;script data-main=&quot;js/main&quot; src=&quot;js/libs/require.js&quot;&gt;&lt;/script&gt;</code></p>
<p><strong>此外在项目中如何引入第三方库</strong>？只需在上面代码的基础稍作修改：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// alerter.js文件</span></span><br><span class="line">define([<span class="string">'dataService'</span>, <span class="string">'jquery'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">dataService, $</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">'Tom'</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">showMsg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(dataService.getMsg() + <span class="string">', '</span> + name)</span><br><span class="line">  &#125;</span><br><span class="line">  $(<span class="string">'body'</span>).css(<span class="string">'background'</span>, <span class="string">'green'</span>)</span><br><span class="line">  <span class="comment">// 暴露模块</span></span><br><span class="line">  <span class="keyword">return</span> &#123; showMsg &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js文件</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">require</span>.config(&#123;</span><br><span class="line">    baseUrl: <span class="string">'js/'</span>, <span class="comment">//基本路径 出发点在根目录下</span></span><br><span class="line">    paths: &#123;</span><br><span class="line">      <span class="comment">//自定义模块</span></span><br><span class="line">      alerter: <span class="string">'./modules/alerter'</span>, <span class="comment">//此处不能写成alerter.js,会报错</span></span><br><span class="line">      dataService: <span class="string">'./modules/dataService'</span>,</span><br><span class="line">      <span class="comment">// 第三方库模块</span></span><br><span class="line">      jquery: <span class="string">'./libs/jquery-1.10.1'</span> <span class="comment">//注意：写成jQuery会报错</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">require</span>([<span class="string">'alerter'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">alerter</span>) </span>&#123;</span><br><span class="line">    alerter.showMsg()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>上例是在alerter.js文件中引入jQuery第三方库，main.js文件也要有相应的路径配置。 <strong>小结</strong>：通过两者的比较，可以得出<strong>AMD模块定义的方法非常清晰，不会污染全局环境，能够清楚地显示依赖关系</strong>。AMD模式可以用于浏览器环境，并且允许非同步加载模块，也可以根据需要动态加载模块。</p>
<h2 id="UMD规范"><a href="#UMD规范" class="headerlink" title="UMD规范"></a>UMD规范</h2><h2 id="CMD（Common-Module-Definition）"><a href="#CMD（Common-Module-Definition）" class="headerlink" title="CMD（Common Module Definition）"></a>CMD（Common Module Definition）</h2><p>CMD是SeaJS在推广过程中生产的对模块定义的规范，在Web浏览器端的模块加载器中，SeaJS与RequireJS并称，SeaJS作者为阿里的玉伯。</p>
<p>CMD规范专门用于浏览器端，模块的加载是异步的，模块使用时才会加载执行。CMD规范整合了CommonJS和AMD规范的特点。在 Sea.js 中，所有 JavaScript 模块都遵循 CMD模块定义规范。</p>
<h3 id="CMD语法"><a href="#CMD语法" class="headerlink" title="CMD语法"></a>CMD语法</h3><h4 id="定义暴露模块："><a href="#定义暴露模块：" class="headerlink" title="定义暴露模块："></a><strong>定义暴露模块：</strong></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义没有依赖的模块</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>)</span>&#123;</span><br><span class="line">  exports.xxx = value</span><br><span class="line">  <span class="built_in">module</span>.exports = value</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义有依赖的模块</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//引入依赖模块(同步)</span></span><br><span class="line">  <span class="keyword">var</span> module2 = <span class="built_in">require</span>(<span class="string">'./module2'</span>)</span><br><span class="line">  <span class="comment">//引入依赖模块(异步)</span></span><br><span class="line">    <span class="built_in">require</span>.async(<span class="string">'./module3'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">m3</span>) </span>&#123;</span><br><span class="line">    &#125;)</span><br><span class="line">  <span class="comment">//暴露模块</span></span><br><span class="line">  exports.xxx = value</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="引入使用模块："><a href="#引入使用模块：" class="headerlink" title="引入使用模块："></a><strong>引入使用模块：</strong></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">require</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> m1 = <span class="built_in">require</span>(<span class="string">'./module1'</span>)</span><br><span class="line">  <span class="keyword">var</span> m4 = <span class="built_in">require</span>(<span class="string">'./module4'</span>)</span><br><span class="line">  m1.show()</span><br><span class="line">  m4.show()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="CMD的优缺点"><a href="#CMD的优缺点" class="headerlink" title="CMD的优缺点"></a>CMD的优缺点</h3><ul>
<li>优点：依赖就近，延迟执行 可以很容易在 Node.js 中运行；</li>
<li>缺点：依赖 SPM 打包，模块的加载逻辑偏重；</li>
</ul>
<h3 id="sea-js使用步骤"><a href="#sea-js使用步骤" class="headerlink" title="sea.js使用步骤"></a>sea.js使用步骤</h3><h4 id="1-下载sea-js-并引入"><a href="#1-下载sea-js-并引入" class="headerlink" title="1. 下载sea.js, 并引入"></a>1. 下载sea.js, 并引入</h4><ul>
<li>官网: <a href="http://seajs.org/" target="_blank" rel="noopener">seajs.org/</a></li>
<li>github : <a href="https://github.com/seajs/seajs" target="_blank" rel="noopener">github.com/seajs/seajs</a></li>
</ul>
<p>然后将sea.js导入项目: js/libs/sea.js</p>
<h4 id="2-创建项目结构-1"><a href="#2-创建项目结构-1" class="headerlink" title="2. 创建项目结构"></a>2. 创建项目结构</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">|-js</span><br><span class="line">  |-libs</span><br><span class="line">    |-sea.js</span><br><span class="line">  |-modules</span><br><span class="line">    |-module1.js</span><br><span class="line">    |-module2.js</span><br><span class="line">    |-module3.js</span><br><span class="line">    |-module4.js</span><br><span class="line">    |-main.js</span><br><span class="line">|-index.html</span><br></pre></td></tr></table></figure>

<h4 id="3-定义sea-js的模块代码"><a href="#3-定义sea-js的模块代码" class="headerlink" title="3. 定义sea.js的模块代码"></a>3. 定义sea.js的模块代码</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// module1.js文件</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//内部变量数据</span></span><br><span class="line">  <span class="keyword">var</span> data = <span class="string">'atguigu.com'</span></span><br><span class="line">  <span class="comment">//内部函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'module1 show() '</span> + data)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//向外暴露</span></span><br><span class="line">  exports.show = show</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// module2.js文件</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    msg: <span class="string">'I Will Back'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// module3.js文件</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> API_KEY = <span class="string">'abc123'</span></span><br><span class="line">  exports.API_KEY = API_KEY</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// module4.js文件</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//引入依赖模块(同步)</span></span><br><span class="line">  <span class="keyword">var</span> module2 = <span class="built_in">require</span>(<span class="string">'./module2'</span>)</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'module4 show() '</span> + module2.msg)</span><br><span class="line">  &#125;</span><br><span class="line">  exports.show = show</span><br><span class="line">  <span class="comment">//引入依赖模块(异步)</span></span><br><span class="line">  <span class="built_in">require</span>.async(<span class="string">'./module3'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">m3</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'异步引入依赖模块3  '</span> + m3.API_KEY)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js文件</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">require</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> m1 = <span class="built_in">require</span>(<span class="string">'./module1'</span>)</span><br><span class="line">  <span class="keyword">var</span> m4 = <span class="built_in">require</span>(<span class="string">'./module4'</span>)</span><br><span class="line">  m1.show()</span><br><span class="line">  m4.show()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="4-在index-html中引入"><a href="#4-在index-html中引入" class="headerlink" title="4. 在index.html中引入"></a>4. 在index.html中引入</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"js/libs/sea.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script type="text/</span>javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">  seajs.use('./js/modules/main')</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="ES6模块化（-重点介绍-）"><a href="#ES6模块化（-重点介绍-）" class="headerlink" title="ES6模块化（==重点介绍==）"></a>ES6模块化（==重点介绍==）</h2><p>ES6模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。所以说ES6是<strong>编译时加载</strong>，不同于CommonJS的运行时加载(实际加载的是一整个对象)，ES6模块不是对象，而是通过export命令显式指定输出的代码，输入时也采用静态命令的形式。</p>
<p>ES6 的模块自动采用严格模式，不管你有没有在模块头部加上<code>&quot;use strict&quot;;</code>。</p>
<p>严格模式主要有以下限制。</p>
<ul>
<li>变量必须声明后再使用</li>
<li>函数的参数不能有同名属性，否则报错</li>
<li>不能使用<code>with</code>语句</li>
<li>不能对只读属性赋值，否则报错</li>
<li>不能使用前缀 0 表示八进制数，否则报错</li>
<li>不能删除不可删除的属性，否则报错</li>
<li>不能删除变量<code>delete prop</code>，会报错，只能删除属性<code>delete global[prop]</code></li>
<li><code>eval</code>不会在它的外层作用域引入变量</li>
<li><code>eval</code>和<code>arguments</code>不能被重新赋值</li>
<li><code>arguments</code>不会自动反映函数参数的变化</li>
<li>不能使用<code>arguments.callee</code></li>
<li>不能使用<code>arguments.caller</code></li>
<li>禁止<code>this</code>指向全局对象</li>
<li>不能使用<code>fn.caller</code>和<code>fn.arguments</code>获取函数调用的堆栈</li>
<li>增加了保留字（比如<code>protected</code>、<code>static</code>和<code>interface</code>）</li>
</ul>
<p>上面这些限制，模块都必须遵守。由于严格模式是 ES5 引入的，不属于 ES6，所以请参阅相关 ES5 书籍，本书不再详细介绍了。</p>
<p>其中，尤其需要注意<code>this</code>的限制。ES6 模块之中，顶层的<code>this</code>指向<code>undefined</code>，即不应该在顶层代码使用<code>this</code>。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。</p>
<h4 id="export"><a href="#export" class="headerlink" title="export"></a>export</h4><p>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。下面是一个 JS 文件，里面使用export命令输出变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cUl</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ulEle = <span class="built_in">document</span>.createElement(<span class="string">"ul"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> liEle = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</span><br><span class="line">        liEle.innerHTML = <span class="string">"无序列表"</span> + i;</span><br><span class="line">        ulEle.appendChild(liEle);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ulEle;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> ul = cUl();</span><br><span class="line"><span class="keyword">export</span> &#123;ul&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="import"><a href="#import" class="headerlink" title="import"></a>import</h4><p>使用<code>export</code>命令定义了模块的对外接口以后，其他 JS 文件就可以通过<code>import</code>命令加载这个模块。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;table&#125; <span class="keyword">from</span> <span class="string">"../test/test_table.js"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;div&#125; <span class="keyword">from</span> <span class="string">"../test/test_div.js"</span> ;</span><br><span class="line"><span class="keyword">import</span> &#123;ul&#125; <span class="keyword">from</span> <span class="string">"../test/test_ul.js"</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;table, div, ul&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="ES6-模块与-CommonJS-模块的差异"><a href="#ES6-模块与-CommonJS-模块的差异" class="headerlink" title="ES6 模块与 CommonJS 模块的差异"></a>ES6 模块与 CommonJS 模块的差异</h3><p>它们有两个重大差异：</p>
<p><strong>1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用</strong>。</p>
<p><strong>2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口</strong>。</p>
<p>第二个差异是因为 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p>
<p>下面重点解释第一个差异，我们还是举上面那个CommonJS模块的加载机制例子:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; counter, incCounter &#125; <span class="keyword">from</span> <span class="string">'./lib'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 3</span></span><br><span class="line">incCounter();</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p>ES6 模块的运行机制与 CommonJS 不一样。<strong>ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块</strong>。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1></font>



]]></content>
      <categories>
        <category>前端模块化</category>
      </categories>
      <tags>
        <tag>前端模块化</tag>
      </tags>
  </entry>
  <entry>
    <title>Module使用详解</title>
    <url>/yinyiwang/2020/04/20/Module%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>sdsdsdsdsds</p>
]]></content>
  </entry>
  <entry>
    <title>ES6的Module使用详解</title>
    <url>/yinyiwang/2020/04/20/ES6%E7%9A%84Module%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<blockquote>
<p>ES6在语言标准的层面上，实现了<strong>模块</strong>的功能，有望成为浏览器和服务端模块的通用解决方案。</p>
<p>ES6 模块的设计思想是尽量的<strong>静态化</strong>，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。</p>
<p>ES6 的模块自动采用严格模式，不管你有没有在模块头部加上<code>&quot;use strict&quot;;</code>。</p>
</blockquote>
<h1 id="一、模块命令"><a href="#一、模块命令" class="headerlink" title="一、模块命令"></a>一、模块命令</h1><p>模块功能主要由两个命令构成：<code>export</code>和<code>import</code>。</p>
<p><code>export</code>命令用于规定模块的对外接口，<code>import</code>命令用于输入其他模块提供的功能。</p>
<ol>
<li><code>export</code>命令</li>
</ol>
<ol start="2">
<li><code>import</code>命令</li>
</ol>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>Module</tag>
        <tag>模块</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6迭代器</title>
    <url>/yinyiwang/2020/04/24/ES6%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<p style = 'color:red'>这是一个p标签</p>

<p><img src="https://i.loli.net/2020/04/24/zX21NdsLFHcA5OZ.jpg" alt="K9DIWTU0D4KID_thumbnail"></p>
<h2 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h2><p>Iterator 是 ES6 引入的一种新的遍历机制，迭代器有两个核心概念：</p>
<ul>
<li>迭代器是一个统一的接口，它的作用是使各种数据结构可被便捷的访问，它是通过一个键为Symbol.iterator 的方法来实现。</li>
<li>迭代器是用于遍历数据结构元素的指针（如数据库中的游标）。</li>
</ul>
<h3 id="迭代过程"><a href="#迭代过程" class="headerlink" title="迭代过程"></a>迭代过程</h3><p>迭代的过程如下：</p>
<ul>
<li>通过 Symbol.iterator 创建一个迭代器，指向当前数据结构的起始位置</li>
<li>随后通过 next 方法进行向下迭代指向下一个位置， next 方法会返回当前位置的对象，对象包含了 value 和 done 两个属性， value 是当前属性的值， done 用于判断是否遍历结束</li>
<li>当 done 为 true 时则遍历结束</li>
</ul>
<p>下面通过一个简单的例子进行说明：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> items = [<span class="string">"zero"</span>, <span class="string">"one"</span>, <span class="string">"two"</span>]; </span><br><span class="line"><span class="keyword">const</span> it = items[<span class="built_in">Symbol</span>.iterator]();  </span><br><span class="line">it.next(); </span><br><span class="line">&gt;&#123;<span class="attr">value</span>: <span class="string">"zero"</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125; </span><br><span class="line">it.next(); </span><br><span class="line">&gt;&#123;<span class="attr">value</span>: <span class="string">"one"</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125; </span><br><span class="line">it.next(); </span><br><span class="line">&gt;&#123;<span class="attr">value</span>: <span class="string">"two"</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125; </span><br><span class="line">it.next(); </span><br><span class="line">&gt;&#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子，首先创建一个数组，然后通过 Symbol.iterator 方法创建一个迭代器，之后不断的调用 next 方法对数组内部项进行访问，当属性 done 为 true 时访问结束。</p>
<p>迭代器是协议（使用它们的规则）的一部分，用于迭代。该协议的一个关键特性就是它是顺序的：迭代器一次返回一个值。这意味着如果可迭代数据结构是非线性的（例如树），迭代将会使其线性化。</p>
<h3 id="可迭代的数据结构"><a href="#可迭代的数据结构" class="headerlink" title="可迭代的数据结构"></a>可迭代的数据结构</h3><p>以下是可迭代的值:</p>
<ul>
<li>Array</li>
<li>String</li>
<li>Map</li>
<li>Set</li>
<li>Dom元素（正在进行中）</li>
</ul>
<p>我们将使用 <strong>for…of</strong> 循环（参见下文的 for…of 循环）对数据结构进行迭代。</p>
<p><strong>Array</strong></p>
<p>数组 ( Array ) 和类型数组 ( TypedArray ) 他们是可迭代的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> [<span class="string">"zero"</span>, <span class="string">"one"</span>, <span class="string">"two"</span>]) &#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(item); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// output: </span></span><br><span class="line"><span class="comment">// zero </span></span><br><span class="line"><span class="comment">// one </span></span><br><span class="line"><span class="comment">// two</span></span><br></pre></td></tr></table></figure>

<p><strong>String</strong></p>
<p>字符串是可迭代的，单他们遍历的是 Unicode 码，每个码可能包含一个到两个的 Javascript 字符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> c <span class="keyword">of</span> <span class="string">'z\uD83D\uDC0A'</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(c); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// output: </span></span><br><span class="line"><span class="comment">// z </span></span><br><span class="line"><span class="comment">// \uD83D\uDC0A</span></span><br></pre></td></tr></table></figure>

<p><strong>Map</strong></p>
<p>Map 主要是迭代它们的 entries ，每个 entry 都会被编码为 [key, value] 的项， entries 是以确定的形势进行迭代，其顺序是与添加的顺序相同。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(); </span><br><span class="line">map.set(<span class="number">0</span>, <span class="string">"zero"</span>); </span><br><span class="line">map.set(<span class="number">1</span>, <span class="string">"one"</span>);  </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> map) &#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(item); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// output: </span></span><br><span class="line"><span class="comment">// [0, "zero"] </span></span><br><span class="line"><span class="comment">// [1, "one"]</span></span><br></pre></td></tr></table></figure>

<p>注意： WeakMaps 不可迭代</p>
<p><strong>Set</strong></p>
<p>Set 是对其元素进行迭代，迭代的顺序与其添加的顺序相同</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set(); </span><br><span class="line"><span class="keyword">set</span>.add("zero"); </span><br><span class="line"><span class="keyword">set</span>.add("one");  </span><br><span class="line">for (let item of <span class="keyword">set</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// output: </span></span><br><span class="line"><span class="comment">// zero </span></span><br><span class="line"><span class="comment">// one</span></span><br></pre></td></tr></table></figure>

<p>注意： WeakSets 不可迭代</p>
<p><strong>arguments</strong></p>
<p>arguments 目前在 ES6 中使用越来越少，但也是可遍历的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">args</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> <span class="built_in">arguments</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; args(<span class="string">"zero"</span>, <span class="string">"one"</span>); </span><br><span class="line"><span class="comment">// output: </span></span><br><span class="line"><span class="comment">// zero </span></span><br><span class="line"><span class="comment">// one</span></span><br></pre></td></tr></table></figure>

<h3 id="普通对象不可迭代"><a href="#普通对象不可迭代" class="headerlink" title="普通对象不可迭代"></a>普通对象不可迭代</h3><p>普通对象是由 object 创建的，不可迭代：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TypeError </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> &#123;&#125;) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="for…of循环"><a href="#for…of循环" class="headerlink" title="for…of循环"></a>for…of循环</h2><p>for…of 是 ES6 新引入的循环，用于替代 for..in 和 forEach() ，并且支持新的迭代协议。它可用于迭代常规的数据类型，如 <code>Array</code> 、 <code>String</code> 、 <code>Map</code>和 <code>Set</code> 等等。</p>
<h3 id="迭代常规数据类型"><a href="#迭代常规数据类型" class="headerlink" title="迭代常规数据类型"></a>迭代常规数据类型</h3><p><strong>Array</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nums = [<span class="string">"zero"</span>, <span class="string">"one"</span>, <span class="string">"two"</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// TypedArray </span></span><br><span class="line"><span class="keyword">const</span> typedArray1 = <span class="keyword">new</span> <span class="built_in">Int8Array</span>(<span class="number">6</span>); </span><br><span class="line">typedArray1[<span class="number">0</span>] = <span class="number">10</span>; </span><br><span class="line">typedArray1[<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> typedArray1) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>String</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">"zero"</span>;  </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> str) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Map</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>(); </span><br><span class="line">myMap.set(<span class="number">0</span>, <span class="string">"zero"</span>); </span><br><span class="line">myMap.set(<span class="number">1</span>, <span class="string">"one"</span>); </span><br><span class="line">myMap.set(<span class="number">2</span>, <span class="string">"two"</span>);  </span><br><span class="line"><span class="comment">// 遍历 key 和 value </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> myMap) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key + <span class="string">" = "</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> myMap.entries()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key + <span class="string">" = "</span> + value);</span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 只遍历 key </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> myMap.keys()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 只遍历 value </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> myMap.values()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Set</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mySet = <span class="keyword">new</span> <span class="built_in">Set</span>(); </span><br><span class="line">mySet.add(<span class="string">"zero"</span>); </span><br><span class="line">mySet.add(<span class="string">"one"</span>); </span><br><span class="line">mySet.add(<span class="string">"two"</span>);  </span><br><span class="line"><span class="comment">// 遍历整个 set </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> mySet) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 只遍历 key 值 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> mySet.keys()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 只遍历 value </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> mySet.values()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 遍历 key 和 value ，两者会相等 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> mySet.entries()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key + <span class="string">" = "</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可迭代的数据结构-1"><a href="#可迭代的数据结构-1" class="headerlink" title="可迭代的数据结构"></a>可迭代的数据结构</h3><p>of 操作数必须是可迭代，这意味着如果是普通对象则无法进行迭代。如果数据结构类似于数组的形式，则可以借助 Array.from() 方法进行转换迭代。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayLink = &#123;</span><br><span class="line">    length: <span class="number">2</span>, </span><br><span class="line">    <span class="number">0</span>: <span class="string">"zero"</span>, </span><br><span class="line">    <span class="number">1</span>: <span class="string">"one"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 报 TypeError 异常 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arrayLink) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 正常运行 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> <span class="built_in">Array</span>.from(arrayLink)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output: </span></span><br><span class="line"><span class="comment">// zero </span></span><br><span class="line"><span class="comment">// one</span></span><br></pre></td></tr></table></figure>

<p><strong>let 、const 和 var 用于 for..of</strong></p>
<p>如果使用 let 和 const ，每次迭代将会创建一个新的存储空间，这可以保证作用域在迭代的内部。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nums = [<span class="string">"zero"</span>, <span class="string">"one"</span>, <span class="string">"two"</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num);</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 报 ReferenceError </span></span><br><span class="line"><span class="built_in">console</span>.log(num);</span><br></pre></td></tr></table></figure>

<p>从上面的例子我们看到，最后一句会报异常，原因 num 的作用域只在循环体内部，外部无效。使用 var 则不会出现上述情况，因为 var 会作用于全局，迭代将不会每次都创建一个新的存储空间。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nums = [<span class="string">"zero"</span>, <span class="string">"one"</span>, <span class="string">"two"</span>];</span><br><span class="line">forv (<span class="keyword">var</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num);</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">console</span>.log(num);</span><br><span class="line"><span class="comment">// output: two</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/04/24/oEYfrkFBCDzR7e2.png" alt="01"></p>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>迭代器</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6模块</title>
    <url>/yinyiwang/2020/04/21/ES6%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在 ES6 前， 实现模块化使用的是 RequireJS 或者 seaJS（分别是基于 AMD 规范的模块化库， 和基于 CMD 规范的模块化库）。<br>ES6 引入了模块化，其设计思想是在编译时就能确定模块的依赖关系，以及输入和输出的变量。<br>ES6 的模块化分为导出（export） @与导入（import）两个模块。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>ES6 的模块自动开启严格模式，不管你有没有在模块头部加上 <strong>use strict;</strong>。<br>模块中可以导入和导出各种类型的变量，如函数，对象，字符串，数字，布尔值，类等。<br>每个模块都有自己的上下文，每一个模块内声明的变量都是局部变量，不会污染全局作用域。<br>每一个模块只加载一次（是单例的）， 若再去加载同目录下同文件，直接从内存中读取。</p>
<h2 id="export-与-import"><a href="#export-与-import" class="headerlink" title="export 与 import"></a>export 与 import</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>模块导入导出各种类型的变量，如字符串，数值，函数，类。</p>
<ul>
<li>导出的函数声明与类声明必须要有名称（export default 命令另外考虑）。 </li>
<li>不仅能导出声明还能导出引用（例如函数）。</li>
<li>export 命令可以出现在模块的任何位置，但必需处于模块顶层。</li>
<li>import 命令会提升到整个模块的头部，首先执行。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*-----export [test.js]-----*/</span></span><br><span class="line"><span class="keyword">let</span> myName = <span class="string">"Tom"</span>;</span><br><span class="line"><span class="keyword">let</span> myAge = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> myfn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"My name is"</span> + myName + <span class="string">"! I'm '"</span> + myAge + <span class="string">"years old."</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myClass =  <span class="class"><span class="keyword">class</span> <span class="title">myClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> a = <span class="string">"yeah!"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; myName, myAge, myfn, myClass &#125; </span><br><span class="line"><span class="comment">/*-----import [xxx.js]-----*/</span></span><br><span class="line"><span class="keyword">import</span> &#123; myName, myAge, myfn, myClass &#125; <span class="keyword">from</span> <span class="string">"./test.js"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myfn());<span class="comment">// My name is Tom! I'm 20 years old.</span></span><br><span class="line"><span class="built_in">console</span>.log(myAge);<span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(myName);<span class="comment">// Tom</span></span><br><span class="line"><span class="built_in">console</span>.log(myClass.a );<span class="comment">// yeah!</span></span><br></pre></td></tr></table></figure>
<p>建议使用大括号指定所要输出的一组变量写在文档尾部，明确导出的接口。<br>函数与类都需要有对应的名称，导出文档尾部也避免了无对应名称。</p>
<h3 id="as-的用法"><a href="#as-的用法" class="headerlink" title="as 的用法"></a>as 的用法</h3><p>export 命令导出的接口名称，须和模块内部的变量有一一对应关系。<br>导入的变量名，须和导出的接口名称相同，即顺序可以不一致。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*-----export [test.js]-----*/</span></span><br><span class="line"><span class="keyword">let</span> myName = <span class="string">"Tom"</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; myName <span class="keyword">as</span> exportName &#125;</span><br><span class="line"><span class="comment">/*-----import [xxx.js]-----*/</span></span><br><span class="line"><span class="keyword">import</span> &#123; exportName &#125; <span class="keyword">from</span> <span class="string">"./test.js"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(exportName);<span class="comment">// Tom</span></span><br><span class="line"><span class="comment">// 使用 as 重新定义导出的接口名称，隐藏模块内部的变量</span></span><br><span class="line"><span class="comment">/*-----export [test1.js]-----*/</span></span><br><span class="line"><span class="keyword">let</span> myName = <span class="string">"Tom"</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; myName &#125;</span><br><span class="line"><span class="comment">/*-----export [test2.js]-----*/</span></span><br><span class="line"><span class="keyword">let</span> myName = <span class="string">"Jerry"</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; myName &#125;</span><br><span class="line"><span class="comment">/*-----import [xxx.js]-----*/</span></span><br><span class="line"><span class="keyword">import</span> &#123; myName <span class="keyword">as</span> name1 &#125; <span class="keyword">from</span> <span class="string">"./test1.js"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; myName <span class="keyword">as</span> name2 &#125; <span class="keyword">from</span> <span class="string">"./test2.js"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name1);<span class="comment">// Tom</span></span><br><span class="line"><span class="built_in">console</span>.log(name2);<span class="comment">// Jerry</span></span><br></pre></td></tr></table></figure>
<p>不同模块导出接口名称命名重复， 使用 as 重新定义变量名。</p>
<h3 id="import-命令的特点"><a href="#import-命令的特点" class="headerlink" title="import 命令的特点"></a>import 命令的特点</h3><p><strong>只读属性</strong>：不允许在加载模块的脚本里面，改写接口的引用指向，即可以改写 import 变量类型为对象的属性值，不能改写 import 变量类型为基本类型的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;a&#125; <span class="keyword">from</span> <span class="string">"./xxx.js"</span></span><br><span class="line">a = &#123;&#125;; <span class="comment">// error</span></span><br><span class="line"><span class="keyword">import</span> &#123;a&#125; <span class="keyword">from</span> <span class="string">"./xxx.js"</span></span><br><span class="line">a.foo = <span class="string">"hello"</span>; <span class="comment">// a = &#123; foo : 'hello' &#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>单例模式</strong>：多次重复执行同一句 import 语句，那么只会执行一次，而不会执行多次。import 同一模块，声明不同接口引用，会声明对应变量，但只执行一次 import 。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; a &#125; <span class="string">"./xxx.js"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; a &#125; <span class="string">"./xxx.js"</span>;</span><br><span class="line"><span class="comment">// 相当于 import &#123; a &#125; "./xxx.js";</span></span><br><span class="line"><span class="keyword">import</span> &#123; a &#125; <span class="keyword">from</span> <span class="string">"./xxx.js"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; b &#125; <span class="keyword">from</span> <span class="string">"./xxx.js"</span>;</span><br><span class="line"><span class="comment">// 相当于 import &#123; a, b &#125; from "./xxx.js";</span></span><br></pre></td></tr></table></figure>
<p><strong>静态执行特性</strong>：import 是静态执行，所以不能使用表达式和变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="string">"f"</span> + <span class="string">"oo"</span> &#125; <span class="keyword">from</span> <span class="string">"methods"</span>;</span><br><span class="line"><span class="comment">// error</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">module</span> = <span class="string">"methods"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="built_in">module</span>;</span><br><span class="line"><span class="comment">// error</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">"method1"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">"method2"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// error</span></span><br></pre></td></tr></table></figure>
<h3 id="export-default-命令"><a href="#export-default-命令" class="headerlink" title="export default 命令"></a>export default 命令</h3><ul>
<li>在一个文件或模块中，export、import 可以有多个，export default 仅有一个。</li>
<li>export default 中的 default 是对应的导出接口变量。</li>
<li>通过 export 方式导出，在导入时要加{ }，export default 则不需要。</li>
<li>export default 向外暴露的成员，可以使用任意变量来接收。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"My name is Tom!"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> a; <span class="comment">// 仅有一个</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">var</span> c = <span class="string">"error"</span>; </span><br><span class="line"><span class="comment">// error，default 已经是对应的导出变量，不能跟着变量声明语句</span></span><br><span class="line"><span class="keyword">import</span> b <span class="keyword">from</span> <span class="string">"./xxx.js"</span>; <span class="comment">// 不需要加&#123;&#125;， 使用任意变量接收</span></span><br></pre></td></tr></table></figure>
<h2 id="复合使用"><a href="#复合使用" class="headerlink" title="复合使用"></a>复合使用</h2>export 与 import 可以在同一模块使用，使用特点：</li>
<li>可以将导出接口改名，包括 default。 </li>
<li>复合使用 export 与 import ，也可以导出全部，当前模块导出的接口会覆盖继承导出的。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">"methods"</span>;</span><br><span class="line"><span class="comment">// 约等于下面两段语句，不过上面导入导出方式该模块没有导入 foo 与 bar</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">"methods"</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; foo, bar &#125;;</span><br><span class="line"><span class="comment">/* ------- 特点 1 --------*/</span></span><br><span class="line"><span class="comment">// 普通改名</span></span><br><span class="line"><span class="keyword">export</span> &#123; foo <span class="keyword">as</span> bar &#125; <span class="keyword">from</span> <span class="string">"methods"</span>;</span><br><span class="line"><span class="comment">// 将 foo 转导成 default</span></span><br><span class="line"><span class="keyword">export</span> &#123; foo <span class="keyword">as</span> <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">"methods"</span>;</span><br><span class="line"><span class="comment">// 将 default 转导成 foo</span></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> foo &#125; <span class="keyword">from</span> <span class="string">"methods"</span>;</span><br><span class="line"><span class="comment">/* ------- 特点 2 --------*/</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">"methods"</span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>— ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>模块</tag>
      </tags>
  </entry>
  <entry>
    <title>Node模块Express简介</title>
    <url>/yinyiwang/2020/05/30/Node%E6%A8%A1%E5%9D%97Express%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Express是目前最流行的基于Node.js的Web开发框架，可以快速地搭建一个完整功能的网站。</p>
<p>Express上手非常简单，首先新建一个项目目录，假定叫做hello-world。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ mkdir hello-world</span><br></pre></td></tr></table></figure>

<p>进入该目录，新建一个package.json文件，内容如下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"hello-world"</span>,</span><br><span class="line">  <span class="string">"description"</span>: <span class="string">"hello world test app"</span>,</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"0.0.1"</span>,</span><br><span class="line">  <span class="string">"private"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="string">"express"</span>: <span class="string">"4.x"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码定义了项目的名称、描述、版本等，并且指定需要4.0版本以上的Express。</p>
<p>然后，就可以安装了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$ npm install</span><br></pre></td></tr></table></figure>

<p>执行上面的命令以后，在项目根目录下，新建一个启动文件，假定叫做index.js。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.use(express.static(__dirname + <span class="string">'/public'</span>));</span><br><span class="line">app.listen(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20200530%20/14-37-59-3sBRp7.png" alt="1"></p>
<p>然后，运行上面的启动脚本。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ node index</span><br></pre></td></tr></table></figure>

<p>现在就可以访问<code>http://localhost:8080</code>，它会在浏览器中打开当前目录的public子目录（严格来说，是打开public目录的index.html文件）。如果public目录之中有一个图片文件<code>my_image.png</code>，那么可以用<code>http://localhost:8080/my_image.png</code>访问该文件。</p>
<p>你也可以在index.js之中，生成动态网页。<br><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20200530%20/14-39-34-etX7RH.png" alt="2"></p>
<p>然后，在命令行下运行启动脚本，就可以在浏览器中访问项目网站了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ node index</span><br></pre></td></tr></table></figure>

<p>上面代码会在本机的3000端口启动一个网站，网页显示Hello World。</p>
<p>启动脚本index.js的<code>app.get</code>方法，用于指定不同的访问路径所对应的回调函数，这叫做“路由”（routing）。上面代码只指定了根目录的回调函数，因此只有一个路由记录。实际应用中，可能有多个路由记录。</p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20200530%20/14-43-06-TVQccv.png" alt="3"></p>
<p>这时，最好就把路由放到一个单独的文件中，比如新建一个routes子目录。</p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20200530%20/14-44-25-oYAFro.png" alt="4"></p>
<p>然后，原来的index.js就变成下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="keyword">var</span> routes = <span class="built_in">require</span>(<span class="string">'./routes'</span>)(app);</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>



<h2 id="运行原理"><a href="#运行原理" class="headerlink" title="运行原理"></a>运行原理</h2><h3 id="底层：http模块"><a href="#底层：http模块" class="headerlink" title="底层：http模块"></a>底层：http模块</h3><p>Express框架建立在node.js内置的http模块上。http模块生成服务器的原始代码如下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line"><span class="keyword">var</span> app = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">  response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>&#125;);</span><br><span class="line">  response.end(<span class="string">"Hello world!"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="string">"localhost"</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码的关键是http模块的createServer方法，表示生成一个HTTP服务器实例。该方法接受一个回调函数，该回调函数的参数，分别为代表HTTP请求和HTTP回应的request对象和response对象。</p>
<p>Express框架的核心是对http模块的再包装。上面的代码用Express改写如下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.send(<span class="string">'Hello world!'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<p>比较两段代码，可以看到它们非常接近。原来是用<code>http.createServer</code>方法新建一个app实例，现在则是用Express的构造方法，生成一个Epress实例。两者的回调函数都是相同的。Express框架等于在http模块之上，加了一个中间层。</p>
<h3 id="什么是中间件"><a href="#什么是中间件" class="headerlink" title="什么是中间件"></a>什么是中间件</h3><p>简单说，中间件（middleware）就是处理HTTP请求的函数。它最大的特点就是，一个中间件处理完，再传递给下一个中间件。App实例在运行过程中，会调用一系列的中间件。</p>
<p>每个中间件可以从App实例，接收三个参数，依次为request对象（代表HTTP请求）、response对象（代表HTTP回应），next回调函数（代表下一个中间件）。每个中间件都可以对HTTP请求（request对象）进行加工，并且决定是否调用next方法，将request对象再传给下一个中间件。</p>
<p>一个不进行任何操作、只传递request对象的中间件，就是下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uselessMiddleware</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码的next就是下一个中间件。如果它带有参数，则代表抛出一个错误，参数为错误文本。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uselessMiddleware</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  next(<span class="string">'出错了！'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抛出错误以后，后面的中间件将不再执行，直到发现一个错误处理函数为止。</p>
<h3 id="use方法"><a href="#use方法" class="headerlink" title="use方法"></a>use方法</h3><p>use是express注册中间件的方法，它返回一个函数。下面是一个连续调用两个中间件的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">request, response, next</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"In comes a "</span> + request.method + <span class="string">" to "</span> + request.url);</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">  response.writeHead(<span class="number">200</span>, &#123; <span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span> &#125;);</span><br><span class="line">  response.end(<span class="string">"Hello world!\n"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">http.createServer(app).listen(<span class="number">1337</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码使用<code>app.use</code>方法，注册了两个中间件。收到HTTP请求后，先调用第一个中间件，在控制台输出一行信息，然后通过<code>next</code>方法，将执行权传给第二个中间件，输出HTTP回应。由于第二个中间件没有调用<code>next</code>方法，所以request对象就不再向后传递了。</p>
<p><code>use</code>方法内部可以对访问路径进行判断，据此就能实现简单的路由，根据不同的请求网址，返回不同的网页内容。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">request, response, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (request.url == <span class="string">"/"</span>) &#123;</span><br><span class="line">    response.writeHead(<span class="number">200</span>, &#123; <span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span> &#125;);</span><br><span class="line">    response.end(<span class="string">"Welcome to the homepage!\n"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">request, response, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (request.url == <span class="string">"/about"</span>) &#123;</span><br><span class="line">    response.writeHead(<span class="number">200</span>, &#123; <span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span> &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">  response.writeHead(<span class="number">404</span>, &#123; <span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span> &#125;);</span><br><span class="line">  response.end(<span class="string">"404 error!\n"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">http.createServer(app).listen(<span class="number">1337</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码通过<code>request.url</code>属性，判断请求的网址，从而返回不同的内容。注意，<code>app.use</code>方法一共登记了三个中间件，只要请求路径匹配，就不会将执行权交给下一个中间件。因此，最后一个中间件会返回404错误，即前面的中间件都没匹配请求路径，找不到所要请求的资源。</p>
<p>除了在回调函数内部判断请求的网址，use方法也允许将请求网址写在第一个参数。这代表，只有请求路径匹配这个参数，后面的中间件才会生效。无疑，这样写更加清晰和方便。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.use(<span class="string">'/path'</span>, someMiddleware);</span><br></pre></td></tr></table></figure>

<p>上面代码表示，只对根目录的请求，调用某个中间件。</p>
<p>因此，上面的代码可以写成下面的样子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">"/home"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">request, response, next</span>) </span>&#123;</span><br><span class="line">  response.writeHead(<span class="number">200</span>, &#123; <span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span> &#125;);</span><br><span class="line">  response.end(<span class="string">"Welcome to the homepage!\n"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">"/about"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">request, response, next</span>) </span>&#123;</span><br><span class="line">  response.writeHead(<span class="number">200</span>, &#123; <span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span> &#125;);</span><br><span class="line">  response.end(<span class="string">"Welcome to the about page!\n"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">  response.writeHead(<span class="number">404</span>, &#123; <span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span> &#125;);</span><br><span class="line">  response.end(<span class="string">"404 error!\n"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">http.createServer(app).listen(<span class="number">1337</span>);</span><br></pre></td></tr></table></figure>



<h2 id="Express的方法"><a href="#Express的方法" class="headerlink" title="Express的方法"></a>Express的方法</h2><h3 id="all方法和HTTP动词方法"><a href="#all方法和HTTP动词方法" class="headerlink" title="all方法和HTTP动词方法"></a>all方法和HTTP动词方法</h3><p>针对不同的请求，Express提供了use方法的一些别名。比如，上面代码也可以用别名的形式来写。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line">app.all(<span class="string">"*"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">request, response, next</span>) </span>&#123;</span><br><span class="line">  response.writeHead(<span class="number">200</span>, &#123; <span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span> &#125;);</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">"/"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">  response.end(<span class="string">"Welcome to the homepage!"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">"/about"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">  response.end(<span class="string">"Welcome to the about page!"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">"*"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">  response.end(<span class="string">"404!"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">http.createServer(app).listen(<span class="number">1337</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码的all方法表示，所有请求都必须通过该中间件，参数中的“*”表示对所有路径有效。get方法则是只有GET动词的HTTP请求通过该中间件，它的第一个参数是请求的路径。由于get方法的回调函数没有调用next方法，所以只要有一个中间件被调用了，后面的中间件就不会再被调用了。</p>
<p>除了get方法以外，Express还提供post、put、delete方法，即HTTP动词都是Express的方法。</p>
<p>这些方法的第一个参数，都是请求的路径。除了绝对匹配以外，Express允许模式匹配。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">"/hello/:who"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.end(<span class="string">"Hello, "</span> + req.params.who + <span class="string">"."</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码将匹配“/hello/alice”网址，网址中的alice将被捕获，作为req.params.who属性的值。需要注意的是，捕获后需要对网址进行检查，过滤不安全字符，上面的写法只是为了演示，生产中不应这样直接使用用户提供的值。</p>
<p>如果在模式参数后面加上问号，表示该参数可选。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">'/hello/:who?'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(req.params.id) &#123;</span><br><span class="line">    	res.end(<span class="string">"Hello, "</span> + req.params.who + <span class="string">"."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    	res.send(<span class="string">"Hello, Guest."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>下面是一些更复杂的模式匹配的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">'/forum/:fid/thread/:tid'</span>, middleware)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配/commits/71dbb9c</span></span><br><span class="line"><span class="comment">// 或/commits/71dbb9c..4c084f9这样的git格式的网址</span></span><br><span class="line">app.get(<span class="regexp">/^\/commits\/(\w+)(?:\.\.(\w+))?$/</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="keyword">from</span> = req.params[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">var</span> to = req.params[<span class="number">1</span>] || <span class="string">'HEAD'</span>;</span><br><span class="line">  res.send(<span class="string">'commit range '</span> + <span class="keyword">from</span> + <span class="string">'..'</span> + to);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h3 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h3><p>set方法用于指定变量的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.set(<span class="string">"views"</span>, __dirname + <span class="string">"/views"</span>);</span><br><span class="line"></span><br><span class="line">app.set(<span class="string">"view engine"</span>, <span class="string">"jade"</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码使用set方法，为系统变量“views”和“view engine”指定值。</p>
<h3 id="response对象"><a href="#response对象" class="headerlink" title="response对象"></a>response对象</h3><p><strong>（1）response.redirect方法</strong></p>
<p>response.redirect方法允许网址的重定向。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">response.redirect(<span class="string">"/hello/anime"</span>);</span><br><span class="line">response.redirect(<span class="string">"http://www.example.com"</span>);</span><br><span class="line">response.redirect(<span class="number">301</span>, <span class="string">"http://www.example.com"</span>);</span><br></pre></td></tr></table></figure>

<p><strong>（2）response.sendFile方法</strong></p>
<p>response.sendFile方法用于发送文件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">response.sendFile(<span class="string">"/path/to/anime.mp4"</span>);</span><br></pre></td></tr></table></figure>

<p><strong>（3）response.render方法</strong></p>
<p>response.render方法用于渲染网页模板。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">"/"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">  response.render(<span class="string">"index"</span>, &#123; <span class="attr">message</span>: <span class="string">"Hello World"</span> &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码使用render方法，将message变量传入index模板，渲染成HTML网页。</p>
<h3 id="requst对象"><a href="#requst对象" class="headerlink" title="requst对象"></a>requst对象</h3><p><strong>（1）request.ip</strong></p>
<p>request.ip属性用于获得HTTP请求的IP地址。</p>
<p><strong>（2）request.files</strong></p>
<p>request.files用于获取上传的文件。</p>
<h3 id="搭建HTTPs服务器"><a href="#搭建HTTPs服务器" class="headerlink" title="搭建HTTPs服务器"></a>搭建HTTPs服务器</h3><p>使用Express搭建HTTPs加密服务器，也很简单。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">  key: fs.readFileSync(<span class="string">'E:/ssl/myserver.key'</span>),</span><br><span class="line">  cert: fs.readFileSync(<span class="string">'E:/ssl/myserver.crt'</span>),</span><br><span class="line">  passphrase: <span class="string">'1234'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> https = <span class="built_in">require</span>(<span class="string">'https'</span>);</span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">  res.send(<span class="string">'Hello World Expressjs'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = https.createServer(options, app);</span><br><span class="line">server.listen(<span class="number">8084</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Server is running on port 8084'</span>);</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>致对象</title>
    <url>/yinyiwang/2020/04/22/%E8%87%B4%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/04/22/rS7L4ZChb23kvIE.jpg" alt=""></p>
<p>那时年少爱幻想<br>告别了灯红酒绿<br>来到了零一的世界<br>这是你的世界<br>也是我的梦想</p>
<p>我们厮杀过<br>那一行行灰色<br>见证着我对你的伤害<br>这一根根白发<br>承载着你对我的报复</p>
<p>我们也相爱过<br>为了完美<br>我曾无数次将你雕琢<br>作为回报<br>你曾无数次给我喜悦</p>
<p>这一生<br>大概就这样了<br>待来世<br>我捧你上王座</p>
<p><img src="https://i.loli.net/2020/04/22/bQwtpnWPGA4dfE3.png" alt=""></p>
]]></content>
  </entry>
  <entry>
    <title>Apache-Jmeter简单配置及使用</title>
    <url>/yinyiwang/2020/04/28/Apache-Jmeter%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>ES6_Promise</title>
    <url>/yinyiwang/2020/04/25/ES6-Promise/</url>
    <content><![CDATA[<p>ECMAscript 6 原生提供了 Promise 对象。<br>Promise 对象代表了未来将要发生的事件，用来传递异步操作的消息。</p>
<h3 id="Promise-对象有以下两个特点"><a href="#Promise-对象有以下两个特点" class="headerlink" title="Promise 对象有以下两个特点:"></a>Promise 对象有以下两个特点:</h3><p>1、对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态：</p>
<ul>
<li><code>pending</code>: 初始状态，不是成功或失败状态。</li>
<li><code>fulfilled</code>: 意味着操作成功完成。</li>
<li><code>rejected</code>: 意味着操作失败。</li>
</ul>
<p>只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是 Promise 这个名字的由来，它的英语意思就是「承诺」，表示其他手段无法改变。</p>
<p>2、一旦状态改变，就不会再变，任何时候都可以得到这个结果。</p>
<p>Promise 对象的状态改变，只有两种可能：从 Pending 变为 Resolved 和从 Pending 变为 Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p>
<h3 id="Promise-优缺点"><a href="#Promise-优缺点" class="headerlink" title="Promise 优缺点"></a>Promise 优缺点</h3><p>有了 Promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise 对象提供统一的接口，使得控制异步操作更加容易。</p>
<p>Promise 也有一些缺点。首先，无法取消 Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。第三，当处于 Pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p>
<h3 id="Promise-创建"><a href="#Promise-创建" class="headerlink" title="Promise 创建"></a>Promise 创建</h3><p>要想创建一个 promise 对象、可以使用 new 来调用 Promise 的构造器来进行实例化。<br>下面是创建 promise 的步骤：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 异步处理    </span></span><br><span class="line">    <span class="comment">// 处理结束后、调用resolve 或 reject </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Promise 构造函数包含一个参数和一个带有 resolve（解析）和 reject（拒绝）两个参数的回调。在回调中执行一些操作（例如异步），如果一切都正常，则调用 resolve，否则调用 reject。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myFirstPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 当异步代码执行成功时，我们才会调用resolve(...), </span></span><br><span class="line">    <span class="comment">// 当异步代码失败时就会调用reject(...)</span></span><br><span class="line">    <span class="comment">// 在本例中，我们使用setTimeout(...)来模拟异步代码</span></span><br><span class="line">    <span class="comment">// 实际编码时可能是XHR请求或是HTML5的一些API方法.    </span></span><br><span class="line">	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		resolve(<span class="string">"成功!"</span>); <span class="comment">//代码正常执行！</span></span><br><span class="line">	&#125;, <span class="number">250</span>); </span><br><span class="line">&#125;);  </span><br><span class="line">myFirstPromise.then(<span class="function"><span class="keyword">function</span>(<span class="params">successMessage</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//successMessage的值是上面调用resolve(...)方法传入的值.    </span></span><br><span class="line">    <span class="comment">//successMessage参数不一定非要是字符串类型，这里只是举个例子</span></span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">"Yay! "</span> + successMessage); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>对于已经实例化过的 promise 对象可以调用 promise.then() 方法，传递 resolve 和 reject 方法作为回调。</p>
<p>promise.then() 是 promise 最为常用的方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">promise.then(onFulfilled, onRejected)</span><br></pre></td></tr></table></figure>

<p>promise简化了对error的处理，上面的代码我们也可以这样写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">promise.then(onFulfilled).catch(onRejected)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Promise-Ajax"><a href="#Promise-Ajax" class="headerlink" title="Promise Ajax"></a>Promise Ajax</h2><p>下面是一个用 Promise 对象实现的 Ajax 操作的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">URL</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        req.open(<span class="string">'GET'</span>, URL, <span class="literal">true</span>);</span><br><span class="line">        req.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (req.status === <span class="number">200</span>) &#123;</span><br><span class="line">                resolve(req.responseText);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                reject(<span class="keyword">new</span> <span class="built_in">Error</span>(req.statusText));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        req.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            reject(<span class="keyword">new</span> <span class="built_in">Error</span>(req.statusText));</span><br><span class="line">        &#125;;</span><br><span class="line">        req.send();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> URL = <span class="string">"/try/ajax/testpromise.php"</span>;</span><br><span class="line">ajax(URL).then(<span class="function"><span class="keyword">function</span> <span class="title">onFulfilled</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">'内容是：'</span> + value);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> <span class="title">onRejected</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">'错误：'</span> + error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，resolve 方法和 reject 方法调用时，都带有参数。它们的参数会被传递给回调函数。</p>
<p>reject 方法的参数通常是 Error 对象的实例，而 resolve 方法的参数除了正常的值以外，还可能是另一个 Promise 实例，比如像下面这样。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ... some code</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ... some code  resolve(p1);</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上面代码中，p1 和 p2 都是 Promise 的实例，但是 p2 的 resolve 方法将 p1 作为参数，这时 p1 的状态就会传递给 p2。如果调用的时候，p1 的状态是 pending，那么 p2 的回调函数就会等待 p1 的状态改变；如果 p1 的状态已经是 fulfilled 或者 rejected，那么 p2 的回调函数将会立刻执行。</p>
<hr>
<h2 id="Promise-prototype-then方法：链式操作"><a href="#Promise-prototype-then方法：链式操作" class="headerlink" title="Promise.prototype.then方法：链式操作"></a>Promise.prototype.then方法：链式操作</h2><p>Promise.prototype.then 方法返回的是一个新的 Promise 对象，因此可以采用链式写法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getJSON(<span class="string">"/posts.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> json.post;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// proceed</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面的代码使用 then 方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</p>
<p>如果前一个回调函数返回的是Promise对象，这时后一个回调函数就会等待该Promise对象有了运行结果，才会进一步调用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getJSON(<span class="string">"/post/1.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getJSON(post.commentURL);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">comments</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对comments进行处理</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这种设计使得嵌套的异步操作，可以被很容易得改写，从回调函数的”横向发展”改为”向下发展”。</p>
<hr>
<h2 id="Promise-prototype-catch方法：捕捉错误"><a href="#Promise-prototype-catch方法：捕捉错误" class="headerlink" title="Promise.prototype.catch方法：捕捉错误"></a>Promise.prototype.catch方法：捕捉错误</h2><p>Promise.prototype.catch 方法是 Promise.prototype.then(null, rejection) 的别名，用于指定发生错误时的回调函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getJSON(<span class="string">"/posts.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">posts</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// some code</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 处理前一个回调函数运行时发生的错误</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'发生错误！'</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Promise 对象的错误具有”冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个 catch 语句捕获。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getJSON(<span class="string">"/post/1.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getJSON(post.commentURL);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">comments</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// some code</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 处理前两个回调函数的错误</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Promise-all方法，Promise-race方法"><a href="#Promise-all方法，Promise-race方法" class="headerlink" title="Promise.all方法，Promise.race方法"></a>Promise.all方法，Promise.race方法</h2><p>Promise.all 方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.all([p1,p2,p3]);</span><br></pre></td></tr></table></figure>

<p>上面代码中，Promise.all 方法接受一个数组作为参数，p1、p2、p3 都是 Promise 对象的实例。（Promise.all 方法的参数不一定是数组，但是必须具有 <strong>iterator 接口</strong>，且返回的每个成员都是 Promise 实例。）</p>
<p>p 的状态由 p1、p2、p3 决定，分成两种情况。</p>
<ul>
<li>只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。</li>
<li>只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。</li>
</ul>
<p>下面是一个具体的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成一个Promise对象的数组 </span></span><br><span class="line"><span class="keyword">var</span> promises = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>].map(<span class="function"><span class="keyword">function</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getJSON(<span class="string">"/post/"</span> + id + <span class="string">".json"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Promise</span>.all(promises).then(<span class="function"><span class="keyword">function</span>(<span class="params">posts</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Promise.race 方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.race([p1,p2,p3]);</span><br></pre></td></tr></table></figure>

<p>上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的Promise实例的返回值，就传递给p的返回值。</p>
<p>如果Promise.all方法和Promise.race方法的参数，不是Promise实例，就会先调用下面讲到的Promise.resolve方法，将参数转为Promise实例，再进一步处理。</p>
<hr>
<h2 id="Promise-resolve-方法，Promise-reject-方法"><a href="#Promise-resolve-方法，Promise-reject-方法" class="headerlink" title="Promise.resolve 方法，Promise.reject 方法"></a>Promise.resolve 方法，Promise.reject 方法</h2><p>有时需要将现有对象转为Promise对象，Promise.resolve方法就起到这个作用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> jsPromise = <span class="built_in">Promise</span>.resolve($.ajax(<span class="string">'/whatever.json'</span>));</span><br></pre></td></tr></table></figure>

<p>上面代码将 jQuery 生成 deferred 对象，转为一个新的 ES6 的 Promise 对象。</p>
<p>如果 Promise.resolve 方法的参数，不是具有 then 方法的对象（又称 thenable 对象），则返回一个新的 Promise 对象，且它的状态为fulfilled。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve(<span class="string">'Hello'</span>);</span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span> (<span class="params">s</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(s)</span><br><span class="line">&#125;); </span><br><span class="line"><span class="comment">// Hello</span></span><br></pre></td></tr></table></figure>

<p>上面代码生成一个新的Promise对象的实例p，它的状态为<code>fulfilled</code>，所以回调函数会立即执行，Promise.resolve方法的参数就是回调函数的参数。</p>
<p>如果Promise.resolve方法的参数是一个Promise对象的实例，则会被原封不动地返回。</p>
<p>Promise.reject(reason)方法也会返回一个新的Promise实例，该实例的状态为<code>rejected</code>。Promise.reject方法的参数reason，会被传递给实例的回调函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.reject(<span class="string">'出错了'</span>);</span><br><span class="line">p.then(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span> (<span class="params">s</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(s)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure>

<p>上面代码生成一个Promise对象的实例p，状态为<code>rejected</code>，回调函数会立即执行。</p>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>最全面的Cookie知识点总结</title>
    <url>/yinyiwang/2020/09/25/%E6%9C%80%E5%85%A8%E9%9D%A2%E7%9A%84Cookie%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><img src="/Users/wangzhijie/Public/%E5%B7%A5%E4%BD%9C/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Cookie%20%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/images/%E6%96%87%E7%AB%A0%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="文章架构图"></p>
<blockquote>
<p>完整阅读本文大约需要二十分钟时间，可根据文章结构图直接阅读自己需要的部分。</p>
</blockquote>
<h2 id="1-Cookie-产生的背景"><a href="#1-Cookie-产生的背景" class="headerlink" title="1. Cookie 产生的背景"></a>1. Cookie 产生的背景</h2><blockquote>
<p>所有新技术的出现都是为了解决某一痛点。 ——《前端三昧》</p>
</blockquote>
<p>我们都知道，<code>HTTP 协议</code>是==无状态的==，服务器无法知道两个请求是否来自同一个浏览器，也不知道用户上一次做了什么，每次请求都是完全相互独立，这严重阻碍了<code>交互式 Web</code> 应用程序的实现。例子：</p>
<ul>
<li>购物车：在典型的网上购物场景中，用户浏览了几个页面，买了一盒饼干和两瓶饮料。最后结帐时，由于 <code>HTTP</code> 的无状态性，不通过额外的手段，服务器并不知道用户到底买了什么。</li>
<li>登录状态：我们常用的“记住密码”功能，在以前如果不是用 <code>Cookie</code> 记住了登录凭据，想要实现该功能将会很复杂。</li>
</ul>
<p>正是为了解决这些交互方面存在的痛点，<code>Cookie</code> 应运而生。</p>
<h2 id="2-Cookie-概述"><a href="#2-Cookie-概述" class="headerlink" title="2. Cookie 概述"></a>2. Cookie 概述</h2><blockquote>
<p> <code>Cookie</code>（ 也叫 <code>Web Cookie</code> 或<code>浏览器  Cookie</code> ）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。</p>
</blockquote>
<p>存储 <code>Cookie</code> 是浏览器提供的功能。<code>Cookie</code>  其实是存储在浏览器中的纯文本，浏览器的安装目录下会专门有一个  <code>Cookie</code>  文件夹来存放各个域下设置的 <code>Cookie</code>（非内存 <code>Cookie</code>）。</p>
<p><img src="/Users/wangzhijie/Public/%E5%B7%A5%E4%BD%9C/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Cookie%20%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/images/Cookie%E5%AD%98%E6%94%BE%E7%9A%84%E4%BD%8D%E7%BD%AE.png" alt="Cookie存放的位置"></p>
<p>通常，它用于==告知服务端两个请求是否来自同一浏览器==，或者用来==保存一些状态信息==，<code>Cookie</code>  使基于无状态的 <code>HTTP</code> 协议记录稳定的状态信息成为了可能。常用的有以下方面：</p>
<ul>
<li>对话（<code>session</code>）管理：保存登录、购物车等需要记录的信息。</li>
<li>简单的缓存：存储一些简单的业务数据，比如购物车等需要记录的信息。</li>
<li>个性化：保存用户的偏好，比如网页的字体大小、背景色等等。</li>
<li>追踪：记录和分析用户行为。</li>
</ul>
<blockquote>
<p><code>Cookie</code> 主要是用来存储状态的。</p>
</blockquote>
<p><code>Cookie</code> 曾一度用于客户端数据的存储，因当时并没有其它合适的存储办法而作为唯一的存储手段。现在来说，这样做虽然可行，但是并不推荐，因为 <code>Cookie</code> 的设计目标并不是这个，它:</p>
<ul>
<li>容量很小（ 4KB ）</li>
<li>缺乏数据操作接口</li>
<li>影响性能</li>
</ul>
<p>客户端储存应该更多的考虑使用 <code>localStorage</code> 、<code>sesseionStorage</code> 和 <code>IndexedDB</code>。</p>
<p>查看浏览器上存储的 <code>Cookie</code> 的方法如下图：</p>
<p><img src="/Users/wangzhijie/Public/%E5%B7%A5%E4%BD%9C/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Cookie%20%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/images/%E6%9F%A5%E7%9C%8BCookie%E7%9A%84%E6%AD%A5%E9%AA%A4%E5%92%8C%E6%96%B9%E6%B3%95.png" alt="查看Cookie的步骤和方法"></p>
<p>当然，浏览器可以设置不接受 <code>Cookie</code>，也可以设置不向服务器发送 <code>Cookie</code>。<code>window.navigator.cookieEnabled</code>属性返回一个布尔值，表示浏览器是否打开 <code>Cookie</code> 功能。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 浏览器是否打开 Cookie 功能</span></span><br><span class="line"><span class="built_in">window</span>.navigator.cookieEnabled <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>本文所有的讨论都是在浏览器的 <code>window.navigator.cookieEnabled</code> 为 ==true== 的前提下进行的。</p>
</blockquote>
<h2 id="3-Cookie-的工作流程"><a href="#3-Cookie-的工作流程" class="headerlink" title="3. Cookie 的工作流程"></a>3. <code>Cookie</code> 的工作流程</h2><p><img src="/Users/wangzhijie/Public/%E5%B7%A5%E4%BD%9C/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Cookie%20%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/images/Cookie%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt="Cookie的工作原理"></p>
<h2 id="4-Cookie-的限制"><a href="#4-Cookie-的限制" class="headerlink" title="4. Cookie 的限制"></a>4. Cookie 的限制</h2><h3 id="4-1-格式限制"><a href="#4-1-格式限制" class="headerlink" title="4.1 格式限制"></a>4.1 格式限制</h3><p><code>Cookie</code> 只能存储纯文本格式，因为：</p>
<ul>
<li>每条 <code>Cookie</code> 的大小有限制</li>
<li>为用户信息安全考虑，<code>Cookie</code> 中存储的是不可执行语句</li>
</ul>
<h3 id="4-2-大小和条数限制"><a href="#4-2-大小和条数限制" class="headerlink" title="4.2 大小和条数限制"></a>4.2 大小和条数限制</h3><p>由于 <code>Cookie</code> 是保存在客户端上的，所以浏览器加入了一些限制确保 <code>Cookie</code> 不会被恶意使用，同时不会占据太多磁盘空间，所以 <code>Cookie</code> 的数量和大小是有限的。</p>
<p>不同浏览器对 <code>Cookie</code> 数量和大小的限制，是不一样的。一般来说，单个域设置的 <code>Cookie</code> 不应超过 ==50个==，每个 Cookie 的大小不能超过 ==4KB== 。超过限制以后，<code>Cookie</code> 将被==忽略==，不会被设置。</p>
<blockquote>
<p>其限制的原因，主要在于阻止 <code>Cookie</code> 的滥用，而且 <code>Cookie</code> 会被发送到服务器端，如果数量太大的话，会严重影响请求的性能。以上这两个限制条件，就是 <code>Cookie</code> 为什么会被浏览器自动删除的原因了。</p>
</blockquote>
<h3 id="4-3-域限制"><a href="#4-3-域限制" class="headerlink" title="4.3 域限制"></a>4.3 域限制</h3><p>不可跨域读取，<code>Cookie</code> 是被哪个域写入的，就只能被这个域及其子域读取。比如：</p>
<p>由 <code>test.com</code> 写入的 <code>Cookie</code> 可以被 <code>test.com</code> 和 <code>test.com/child</code> 读取，而不能被 <code>example.com</code> 读取。</p>
<h3 id="4-4-路径限制"><a href="#4-4-路径限制" class="headerlink" title="4.4 路径限制"></a>4.4 路径限制</h3><p>存储 <code>Cookie</code> 时会指定路径，该路径的子级可以读取该 <code>Cookie</code>，但是它的父级却读取不到——==子可以读取父，但父不能拿到子==，例如：</p>
<p>由 <code>test.com/parent/child</code> 存储下的 <code>Cookie</code>，可以被 <code>test.com/parent/child/child</code> 读取，但不能被 <code>test.com/parent</code> 读取。</p>
<blockquote>
<p>一般会将 <code>Cookie</code> 存在根路径下，可以避免这种情况的发生。</p>
</blockquote>
<h3 id="4-5-时效限制"><a href="#4-5-时效限制" class="headerlink" title="4.5 时效限制"></a>4.5 时效限制</h3><p>每个 <code>Cookie</code> 都有时效性，默认的有效期是==会话级别==（ <code>Seesion Cookie</code> ）：就是当浏览器关闭，那么 <code>Cookie</code> 立即销毁，但是我们也可以在存储的时候手动设置  <code>Cookie</code> 的过期时间，具体设置方法会在下文讲到。</p>
<h2 id="5-Cookie-的属性"><a href="#5-Cookie-的属性" class="headerlink" title="5.  Cookie 的属性"></a>5.  Cookie 的属性</h2><p><img src="/Users/wangzhijie/Public/%E5%B7%A5%E4%BD%9C/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Cookie%20%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/images/Cookie%E7%9A%84%E5%B1%9E%E6%80%A7.png" alt="Cookie的属性"></p>
<h3 id="5-1-Name-Value"><a href="#5-1-Name-Value" class="headerlink" title="5.1 Name/Value"></a>5.1 Name/Value</h3><p>设置 <code>Cookie</code> 的名称及相对应的值，对于认证 <code>Cookie</code>，<code>Value</code> 值包括 <code>Web</code> 服务器所提供的访问令牌 。</p>
<h3 id="5-2-Domain"><a href="#5-2-Domain" class="headerlink" title="5.2 Domain"></a>5.2 Domain</h3><p>指定了可以访问该 <code>Cookie</code> 的 Web 站点或域。</p>
<p><code>Cookie</code> 机制并未遵循严格的同源策略，允许一个子域可以设置或获取其父域的 <code>Cookie</code>。</p>
<p>当需要实现单点登录方案时，<code>Cookie</code> 的上述特性非常有用，然而也增加了 <code>Cookie</code> 受攻击的危险，比如攻击者可以借此发动会话定置攻击。因而，浏览器禁止在 <code>Domain</code> 属性中设置 .org、.com 等通用顶级域名、以及在国家及地区顶级域下注册的二级域名，以减小攻击发生的范围。</p>
<h3 id="5-3-Path"><a href="#5-3-Path" class="headerlink" title="5.3 Path"></a>5.3 Path</h3><p><code>Path</code> 标识指定了主机下的哪些路径可以接受 <code>Cookie</code>（该 URL 路径必须存在于请求 URL 中）。以字符 <code>%x2F (&quot;/&quot;)</code>  作为路径分隔符，子路径也会被匹配。</p>
<h3 id="5-4-Expires-Max-Age"><a href="#5-4-Expires-Max-Age" class="headerlink" title="5.4 Expires/Max-Age"></a>5.4 Expires/Max-Age</h3><p>设置 <code>Cookie</code> 的生存期。有两种存储类型的 <code>Cookie</code> ：会话性与持久性。</p>
<p><code>Expires</code> 属性指定一个具体的到期时间，到了这个指定的时间之后，浏览器就不再保留这个 <code>Cookie</code> ,它的值是 UTC 格式，可以使用 <code>Date.prototype.toUTCString()</code>  格式进行转换。</p>
<p><code>Max-Age</code> 属性制定了从现在开始 <code>Cookie</code> 存在的秒数，比如 60 * 60 * 24 * 365（即一年）。过了这个时间以后，浏览器就不再保留这个 <code>Cookie</code></p>
<blockquote>
<p>如果没有设置这两个选项，则会使用默认值。 <code>domain</code> 的默认值为设置该 <code>Cookie</code> 的网页所在的域名， <code>path</code> 默认值为设置该 <code>Cookie</code> 的网页所在的目录。</p>
</blockquote>
<ul>
<li><code>Expires</code> 属性缺省时，为会话性 <code>Cookie(Session Cookie)</code> ，仅保存在客户端内存中，并在用户关闭浏览器时失效。</li>
<li>持久性 <code>Cookie</code> 会保存在用户的硬盘中，直至生存期到或用户直接在网页中单击“注销”等按钮结束会话时才会失效。</li>
</ul>
<blockquote>
<p>当 <code>Cookie</code> 的过期时间被设定时，设定的日期和时间只与客户端相关，而不是服务端。</p>
</blockquote>
<h3 id="5-5-HTTPOnly"><a href="#5-5-HTTPOnly" class="headerlink" title="5.5 HTTPOnly"></a>5.5 HTTPOnly</h3><p>这个选项用来设置 <code>Cookie</code> 是否能通过 <code>JavaScript</code> 去访问。默认情况下， <code>Cookie</code> 不会带 <code>HTTPOnly</code> 选项(即为空)，所以默认情况下，客户端是可以通过 <code>JavaScript</code> 代码去访问（包括读取、修改、删除等）这个 <code>Cookie</code> 的。当 <code>Cookie</code> 带 <code>HTTPOnly</code> 选项时，客户端则无法通过js代码去访问（包括读取、修改、删除等）这个 <code>Cookie</code> 。</p>
<p>用于防止客户端脚本通过 <code>document.cookie</code> 属性访问 <code>Cookie</code> ，有助于保护 <code>Cookie</code> 不被跨站脚本攻击窃取或篡改。但是，<code>HTTPOnly</code> 的应用仍存在局限性，一些浏览器可以阻止客户端脚本对 <code>Cookie</code> 的读操作，但允许写操作；此外大多数浏览器仍允许通过 <code>XMLHTTP</code> 对象读取 <code>HTTP</code> 响应中的 <code>Set-Cookie</code> 头  。</p>
<blockquote>
<p>在客户端是不能通过 <code>JAvaScript</code> 代码去设置一个 <code>httpOnly</code> 类型的 <code>Cookie</code> 的，这种类型的 <code>Cookie</code> 只能通过服务端来设置。</p>
</blockquote>
<h3 id="5-6-Secure"><a href="#5-6-Secure" class="headerlink" title="5.6 Secure"></a>5.6 Secure</h3><p>指定是否使用 <code>HTTPS</code> 安全协议发送 <code>Cookie</code> 。</p>
<p>使用 <code>HTTPS</code> 安全协议，可以保护 <code>Cookie</code> 在浏览器和 <code>Web</code> 服务器间的传输过程中不被窃取和篡改。该方法也可用于 <code>Web</code> 站点的身份鉴别，即在 <code>HTTPS</code> 的连接建立阶段，浏览器会检查 <code>Web</code> 网站的 <code>SSL</code> 证书的有效性。</p>
<p>但是基于兼容性的原因（比如有些网站使用自签署的证书）在检测到 <code>SSL</code> 证书无效时，浏览器并不会立即终止用户的连接请求，而是显示安全风险信息，用户仍可以选择继续访问该站点。由于许多用户缺乏安全意识，因而仍可能连接到 <code>Pharming</code> 攻击所伪造的网站 。</p>
<blockquote>
<p>如果当前协议是 HTTP，浏览器会自动忽略服务器发来的 Secure。</p>
</blockquote>
<h3 id="5-7-SameSite"><a href="#5-7-SameSite" class="headerlink" title="5.7 SameSite"></a>5.7 SameSite</h3><p><code>Cookie</code> 允许服务器要求某个 <code>Cookie</code> 在跨站请求时不会被发送，（其中 <code>Site</code> 由可注册域定义），从而可以阻止跨站请求伪造攻击（<code>CSRF</code>）。</p>
<p><code>SameSite cookies</code> 是相对较新的一个字段，所有主流浏览器都已经得到支持。下面是例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set</span>-Cookie: key=value; SameSite=Strict</span><br></pre></td></tr></table></figure>

<p><code>SameSite</code> 可以有下面三种值：</p>
<ul>
<li><strong><code>None</code></strong>。浏览器会在同站请求、跨站请求下继续发送 <code>Cookies</code>，不区分大小写。</li>
<li><strong><code>Strict</code>。</strong>浏览器将只在访问相同站点时发送 <code>Cookie</code>。（在原有 <code>Cookies</code> 的限制条件上的加强）。</li>
<li><strong><code>Lax</code>。</strong>与 <strong><code>Strict</code></strong> 类似，但用户从外部站点导航至URL时（例如通过链接）除外。 在新版本浏览器中，为默认选项，<code>Same-site cookies</code> 将会为一些跨站子请求保留，如图片加载或者 <code>frames</code> 的调用，但只有当用户从外部站点导航到 <code>URL</code> 时才会发送。如 link 链接。</li>
</ul>
<blockquote>
<p>以前，如果 <code>SameSite</code> 属性没有设置，或者没有得到运行浏览器的支持，那么它的行为等同于 <code>None</code>，<code>Cookies</code> 会被包含在任何请求中——包括跨站请求。</p>
<p>大多数主流浏览器正在将 <code>SameSite</code> 的默认值迁移至 <code>Lax</code>。如果想要指定 <code>Cookies</code> 在同站、跨站请求都被发送，现在需要明确指定 <code>SameSite</code>  为 <code>None</code>。</p>
</blockquote>
<h3 id="5-8-Cookie-prefixes"><a href="#5-8-Cookie-prefixes" class="headerlink" title="5.8 Cookie prefixes"></a>5.8 Cookie prefixes</h3><p><code>Cookie</code> 机制的使得服务器无法确认  <code>Cookie</code>  是在安全来源上设置的，甚至无法确定   <code>Cookie</code>   最初是在哪里设置的。</p>
<p>子域上的易受攻击的应用程序可以使用 <code>Domain</code> 属性设置  <code>Cookie</code>  ，从而可以访问所有其他子域上的该   <code>Cookie</code>  。会话定置攻击中可能会滥用此机制。</p>
<p>但是，作为 <code>深度防御措施</code>，可以使用 <code>Cookie</code> 前缀来断言有关  <code>Cookie</code>  的特定事实。有两个前缀可用：</p>
<ul>
<li><p><strong><code>__Host-</code></strong></p>
<p>  如果    <code>Cookie</code>  名称具有此前缀，则仅当它也用 <code>Secure</code> 属性标记，是从安全来源发送的，不包括 <code>Domain</code> 属性，并将 <code>Path</code> 属性设置为 <code>/</code> 时，它才在 <code>Set-Cookie</code> 标头中接受。这样，这些 <code>Cookie</code> 可以被视为 “<code>domain-locked</code>”。</p>
</li>
<li><p><strong><code>__Secure-</code></strong></p>
<p>  如果 <code>Cookie</code> 名称具有此前缀，则仅当它也用 <code>Secure</code> 属性标记，是从安全来源发送的，它才在 <code>Set-Cookie</code> 标头中接受。该前缀限制要弱于 <code>__Host-</code> 前缀。</p>
</li>
</ul>
<p>带有这些前缀点 <code>Cookie</code>， 如果不符合其限制的会被浏览器拒绝。请注意，这确保了如果子域要创建带有前缀的  <code>Cookie</code>，那么它将要么局限于该子域，要么被完全忽略。由于应用服务器仅在确定用户是否已通过身份验证或 CSRF 令牌正确时才检查特定的  <code>Cookie</code>  名称，因此，这有效地充当了针对会话劫持的防御措施。</p>
<p><code>Cookie</code> 各个属性的兼容性如下图所示：</p>
<p><img src="/Users/wangzhijie/Public/%E5%B7%A5%E4%BD%9C/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Cookie%20%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/images/Cookie%E5%B1%9E%E6%80%A7%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7.png" alt="Cookie属性的兼容性"></p>
<h2 id="6-HTTP-Cookie-和-document-cookie"><a href="#6-HTTP-Cookie-和-document-cookie" class="headerlink" title="6. HTTP Cookie 和 document.cookie"></a>6. HTTP Cookie 和 document.cookie</h2><h3 id="6-1-HTTP-Cookie"><a href="#6-1-HTTP-Cookie" class="headerlink" title="6.1 HTTP Cookie"></a>6.1 HTTP Cookie</h3><p>服务器如果希望在浏览器保存 <code>Cookie</code>，就要在 <code>HTTP</code> 回应的头信息里面，放置一个<code>Set-Cookie</code>字段。</p>
<p><img src="/Users/wangzhijie/Public/%E5%B7%A5%E4%BD%9C/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Cookie%20%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/images/HTTP%E8%AE%BE%E7%BD%AECookie.png" alt="HTTP设置Cookie"></p>
<p>浏览器收到响应后通常会保存下 <code>Cookie</code>，之后对该服务器每一次请求中都通过  <code>Cookie</code> 请求头部将 <code>Cookie</code> 信息发送给服务器。另外，<code>Cookie</code> 的过期时间、域、路径、有效期、适用站点都可以根据需要来指定。</p>
<p><code>HTTP</code> 回应可以包含多个 <code>Set-Cookie</code> 字段，即在浏览器生成多个 <code>Cookie</code>。下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">HTTP/<span class="number">1.0</span> <span class="number">200</span> OK</span><br><span class="line">Content-type: text/html</span><br><span class="line"><span class="built_in">Set</span>-Cookie: yummy_cookie=choco</span><br><span class="line"><span class="built_in">Set</span>-Cookie: tasty_cookie=strawberry</span><br><span class="line"></span><br><span class="line">[page content]</span><br></pre></td></tr></table></figure>

<p>除了 <code>Cookie</code> 的值，<code>Set-Cookie</code>字段还可以附加 <code>Cookie</code> 的属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set</span>-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Expires=&lt;date&gt;</span><br><span class="line">Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Max-Age=&lt;non-zero-digit&gt;</span><br><span class="line">Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Domain=&lt;domain-value&gt;</span><br><span class="line">Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Path=&lt;path-value&gt;</span><br><span class="line">Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Secure</span><br><span class="line">Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; HttpOnly</span><br></pre></td></tr></table></figure>

<p>一个 <code>Set-Cookie</code> 字段里面，可以同时包括多个属性，没有次序的要求。</p>
<blockquote>
<p>如果服务器想改变一个早先设置的 <code>Cookie</code>，必须同时满足四个条件：<code>Cookie</code> 的 <code>key</code>、<code>domain</code>、<code>path</code> 和 <code>secure</code> 都匹配。否则，会创建一个新的 <code>Cookie</code>。</p>
</blockquote>
<p>浏览器接收了响应头提供的 <code>Cookie</code> 之后，每一次访问该域时，都会携带该 <code>Cookie</code> 值：</p>
<p><img src="/Users/wangzhijie/Public/%E5%B7%A5%E4%BD%9C/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Cookie%20%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/images/HTTP%E7%9A%84%E8%AF%B7%E6%B1%82%E5%A4%B4%E4%B8%AD%E6%90%BA%E5%B8%A6Cookie.png" alt="HTTP的请求头中携带Cookie"></p>
<p><code>Cookie</code> 字段可以包含多个 Cookie，使用分号（<code>;</code>）分隔。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">GET /sample_page.html HTTP/<span class="number">1.1</span></span><br><span class="line">Host: www.example.org</span><br><span class="line">Cookie: yummy_cookie=choco; tasty_cookie=strawberry</span><br></pre></td></tr></table></figure>

<h3 id="6-2-document-cookie"><a href="#6-2-document-cookie" class="headerlink" title="6.2 document.cookie"></a>6.2 document.cookie</h3><p>通过 <code>document.cookie</code> 属性可创建新的 <code>Cookie</code>，也可通过该属性访问==非 HttpOnly== 标记的 <code>Cookie</code>。</p>
<p><img src="/Users/wangzhijie/Public/%E5%B7%A5%E4%BD%9C/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Cookie%20%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/images/Document%E8%8E%B7%E5%8F%96Cookie.png" alt="Document获取Cookie"></p>
<p>上图从 <code>document.cookie</code> 一次性读出多个 <code>Cookie</code>，它们之间使用分号分隔。必须手动还原，才能取出每一个 <code>Cookie</code> 的值。</p>
<p>写入的时候，<code>Cookie</code> 的值必须写成 <code>key=value</code> 的形式。注意，等号两边不能有空格。另外，写入 <code>Cookie</code> 的时候，必须对分号、逗号和空格进行转义（它们都不允许作为 <code>Cookie</code> 的值），这可以用 <code>encodeURIComponent</code> 方法达到。比如，我们要存储一个对象到 <code>Cookie</code>中，可以通过下面代码实现：</p>
<p><img src="/Users/wangzhijie/Public/%E5%B7%A5%E4%BD%9C/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Cookie%20%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/images/document.cookie%E8%AE%BE%E7%BD%AE.png" alt="document.cookie设置"></p>
<p>设置完成后，在浏览器查看：</p>
<p><img src="/Users/wangzhijie/Public/%E5%B7%A5%E4%BD%9C/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Cookie%20%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/images/%E6%9F%A5%E7%9C%8B%E8%AE%BE%E7%BD%AE%E7%9A%84Cookie.png" alt="查看设置的Cookie"></p>
<p>那要怎么才能读取到这次设置的 <code>Cookie</code> 呢？方法如下：</p>
<p><img src="/Users/wangzhijie/Public/%E5%B7%A5%E4%BD%9C/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Cookie%20%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/images/%E8%AF%BB%E5%8F%96%E8%AE%BE%E7%BD%AE%E7%9A%84cookie_people.png" alt="读取设置的cookie_people"></p>
<p>读取到的结果如下：</p>
<p><img src="/Users/wangzhijie/Public/%E5%B7%A5%E4%BD%9C/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Cookie%20%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/images/%E8%AF%BB%E5%8F%96%E8%AE%BE%E7%BD%AE%E7%9A%84cookie.png" alt="读取设置的cookie"></p>
<blockquote>
<p><code>document.cookie</code> 一次只能写入一个 <code>Cookie</code>，而且写入并不是覆盖，而是添加。</p>
</blockquote>
<h2 id="7-Cookie-的安全隐患"><a href="#7-Cookie-的安全隐患" class="headerlink" title="7. Cookie 的安全隐患"></a>7. Cookie 的安全隐患</h2><blockquote>
<p>信息被存在 <code>Cookie</code> 中时，需要明白 <code>Cookie</code> 的值时可以被访问，且可以被终端用户所修改的。根据应用程序的不同，可能需要使用服务器查找的不透明标识符，或者研究诸如 <code>JSON Web Tokens</code> 之类的替代身份验证/机密机制。</p>
<p>当机器处于不安全环境时，切记<em>不能</em>通过 <code>HTTP Cookie</code> 存储、传输敏感信息。</p>
</blockquote>
<h3 id="7-1-Cookie-捕获-重放"><a href="#7-1-Cookie-捕获-重放" class="headerlink" title="7.1 Cookie 捕获/重放"></a>7.1 Cookie 捕获/重放</h3><p>攻击者可以通过木马等恶意程序，或使用跨站脚本攻击等手段偷窃存放在用户硬盘或内存中的 <code>Cookie</code>。借助网络攻击手段，包括：</p>
<ul>
<li>在不安全的局域网中被动地监听网络通信；</li>
<li>通过攻击网络用户的路由器，或通过搭建恶意的无线路由器等手法，控制路由基础设施，将网络流量重定向到攻击者控制的主机；</li>
<li>发动 <code>DNSPharming</code> (域欺骗)攻击，通过 <code>DNS 缓存中毒</code>、<code>DNS 应答欺骗</code>、或修改用户端的本地域名解析文件等方法攻击 <code>DNS</code> 系统，导致用户对合法网站的访问请求被重定向到恶意网站等等，同样可能窃取 <code>Cookie</code>。</li>
</ul>
<p>对于捕获到的认证 <code>Cookie</code>，攻击者往往会猜测其中的访问令牌，试图获取会话ID、用户名与口令、用户角色、时间戳等敏感信息；或者直接重放该 <code>Cookie</code>，假冒受害者的身份发动攻击  。</p>
<h3 id="7-2-恶意-Cookies"><a href="#7-2-恶意-Cookies" class="headerlink" title="7.2 恶意 Cookies"></a>7.2 恶意 Cookies</h3><p><code>Cookies</code> 是文本文件， 一般情况下认为它不会造成安全威胁。 但是，如果在 <code>Cookies</code> 中通过特殊标记语言，引入可执行代码，就很可能给用户造成严重的安全隐患。<code>HTML</code> 为区别普通文本和标记语言，用符号 <code>“&lt;&gt;”</code> 来指示 <code>HTML</code> 代码。 这些 <code>HTML</code> 代码或者定义 <code>Web</code> 网页格式，或者引入 <code>Web</code> 浏览器可执行代码段。 <code>Web</code> 服务 器可以使用 <code>Cookies</code> 信息创建动态网页。假使 <code>Cookies</code> 包含可执行恶意代码段，那么在显示合成有该 <code>Cookies</code> 的网页时，就会自动执行这段恶意代码。当然，恶意代码能否真正造成危害，还取决于 <code>Web</code> 站点的安全配置策略 。</p>
<h3 id="7-3-会话定置"><a href="#7-3-会话定置" class="headerlink" title="7.3 会话定置"></a>7.3 会话定置</h3><p>会话定置(<code>Session Fixation</code>)攻击是指，攻击者向受害者主机注入自己控制的认证 <code>Cookie</code> 等信息，使得受害者以攻击者的身份登录网站，从而窃取受害者的会话信息。</p>
<p>注入 <code>Cookie</code> 的方法包括：</p>
<ul>
<li>使用跨站脚本或木马等恶意程序；</li>
<li>或伪造与合法网站同域的站点，并利用各种方法欺骗用户访问该仿冒网站，从而通过HTTP响应中的Set-Cookie头将攻击者拥有的该域Cookie发送给用户等。</li>
</ul>
<h3 id="7-4-CSRF-攻击"><a href="#7-4-CSRF-攻击" class="headerlink" title="7.4 CSRF 攻击"></a>7.4 CSRF 攻击</h3><p>跨站请求伪造（<code>Cross-Site Request Forgery</code>，简称<code>CSRF</code>）是指：</p>
<p>攻击者可能利用网页中的恶意代码强迫受害者浏览器向被攻击的 <code>Web</code> 站点发送伪造的请求，篡夺受害者的认证 <code>Cookie</code> 等身份信息，从而假冒受害者对目标站点执行指定的操作。</p>
<p>Firefox、Opera 等浏览器使用单进程机制，多个窗口或标签使用同一个进程，共享 <code>Cookie</code> 等会话数据。IE 则混合使用单进程与多进程模式，一个窗口中的多个标签，以及使用 “CTRL+N”  或单击网页中的链接打开的新窗口使用同一进程，共享会话数据；只有直接运行IE可执行程序打开窗口时，才会创建新的进程。Chrome 虽然使用多进程机制，然而经测试发现，其不同的窗口或标签之间仍会共享会话数据，除非使用隐身访问方式。</p>
<p>因而，用户同时打开多个浏览器窗口或标签访问互联网资源时，就为 <code>CSRF</code> 攻击篡夺用户的会话 <code>Cookie</code> 创造了条件。另外，如果一个Web 站点提供持久化 <code>Cookie</code>，则 <code>CSRF</code> 攻击将更直接、更容易。</p>
<blockquote>
<p>缓解 Cookie 攻击的方法如下：</p>
<ul>
<li>对用户输入进行过滤来阻止 XSS；</li>
<li>任何敏感操作都需要确认；</li>
<li>用于敏感信息的 Cookie 只能拥有较短的生命周期；</li>
</ul>
</blockquote>
<h2 id="8-安全使用-Cookie"><a href="#8-安全使用-Cookie" class="headerlink" title="8. 安全使用 Cookie"></a>8. 安全使用 Cookie</h2><p>有两种方法可以确保 <code>Cookie</code> 被安全发送，并且不会被意外的参与者或脚本访问：<code>Secure</code> 属性和 <code>HttpOnly</code> 属性。</p>
<p>标记为 <code>Secure</code> 的 <code>Cookie</code> 只应通过被 <code>HTTPS</code> 协议加密过的请求发送给服务端，因此可以预防 <code>man-in-the-middle</code> 攻击者的攻击。但即便设置了 <code>Secure</code> 标记，敏感信息也不应该通过 <code>Cookie</code> 传输，因为 <code>Cookie</code> 有其固有的不安全性，<code>Secure</code> 标记也无法提供确实的安全保障, 例如，可以访问客户端硬盘的人可以读取它。</p>
<p><code>JavaScript Document.cookie API</code> 无法访问带有 <code>HttpOnly</code> 属性的 <code>Cookie</code>；此类 <code>Cookie</code> 仅作用于服务器。例如，例如，持久化服务器端会话的 <code>Cookie</code> 不需要对 <code>JavaScript</code> 可用，而应具有 <code>HttpOnly</code> 属性。此预防措施有助于缓解跨站点脚本（<code>XSS</code>）攻击。</p>
<h2 id="9-Cookie-的替代方案"><a href="#9-Cookie-的替代方案" class="headerlink" title="9. Cookie 的替代方案"></a>9. Cookie 的替代方案</h2><p>由于 <code>Cookie</code>  在使用上存在较多限制，近年来，随着技术的发展成熟，出现了几种可替代 <code>Cookie</code> 的方案，且已被大多数主流浏览器支持。</p>
<p><img src="/Users/wangzhijie/Public/%E5%B7%A5%E4%BD%9C/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0/Cookie%20%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/images/Cookie%E7%9A%84%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88.png" alt="Cookie的替代方案"></p>
<ul>
<li><strong>Web Storage、window.localStorage</strong> </li>
</ul>
<p>在浏览器中存储数据的另一种方法是 ==Web Storage API==。<code>window.sessionStorage</code> 和 <code>window.localStorage</code> 属性与持续时间中的会话和永久 <code>Cookie</code> 相对应，但是存储限制比 <code>Cookie</code>大，并且永远不会发送到服务器。</p>
<ul>
<li><strong>IndexedDB</strong></li>
</ul>
<p>可以使用 <code>IndexedDB API</code> 或基于它构建的库来存储更多结构化的数据。</p>
<ul>
<li><strong>Web SQL</strong></li>
</ul>
<p><code>Web SQL</code> 是一种利用数据库进行数据存储并利用 SQL 处理检索任务的 API。</p>
<blockquote>
<p>欢迎大家来到我的「山头」，我是「前端三昧」的作者 <em>隐逸王</em>  ——  一个想要做山大王的男人！</p>
<p>愿和你一起领略前端三昧，发现前端之美！</p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Cookie</category>
      </categories>
      <tags>
        <tag>Cookie</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
