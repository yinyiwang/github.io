<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JavaScript操作数组方法大全</title>
    <url>/yinyiwang/2020/09/27/JavaScript%E6%93%8D%E4%BD%9C%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>用法详解</title>
    <url>/yinyiwang/2020/09/27/%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>1</title>
    <url>/yinyiwang/2020/05/30/1/</url>
    <content><![CDATA[// routes/index.js
module.exports = function (app) {
    app.get('/', function (req, res) {
        res.send('Hello world');
    });
    app.get('/customer', function (req, res) {
        res.send('customer page');
    });
    app.get('/admin', function (req, res) {
        res.send('admin page');
    });
};]]></content>
  </entry>
  <entry>
    <title>peixun培训</title>
    <url>/yinyiwang/2020/04/09/peixun%E5%9F%B9%E8%AE%AD/</url>
    <content><![CDATA[<h1 id="今天是搭建个人博客的培训"><a href="#今天是搭建个人博客的培训" class="headerlink" title="今天是搭建个人博客的培训"></a>今天是搭建个人博客的培训</h1>]]></content>
      <categories>
        <category>培训</category>
      </categories>
      <tags>
        <tag>培训</tag>
        <tag>peixun</tag>
      </tags>
  </entry>
  <entry>
    <title>解决同一台电脑生成过个SSH的问题</title>
    <url>/yinyiwang/2020/04/09/2020-04-09-%E8%A7%A3%E5%86%B3%E5%90%8C%E4%B8%80%E5%8F%B0%E7%94%B5%E8%84%91%E7%94%9F%E6%88%90%E8%BF%87%E4%B8%AASSH%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>解决同一台电脑生成两份或多份ssh密钥、公钥映射两个或多个GitHub账号</p>
<p>需求描述</p>
<p>本人注册一个GitHub账户，用来分享本人自己的开源项目或者代码，同时，公司注册了一个GitHub账户，用来分享公司的开源项目。如果按照单个ssh公钥生成的方法则会把之前的公钥覆盖掉，这样将导致其中一方在下一次上传代码，本机和GitHub无法映射成功。</p>
<a id="more"></a>

<p>需求分析</p>
<p>解决这个问题首先要明确如何生成单个ssh公钥。<br>ssh生成单个公钥命令：ssh-keygen -t rsa -b 4096 -C “<a href="mailto:your_email@example.com">your_email@example.com</a>“。如何生成ssh公钥<br>上述命令会在当前~/.ssh目录下生成id_rsa和id_rsa.pub两个文件。其中id_rsa是私钥文件，id_rsa_.pub是公钥文件。<br>id_rsa和id_rsa_.pub文件都是通过一个邮箱号生成的，同一个公钥文件不可以配置两个不同GitHub账户（已测试）。<br>那么两个GitHub账户就需要两个不同的邮箱号，来生成两组不同的公钥文件。</p>
<p>解决方案</p>
<p>分别指定ssh公钥文件的名称即可。</p>
<p>命令：ssh-keygen -t rsa -C “<a href="mailto:your_email@example.com">your_email@example.com</a>“ -f <del>/.ssh/id_rsa_example<br>示例：分别以<a href="mailto:791815567@qq.com">791815567@qq.com</a>和galaxysoft@sina.cn两个邮箱在</del>/.ssh目录下生成两级不同的公钥文件。<br><a href="mailto:791815567@qq.com">791815567@qq.com</a>邮箱：ssh-keygen -t rsa -C “<a href="mailto:791815567@qq.com">791815567@qq.com</a>“ -f <del>/.ssh/id_rsa_me<br><a href="mailto:galaxysoft@sina.cn">galaxysoft@sina.cn</a>邮箱：ssh-keygen -t rsa -C “<a href="mailto:galaxysoft@sina.cn">galaxysoft@sina.cn</a>“ -f ~/.ssh/id_rsa_galaxysoft<br>生成过程可参考如何生成单个ssh公钥 这篇文章。<br>执行完成后，会以</del>/.ssh目录下看<a href="mailto:791815567@qq.com">791815567@qq.com</a>邮箱对应的私钥文件id_rsa_me、公钥文件id_rsa_me.pub和<a href="mailto:galaxysoft@sina.cn">galaxysoft@sina.cn</a>邮箱对应的私钥文件id_rsa_galaxysoft、公钥文件id_rsa_galaxysoft.pub<br>分别在两个GitHub账户中添加对应的公钥信息即可，可参考如何生成单个ssh公钥 这篇文章</p>
<p>通过ssh-add添加密钥至ssh-agent中</p>
<p>命令：ssh-add ~/.ssh/id_rsa_example;<br>示例：添加本文中的两个密钥：ssh-add ~/.ssh/id_rsa_me; ssh-add ~/.ssh/id_rsa_galaxysoft;</p>
<p>添加config配置文件分别映射不同的GitHub账户</p>
<p>进入~/.ssh目录，新建config文件，并添加相应的内容：</p>
<h1 id="个人的GitHub公钥"><a href="#个人的GitHub公钥" class="headerlink" title="个人的GitHub公钥"></a>个人的GitHub公钥</h1><p>Host github.com<br>HostName github.com<br>PreferredAuthentications publickey<br>IdentityFile ~/.ssh/id_rsa_me  # 指定特定的ssh私钥文件</p>
<h1 id="BitMan’s-GitHub"><a href="#BitMan’s-GitHub" class="headerlink" title="BitMan’s GitHub"></a>BitMan’s GitHub</h1><p>Host github.com<br>HostName github.com<br>PreferredAuthentications publickey<br>IdentityFile ~/.ssh/id_rsa_galaxysoft  # 指定特定的ssh私钥文件<br>测试配置是否成功</p>
<p>测试命令：ssh -T <a href="mailto:git@github.com">git@github.com</a><br>如果出现如下信息，表示配置成功：</p>
<p><code>Hi myNameIssls!</code> You’ve successfully authenticated, but GitHub does not provide shell access.<br>1<br>小提示：由于配置了两个GitHub的公、私钥映射信息，测试结果并不会把两个GitHub的信息都显示出来，只会显示第一个配置的映射成功信息。例如本例中只显示了Hi myNameIssls!账户信息。</p>
]]></content>
      <categories>
        <category>HEXO</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Github和HEXO搭建个人博客</title>
    <url>/yinyiwang/2020/04/09/2020-04-09-%E4%BD%BF%E7%94%A8Github%E5%92%8CHEXO%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用github pages服务搭建博客的好处有：</p>
<ol>
<li>全是静态文件，访问速度快；</li>
<li>免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；</li>
<li>可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；</li>
<li>数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；</li>
<li>博客内容可以轻松打包、转移、发布到其它平台；</li>
<li>等等；</li>
</ol>
<a id="more"></a>

<h2 id="1-1-准备工作"><a href="#1-1-准备工作" class="headerlink" title="1.1. 准备工作"></a>1.1. 准备工作</h2><p>在开始一切之前，你必须已经：</p>
<ul>
<li>有一个github账号，没有的话去注册一个；</li>
<li>安装了node.js、npm，并了解相关基础知识；</li>
<li>安装了git for windows（或者其它git客户端）</li>
</ul>
<h1 id="搭建github博客"><a href="#搭建github博客" class="headerlink" title="搭建github博客"></a>搭建github博客</h1><h2 id="2-1-创建仓库"><a href="#2-1-创建仓库" class="headerlink" title="2.1. 创建仓库"></a>2.1. 创建仓库</h2><p>新建一个名为<code>你的用户名.github.io</code>的仓库，比如说，如果你的github用户名是test，那么你就新建<code>test.github.io</code>的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 <a href="http://test.github.io/" target="_blank" rel="noopener">http://test.github.io</a> 了，是不是很方便？</p>
<p>由此可见，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。</p>
<p>几个注意的地方：</p>
<ol>
<li>注册的邮箱一定要验证，否则不会成功；</li>
<li>仓库名字必须是：<code>username.github.io</code>，其中<code>username</code>是你的用户名；</li>
<li>仓库创建成功不会立即生效，需要过一段时间，大概10-30分钟，或者更久，我的等了半个小时才生效；</li>
</ol>
<p>创建成功后，默认会在你这个仓库里生成一些示例页面，以后你的网站所有代码都是放在这个仓库里啦。</p>
<h2 id="2-2-绑定域名"><a href="#2-2-绑定域名" class="headerlink" title="2.2. 绑定域名"></a>2.2. 绑定域名</h2><p>当然，你不绑定域名肯定也是可以的，就用默认的 <code>xxx.github.io</code> 来访问，如果你想更个性一点，想拥有一个属于自己的域名，那也是OK的。</p>
<p>首先你要注册一个域名，域名注册以前总是推荐去<code>godaddy</code>，现在觉得其实国内的阿里云也挺不错的，价格也不贵，毕竟是大公司，放心！</p>
<p>绑定域名分2种情况：带www和不带www的。</p>
<p>域名配置最常见有2种方式，CNAME和A记录，CNAME填写域名，A记录填写IP，由于不带www方式只能采用A记录，所以必须先ping一下<code>你的用户名.github.io</code>的IP，然后到你的域名DNS设置页，将A记录指向你ping出来的IP，将CNAME指向<code>你的用户名.github.io</code>，这样可以保证无论是否添加www都可以访问，如下：</p>
<p><img src="http://image.liuxianan.com/201608/20160823_191336_238_8683.png" alt="img"></p>
<p>然后到你的github项目根目录新建一个名为CNAME的文件（无后缀），里面填写你的域名，加不加www看你自己喜好，因为经测试：</p>
<ul>
<li>如果你填写的是没有www的，比如 mygit.me，那么无论是访问 <a href="http://www.mygit.me/" target="_blank" rel="noopener">http://www.mygit.me</a> 还是 <a href="http://mygit.me/" target="_blank" rel="noopener">http://mygit.me</a> ，都会自动跳转到 <a href="http://mygit.me/" target="_blank" rel="noopener">http://mygit.me</a></li>
<li>如果你填写的是带www的，比如 <a href="http://www.mygit.me" target="_blank" rel="noopener">www.mygit.me</a> ，那么无论是访问 <a href="http://www.mygit.me/" target="_blank" rel="noopener">http://www.mygit.me</a> 还是 <a href="http://mygit.me/" target="_blank" rel="noopener">http://mygit.me</a> ，都会自动跳转到 <a href="http://www.mygit.me/" target="_blank" rel="noopener">http://www.mygit.me</a></li>
<li>如果你填写的是其它子域名，比如 abc.mygit.me，那么访问 <a href="http://abc.mygit.me/" target="_blank" rel="noopener">http://abc.mygit.me</a> 没问题，但是访问 <a href="http://mygit.me/" target="_blank" rel="noopener">http://mygit.me</a> ，不会自动跳转到 <a href="http://abc.mygit.me/" target="_blank" rel="noopener">http://abc.mygit.me</a></li>
</ul>
<p>另外说一句，在你绑定了新域名之后，原来的<code>你的用户名.github.io</code>并没有失效，而是会自动跳转到你的新域名。</p>
<h1 id="配置SSH-key"><a href="#配置SSH-key" class="headerlink" title="配置SSH key"></a>配置SSH key</h1><p>为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。</p>
<p>用git bash执行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/. ssh <span class="comment">#检查本机已存在的ssh密钥</span></span><br></pre></td></tr></table></figure>

<p>如果提示：No such file or directory 说明你是第一次使用git。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;邮件地址&quot;</span><br></pre></td></tr></table></figure>

<p>然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到<code>.ssh\id_rsa.pub</code>文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key：</p>
<p><img src="http://image.liuxianan.com/201608/20160818_143914_495_9084.png" alt="img"></p>
<p>将刚复制的内容粘贴到key那里，title随便填，保存。</p>
<h2 id="3-1-测试是否成功"><a href="#3-1-测试是否成功" class="headerlink" title="3.1. 测试是否成功"></a>3.1. 测试是否成功</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ssh -T git@github.com # 注意邮箱地址不用改</span><br></pre></td></tr></table></figure>

<p>如果提示<code>Are you sure you want to continue connecting (yes/no)?</code>，输入yes，然后会看到：</p>
<blockquote>
<p>Hi liuxianan! You’ve successfully authenticated, but GitHub does not provide shell access.</p>
</blockquote>
<p>看到这个信息说明SSH已配置成功！</p>
<p>此时你还需要配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name &quot;liuxianan&quot;&#x2F;&#x2F; 你的github用户名，非昵称</span><br><span class="line">$ git config --global user.email  &quot;xxx@qq.com&quot;&#x2F;&#x2F; 填写你的github注册邮箱</span><br></pre></td></tr></table></figure>

<p>具体这个配置是干嘛的我没仔细深究。</p>
<h1 id="使用hexo写博客"><a href="#使用hexo写博客" class="headerlink" title="使用hexo写博客"></a>使用hexo写博客</h1><h2 id="4-1-hexo简介"><a href="#4-1-hexo简介" class="headerlink" title="4.1. hexo简介"></a>4.1. hexo简介</h2><p>Hexo是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题。</p>
<p>官网： <a href="http://hexo.io/" target="_blank" rel="noopener">http://hexo.io</a><br>github: <a href="https://github.com/hexojs/hexo" target="_blank" rel="noopener">https://github.com/hexojs/hexo</a></p>
<h2 id="4-2-原理"><a href="#4-2-原理" class="headerlink" title="4.2. 原理"></a>4.2. 原理</h2><p>由于github pages存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，假如每次写完一篇文章都要手动更新博文目录和相关链接信息，相信谁都会疯掉，所以hexo所做的就是将这些md文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到github。</p>
<h2 id="4-3-注意事项"><a href="#4-3-注意事项" class="headerlink" title="4.3. 注意事项"></a>4.3. 注意事项</h2><p>安装之前先来说几个注意事项：</p>
<ol>
<li>很多命令既可以用Windows的cmd来完成，也可以使用git bash来完成，但是部分命令会有一些问题，为避免不必要的问题，建议全部使用git bash来执行；</li>
<li>hexo不同版本差别比较大，网上很多文章的配置信息都是基于2.x的，所以注意不要被误导；</li>
<li>hexo有2种<code>_config.yml</code>文件，一个是根目录下的全局的<code>_config.yml</code>，一个是各个<code>theme</code>下的；</li>
</ol>
<h2 id="4-4-安装"><a href="#4-4-安装" class="headerlink" title="4.4. 安装"></a>4.4. 安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo</span><br></pre></td></tr></table></figure>

<h2 id="4-5-初始化"><a href="#4-5-初始化" class="headerlink" title="4.5. 初始化"></a>4.5. 初始化</h2><p>在电脑的某个地方新建一个名为hexo的文件夹（名字可以随便取），比如我的是<code>F:\Workspaces\hexo</code>，由于这个文件夹将来就作为你存放代码的地方，所以最好不要随便放。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /f/Workspaces/hexo/</span><br><span class="line">$ hexo init</span><br></pre></td></tr></table></figure>

<p>hexo会自动下载一些文件到这个目录，包括node_modules，目录结构如下图：</p>
<p><img src="http://image.liuxianan.com/201608/20160818_115922_773_1148.png" alt="img"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo g <span class="comment"># 生成</span></span><br><span class="line">$ hexo s <span class="comment"># 启动服务</span></span><br></pre></td></tr></table></figure>

<p>执行以上命令之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github去的：</p>
<p><img src="http://image.liuxianan.com/201608/20160818_120700_028_2426.png" alt="img"></p>
<p><code>hexo s</code>是开启本地预览服务，打开浏览器访问 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000</a> 即可看到内容，很多人会碰到浏览器一直在转圈但是就是加载不出来的问题，一般情况下是因为端口占用的缘故，因为4000这个端口太常见了，解决端口冲突问题请参考这篇文章：</p>
<p><a href="http://blog.liuxianan.com/windows-port-bind.html" target="_blank" rel="noopener">http://blog.liuxianan.com/windows-port-bind.html</a></p>
<p>第一次初始化的时候hexo已经帮我们写了一篇名为 Hello World 的文章，默认的主题比较丑。</p>
<h2 id="4-6-修改主题"><a href="#4-6-修改主题" class="headerlink" title="4.6. 修改主题"></a>4.6. 修改主题</h2><p>既然默认主题很丑，那我们别的不做，首先来替换一个好看点的主题。这是 <a href="https://hexo.io/themes/" target="_blank" rel="noopener">官方主题</a>。</p>
<p>以hexo-theme-next为例</p>
<p>首先下载这个主题：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /f/Workspaces/hexo/</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

<p>下载后的主题都在这里：</p>
<p><img src="http://image.liuxianan.com/201608/20160818_134500_245_0912.png" alt="img"></p>
<p>修改<code>_config.yml</code>中的<code>theme: landscape</code>改为<code>theme: yilia</code>，然后重新执行<code>hexo g</code>来重新生成。</p>
<p>如果出现一些莫名其妙的问题，可以先执行<code>hexo clean</code>来清理一下public的内容，然后再来重新生成和发布。</p>
<h2 id="4-7-上传之前"><a href="#4-7-上传之前" class="headerlink" title="4.7. 上传之前"></a>4.7. 上传之前</h2><p>在上传代码到github之前，一定要记得先把你以前所有代码下载下来（虽然github有版本管理，但备份一下总是好的），因为从hexo提交代码时会把你以前的所有代码都删掉。</p>
<h2 id="4-8-上传到github"><a href="#4-8-上传到github" class="headerlink" title="4.8. 上传到github"></a>4.8. 上传到github</h2><p>如果你一切都配置好了，发布上传很容易，一句<code>hexo d</code>就搞定，当然关键还是你要把所有东西配置好。</p>
<p>首先，<code>ssh key</code>肯定要配置好。</p>
<p>其次，配置<code>_config.yml</code>中有关deploy的部分：</p>
<p>正确写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:liuxianan&#x2F;liuxianan.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>错误写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: github</span><br><span class="line">  repository: https:&#x2F;&#x2F;github.com&#x2F;liuxianan&#x2F;liuxianan.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>后面一种写法是hexo2.x的写法，现在已经不行了，无论是哪种写法，此时直接执行<code>hexo d</code>的话一般会报如下错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Deployer not found: github 或者 Deployer not found: git</span><br></pre></td></tr></table></figure>

<p>原因是还需要安装一个插件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>其它命令不确定，部署这个命令一定要用git bash，否则会提示<code>Permission denied (publickey).</code></p>
<p>打开你的git bash，输入<code>hexo d</code>就会将本次有改动的代码全部提交，没有改动的不会：</p>
<p><img src="http://image.liuxianan.com/201608/20160818_140441_769_5024.png" alt="img"></p>
<h2 id="4-9-保留CNAME、README-md等文件"><a href="#4-9-保留CNAME、README-md等文件" class="headerlink" title="4.9. 保留CNAME、README.md等文件"></a>4.9. 保留CNAME、README.md等文件</h2><p>提交之后网页上一看，发现以前其它代码都没了，此时不要慌，一些非md文件可以把他们放到source文件夹下，这里的所有文件都会原样复制（除了md文件）到public目录的：</p>
<p><img src="http://image.liuxianan.com/201608/20160818_141037_580_8035.png" alt="img"></p>
<p>由于hexo默认会把所有md文件都转换成html，包括README.md，所有需要每次生成之后、上传之前，手动将README.md复制到public目录，并删除README.html。</p>
<h2 id="4-10-常用hexo命令"><a href="#4-10-常用hexo命令" class="headerlink" title="4.10. 常用hexo命令"></a>4.10. 常用hexo命令</h2><p>常见命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &quot;postName&quot; #新建文章</span><br><span class="line">hexo new page &quot;pageName&quot; #新建页面</span><br><span class="line">hexo generate #生成静态页面至public目录</span><br><span class="line">hexo server #开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server）</span><br><span class="line">hexo deploy #部署到GitHub</span><br><span class="line">hexo help  # 查看帮助</span><br><span class="line">hexo version  #查看Hexo的版本</span><br></pre></td></tr></table></figure>

<p>缩写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo n &#x3D;&#x3D; hexo new</span><br><span class="line">hexo g &#x3D;&#x3D; hexo generate</span><br><span class="line">hexo s &#x3D;&#x3D; hexo server</span><br><span class="line">hexo d &#x3D;&#x3D; hexo deploy</span><br></pre></td></tr></table></figure>

<p>组合命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s -g #生成并本地预览</span><br><span class="line">hexo d -g #生成并上传</span><br></pre></td></tr></table></figure>

<h2 id="4-11-config-yml"><a href="#4-11-config-yml" class="headerlink" title="4.11. _config.yml"></a>4.11. _config.yml</h2><p>这里面都是一些全局配置，每个参数的意思都比较简单明了，所以就不作详细介绍了。</p>
<p>需要特别注意的地方是，冒号后面必须有一个空格，否则可能会出问题。</p>
<h2 id="4-12-写博客"><a href="#4-12-写博客" class="headerlink" title="4.12. 写博客"></a>4.12. 写博客</h2><p>定位到我们的hexo根目录，执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &#39;my-first-blog&#39;</span><br></pre></td></tr></table></figure>

<p>hexo会帮我们在<code>_posts</code>下生成相关md文件：</p>
<p><img src="http://image.liuxianan.com/201608/20160823_183047_352_1475.png" alt="img"></p>
<p>我们只需要打开这个文件就可以开始写博客了，默认生成如下内容：</p>
<p><img src="http://image.liuxianan.com/201608/20160823_183325_470_9306.png" alt="img"></p>
<p>当然你也可以直接自己新建md文件，用这个命令的好处是帮我们自动生成了时间。</p>
<p>一般完整格式如下：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: postName #文章页面上的显示名称，一般是中文</span><br><span class="line">date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改</span><br><span class="line">categories: 默认分类 #分类</span><br><span class="line">tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格</span><br><span class="line">description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">以下是正文</span><br></pre></td></tr></table></figure>

<p>那么<code>hexo new page &#39;postName&#39;</code>命令和<code>hexo new &#39;postName&#39;</code>有什么区别呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;my-second-blog&quot;</span><br></pre></td></tr></table></figure>

<p>生成如下：</p>
<p><img src="http://image.liuxianan.com/201608/20160823_184852_854_6502.png" alt="img"></p>
<p>最终部署时生成：<code>hexo\public\my-second-blog\index.html</code>，但是它不会作为文章出现在博文目录。</p>
<h3 id="4-12-1-写博客工具"><a href="#4-12-1-写博客工具" class="headerlink" title="4.12.1. 写博客工具"></a>4.12.1. 写博客工具</h3><p>VSCode和Typora</p>
<h3 id="4-12-2-如何让博文列表不显示全部内容"><a href="#4-12-2-如何让博文列表不显示全部内容" class="headerlink" title="4.12.2. 如何让博文列表不显示全部内容"></a>4.12.2. 如何让博文列表不显示全部内容</h3><p>默认情况下，生成的博文目录会显示全部的文章内容，如何设置文章摘要的长度呢？</p>
<p>答案是在合适的位置加上<code>&lt;!--more--&gt;</code>即可，例如：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 前言</span></span><br><span class="line"></span><br><span class="line">使用github pages服务搭建博客的好处有：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1. </span>全是静态文件，访问速度快；</span><br><span class="line"><span class="bullet">2. </span>免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；</span><br><span class="line"><span class="bullet">3. </span>可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--more--&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="bullet">4. </span>数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；</span><br><span class="line"><span class="bullet">5. </span>博客内容可以轻松打包、转移、发布到其它平台；</span><br><span class="line"><span class="bullet">6. </span>等等；</span><br></pre></td></tr></table></figure>

<p>最终效果：</p>
<p><img src="http://image.liuxianan.com/201608/20160823_184633_653_1893.png" alt="img"></p>
<h1 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h1><p><strong>文章头设置</strong></p>
<p>首先为了新建文章方便，建议将<code>/scaffolds/post.md</code>修改为如下代码：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">top: false</span><br><span class="line">cover: false</span><br><span class="line">password:</span><br><span class="line">toc: true</span><br><span class="line">mathjax: true</span><br><span class="line">summary:</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p><strong>添加404页面</strong></p>
<p>原来的主题没有404页面，加一个也不是什么难事。首先在<code>/source/</code>目录下新建一个<code>404.md</code>，内容如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 404</span><br><span class="line">date: 2019-07-19 16:41:10</span><br><span class="line">type: "404"</span><br><span class="line">layout: "404"</span><br><span class="line">description: "你来到了没有知识的荒原 :("</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>然后在<code>/themes/matery/layout/</code>目录下新建一个<code>404.ejs</code>文件，内容如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="comment">/* don't remove. */</span></span></span><br><span class="line"><span class="css">    <span class="selector-class">.about-cover</span> &#123;</span></span><br><span class="line">        height: 75vh;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"bg-cover pd-header about-cover"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col s10 offset-s1 m8 offset-m2 l8 offset-l2"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"brand"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"title center-align"</span>&gt;</span></span><br><span class="line">                        404</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"description center-align"</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">%=</span> <span class="attr">page.description</span> %&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 每天切换 banner 图.  Switch banner image every day.</span></span></span><br><span class="line"><span class="javascript">    $(<span class="string">'.bg-cover'</span>).css(<span class="string">'background-image'</span>, <span class="string">'url(/medias/banner/'</span> + <span class="keyword">new</span> <span class="built_in">Date</span>().getDay() + <span class="string">'.jpg)'</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>增加建站时间</strong></p>
<p>修改<code>/themes/matery/layout/_partial/footer.ejs</code>文件，在最后加上</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script language=javascript&gt;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">siteTime</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">window</span>.setTimeout(<span class="string">"siteTime()"</span>, <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">var</span> seconds = <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">var</span> minutes = seconds * <span class="number">60</span>;</span><br><span class="line">        <span class="keyword">var</span> hours = minutes * <span class="number">60</span>;</span><br><span class="line">        <span class="keyword">var</span> days = hours * <span class="number">24</span>;</span><br><span class="line">        <span class="keyword">var</span> years = days * <span class="number">365</span>;</span><br><span class="line">        <span class="keyword">var</span> today = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">        <span class="keyword">var</span> todayYear = today.getFullYear();</span><br><span class="line">        <span class="keyword">var</span> todayMonth = today.getMonth() + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">var</span> todayDate = today.getDate();</span><br><span class="line">        <span class="keyword">var</span> todayHour = today.getHours();</span><br><span class="line">        <span class="keyword">var</span> todayMinute = today.getMinutes();</span><br><span class="line">        <span class="keyword">var</span> todaySecond = today.getSeconds();</span><br><span class="line">        <span class="comment">/* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)</span></span><br><span class="line"><span class="comment">        year - 作为date对象的年份，为4位年份值</span></span><br><span class="line"><span class="comment">        month - 0-11之间的整数，做为date对象的月份</span></span><br><span class="line"><span class="comment">        day - 1-31之间的整数，做为date对象的天数</span></span><br><span class="line"><span class="comment">        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数</span></span><br><span class="line"><span class="comment">        minutes - 0-59之间的整数，做为date对象的分钟数</span></span><br><span class="line"><span class="comment">        seconds - 0-59之间的整数，做为date对象的秒数</span></span><br><span class="line"><span class="comment">        microseconds - 0-999之间的整数，做为date对象的毫秒数 */</span></span><br><span class="line">        <span class="keyword">var</span> t1 = <span class="built_in">Date</span>.UTC(<span class="number">2017</span>, <span class="number">09</span>, <span class="number">11</span>, <span class="number">00</span>, <span class="number">00</span>, <span class="number">00</span>); <span class="comment">//北京时间2018-2-13 00:00:00</span></span><br><span class="line">        <span class="keyword">var</span> t2 = <span class="built_in">Date</span>.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);</span><br><span class="line">        <span class="keyword">var</span> diff = t2 - t1;</span><br><span class="line">        <span class="keyword">var</span> diffYears = <span class="built_in">Math</span>.floor(diff / years);</span><br><span class="line">        <span class="keyword">var</span> diffDays = <span class="built_in">Math</span>.floor((diff / days) - diffYears * <span class="number">365</span>);</span><br><span class="line">        <span class="keyword">var</span> diffHours = <span class="built_in">Math</span>.floor((diff - (diffYears * <span class="number">365</span> + diffDays) * days) / hours);</span><br><span class="line">        <span class="keyword">var</span> diffMinutes = <span class="built_in">Math</span>.floor((diff - (diffYears * <span class="number">365</span> + diffDays) * days - diffHours * hours) / minutes);</span><br><span class="line">        <span class="keyword">var</span> diffSeconds = <span class="built_in">Math</span>.floor((diff - (diffYears * <span class="number">365</span> + diffDays) * days - diffHours * hours - diffMinutes * minutes) / seconds);</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">"sitetime"</span>).innerHTML = <span class="string">"本站已运行 "</span> +diffYears+<span class="string">" 年 "</span>+diffDays + <span class="string">" 天 "</span> + diffHours + <span class="string">" 小时 "</span> + diffMinutes + <span class="string">" 分钟 "</span> + diffSeconds + <span class="string">" 秒"</span>;</span><br><span class="line">    &#125;<span class="comment">/*因为建站时间还没有一年，就将之注释掉了。需要的可以取消*/</span></span><br><span class="line">    siteTime();</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后在合适的地方（比如copyright声明后面）加上下面的代码就行了：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"sitetime"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>HEXO</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>获取网址的真实ip</title>
    <url>/yinyiwang/2020/04/18/%E8%8E%B7%E5%8F%96%E7%BD%91%E5%9D%80%E7%9A%84%E7%9C%9F%E5%AE%9Eip/</url>
    <content><![CDATA[<h1 id="HOSTS文件是做什么的？"><a href="#HOSTS文件是做什么的？" class="headerlink" title="HOSTS文件是做什么的？"></a>HOSTS文件是做什么的？</h1><p>Hosts是将一些常用的网址域名与其对应的IP地址建立关联的”数据库”——用户在浏览器输入网址时，系统优先从Hosts文件中寻找对应的IP地址，找到后自动打开对应网页；若没有找到，则再将网址提交DNS域名解析服务器进行IP地址的解析。</p>
]]></content>
      <categories>
        <category>小技巧</category>
      </categories>
      <tags>
        <tag>获取ip</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6的Module使用详解</title>
    <url>/yinyiwang/2020/04/20/2020-04-20-ES6%E7%9A%84Module%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<blockquote>
<p>ES6在语言标准的层面上，实现了<strong>模块</strong>的功能，有望成为浏览器和服务端模块的通用解决方案。</p>
<p>ES6 模块的设计思想是尽量的<strong>静态化</strong>，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。</p>
<p>ES6 的模块自动采用严格模式，不管你有没有在模块头部加上<code>&quot;use strict&quot;;</code>。</p>
</blockquote>
<h1 id="一、模块命令"><a href="#一、模块命令" class="headerlink" title="一、模块命令"></a>一、模块命令</h1><p>模块功能主要由两个命令构成：<code>export</code>和<code>import</code>。</p>
<p><code>export</code>命令用于规定模块的对外接口，<code>import</code>命令用于输入其他模块提供的功能。</p>
<ol>
<li><code>export</code>命令</li>
</ol>
<ol start="2">
<li><code>import</code>命令</li>
</ol>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>Module</tag>
        <tag>模块</tag>
      </tags>
  </entry>
  <entry>
    <title>Module使用详解</title>
    <url>/yinyiwang/2020/04/20/2020-04-20-Module%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>sdsdsdsdsds</p>
]]></content>
  </entry>
  <entry>
    <title>前端插件化（模块化）方案调研</title>
    <url>/yinyiwang/2020/04/17/%E5%89%8D%E7%AB%AF%E6%8F%92%E4%BB%B6%E5%8C%96%EF%BC%88%E6%A8%A1%E5%9D%97%E5%8C%96%EF%BC%89%E6%96%B9%E6%A1%88%E8%B0%83%E7%A0%94/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>随着前端功能越来越复杂，前端代码日益膨胀，为了减少维护成本，提高代码的可复用性，前端模块化势在必行。</p>
<p>所有js文件都在一个html中引入，造成以下不良影响：</p>
<ol>
<li><strong>请求过多</strong>。首先我们要依赖多个模块，那样就会发送多个请求，导致请求过多</li>
<li><strong>依赖模糊</strong>。我们不知道他们的具体依赖关系是什么，也就是说很容易因为不了解他们之间的依赖关系导致加载先后顺序出错。</li>
<li><strong>难以维护</strong>。以上两种原因就导致了很难维护，很可能出现牵一发而动全身的情况导致项目出现严重的问题。</li>
</ol>
<a id="more"></a>

<h2 id="模块的概念"><a href="#模块的概念" class="headerlink" title="模块的概念"></a>模块的概念</h2><p>webpack中是这样定义的：</p>
<blockquote>
<p>在模块化编程中，开发者将程序分解成离散功能块(discrete chunks of functionality)，并称之为模块。 每个模块具有比完整程序更小的接触面，使得校验、调试、测试轻而易举。 精心编写的模块提供了可靠的抽象和封装界限，使得应用程序中每个模块都具有条理清楚的设计和明确的目的。</p>
</blockquote>
<p>模块应该是职责单一、相互独立、低耦合的、高度内聚且可替换的离散功能块。</p>
<h2 id="模块化的概念"><a href="#模块化的概念" class="headerlink" title="模块化的概念"></a>模块化的概念</h2><blockquote>
<p>模块化是一种处理复杂系统分解成为更好的可管理模块的方式，它可以把系统代码划分为一系列职责单一，高度解耦且可替换的模块，系统中某一部分的变化将如何影响其它部分就会变得显而易见，系统的可维护性更加简单易得。</p>
</blockquote>
<p>模块化是一种分治的思想，通过分解复杂系统为独立的模块实现细粒度的精细控制，对于复杂系统的维护和管理十分有益。模块化也是组件化的基石，是构成现在色彩斑斓的前端世界的前提条件。</p>
<h2 id="为什么需要模块化"><a href="#为什么需要模块化" class="headerlink" title="为什么需要模块化"></a>为什么需要模块化</h2><p>前端开发和其他开发工作的主要区别，首先是前端是<strong>基于多语言</strong>、<strong>多层次的编码和组织工作</strong>，其次前端产品的交付是<strong>基于浏览器</strong>，这些资源是通过增量加载的方式运行到浏览器端，如何在开发环境组织好这些碎片化的代码和资源，并且保证他们在浏览器端快速、优雅的加载和更新，就需要一个模块化系统。</p>
<h2 id="模块化的好处"><a href="#模块化的好处" class="headerlink" title="模块化的好处"></a>模块化的好处</h2><ol>
<li><p><strong>可维护性。</strong> 因为模块是独立的，一个设计良好的模块会让外面的代码对自己的依赖越少越好，这样自己就可以独立去更新和改进。</p>
</li>
<li><p><strong>命名空间。</strong> 在 JavaScript 里面，如果一个变量在最顶级的函数之外声明，它就直接变成全局可用。因此，常常不小心出现命名冲突的情况。使用模块化开发来封装变量，可以避免污染全局环境。</p>
</li>
<li><p><strong>重用代码。</strong> 我们有时候会喜欢从之前写过的项目中拷贝代码到新的项目，这没有问题，但是更好的方法是，通过模块引用的方式，来避免重复的代码库。我们可以在更新了模块之后，让引用了该模块的所有项目都同步更新，还能指定版本号，避免 API 变更带来的麻烦。</p>
</li>
</ol>
<h2 id="模块化简史"><a href="#模块化简史" class="headerlink" title="模块化简史"></a>模块化简史</h2><h3 id="1-最简单粗暴的方式"><a href="#1-最简单粗暴的方式" class="headerlink" title="1. 最简单粗暴的方式"></a>1. 最简单粗暴的方式</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 script 标签引入文件，调用相关的函数。这样需要手动去管理依赖顺序，容易造成命名冲突，污染全局，随着项目的复杂度增加维护成本也越来越高。</p>
<h3 id="2-用对象来模拟命名空间"><a href="#2-用对象来模拟命名空间" class="headerlink" title="2. 用对象来模拟命名空间"></a>2. 用对象来模拟命名空间</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> output = &#123;</span><br><span class="line">  _count: <span class="number">0</span>,</span><br><span class="line">  fn1: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样可以解决上面的全局污染的问题，有那么点命名空间的意思，但是随着项目复杂度增加需要越来越多的这样的对象需要维护，不说别的，取名字都是个问题。最关键的还是内部的属性还是可以被直接访问和修改。</p>
<h3 id="3-闭包"><a href="#3-闭包" class="headerlink" title="3. 闭包"></a>3. 闭包</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> fn1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> fn2 = <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    fn1: fn1,</span><br><span class="line">    fn2: fn2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.fn1();</span><br><span class="line"><span class="built_in">module</span>._count; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>这样就拥有独立的词法作用域，内存中只会存在一份 copy。这不仅避免了外界访问此 <code>IIFE</code> 中的变量，而且又不会污染全局作用域，通过 <code>return</code> 暴露出公共接口供外界调用。这其实就是现代模块化实现的基础。</p>
<h3 id="4-更多"><a href="#4-更多" class="headerlink" title="4. 更多"></a>4. 更多</h3><p>还有基于闭包实现的松耦合拓展、紧耦合拓展、继承、子模块、跨文件共享私有对象、基于 new 构造的各种方式，这种方式在现在看来都不再优雅。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 松耦合拓展</span></span><br><span class="line"><span class="comment">// 这种方式使得可以在不同的文件中以相同结构共同实现一个功能块，且不用考虑在引入这些文件时候的顺序问题。</span></span><br><span class="line"><span class="comment">// 缺点是没办法重写你的一些属性或者函数，也不能在初始化的时候就是用module的属性。</span></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = (<span class="function"><span class="keyword">function</span>(<span class="params">my</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> my</span><br><span class="line">&#125;)(<span class="built_in">module</span> || &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 紧耦合拓展（没有传默认参数）</span></span><br><span class="line"><span class="comment">// 加载顺序不再自由，但是可以重载</span></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = (<span class="function"><span class="keyword">function</span>(<span class="params">my</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> old = my.someOldFunc</span><br><span class="line">  </span><br><span class="line">  my.someOldFunc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 重载方法，依然可通过old调用旧的方法...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> my</span><br><span class="line">&#125;)(<span class="built_in">module</span>)</span><br></pre></td></tr></table></figure>



<h2 id="实现模块化的方案规范总览"><a href="#实现模块化的方案规范总览" class="headerlink" title="实现模块化的方案规范总览"></a>实现模块化的方案规范总览</h2><p>历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的<code>require</code>、Python 的<code>import</code>，甚至就连 CSS 都有<code>@import</code>，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。</p>
<p>在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</p>
<p>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。</p>
<p>目前实现模块化的规范主要有：</p>
<ul>
<li>CommonJS</li>
<li>CMD</li>
<li>AMD</li>
<li>ES6模块</li>
</ul>
<h2 id="CommonJS（）"><a href="#CommonJS（）" class="headerlink" title="CommonJS（）"></a>CommonJS（）</h2><p>CommonJS 是以在浏览器环境之外构建 JavaScript 生态系统为目标而产生的项目，比如在服务器和桌面环境中。</p>
<p>采用同步加载模块的方式，也就是说只有加载完成，才能执行后面的操作。CommonJS 代表：Node 应用中的模块，通俗的说就是你用 npm 安装的模块。</p>
<p>它使用 require 引用和加载模块，exports 定义和导出模块，module 标识模块。使用 require 时需要去读取并执行该文件，然后返回 exports 导出的内容。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义模块 math.js</span></span><br><span class="line"> <span class="keyword">var</span> random=<span class="built_in">Math</span>.random()*<span class="number">10</span>;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">printRandom</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(random)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">printIntRandom</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="built_in">Math</span>.floor(random))</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//模块输出</span></span><br><span class="line"> <span class="built_in">module</span>.exports=&#123;</span><br><span class="line">     printRandom:printRandom,</span><br><span class="line">     printIntRandom:printIntRandom</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//加载模块 math.js</span></span><br><span class="line"> <span class="keyword">var</span> math=<span class="built_in">require</span>(<span class="string">'math'</span>)</span><br><span class="line"> <span class="comment">//调用模块提供的方法</span></span><br><span class="line"> math.printIntRandom()</span><br><span class="line"> math.printRandom()</span><br></pre></td></tr></table></figure>

<h3 id="CommonJS主要用于服务端的模块化，不适用于前端模块化的原因在于："><a href="#CommonJS主要用于服务端的模块化，不适用于前端模块化的原因在于：" class="headerlink" title="CommonJS主要用于服务端的模块化，不适用于前端模块化的原因在于："></a>CommonJS主要用于服务端的模块化，不适用于前端模块化的原因在于：</h3><ul>
<li>服务端加载一个模块，直接就从硬盘或者内存中读取了，消耗时间可以忽略不计</li>
<li>浏览器需要从服务端下载这个文件，所以说如果用CommonJS的require方式加载模块，需要等代码模块下载完毕，并运行之后才能得到所需要的API。</li>
<li>如果我们在某个代码模块里使用CommonJS的方法require了一个模块，而这个模块需要通过http请求从服务器去取，如果网速很慢，而CommonJS又是同步的，所以将阻塞后面代码的执行，从而阻塞浏览器渲染页面，使得页面出现假死状态。</li>
</ul>
<h3 id="CommonJS在浏览器端实现的步骤："><a href="#CommonJS在浏览器端实现的步骤：" class="headerlink" title="CommonJS在浏览器端实现的步骤："></a>CommonJS在浏览器端实现的步骤：</h3><h4 id="1-创建项目结构"><a href="#1-创建项目结构" class="headerlink" title="1. 创建项目结构"></a>1. 创建项目结构</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">|-js</span><br><span class="line">  |-dist <span class="comment">//打包生成文件的目录</span></span><br><span class="line">  |-src <span class="comment">//源码所在的目录</span></span><br><span class="line">    |-module1.js</span><br><span class="line">    |-module2.js</span><br><span class="line">    |-module3.js</span><br><span class="line">    |-app.js <span class="comment">//应用主源文件</span></span><br><span class="line">|-index.html <span class="comment">//运行于浏览器上</span></span><br><span class="line">|-package.json</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"browserify-test"</span>,</span><br><span class="line">    <span class="string">"version"</span>: <span class="string">"1.0.0"</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-下载browserify"><a href="#2-下载browserify" class="headerlink" title="2. 下载browserify"></a>2. 下载browserify</h4><ul>
<li>全局: npm install browserify -g</li>
<li>局部: npm install browserify –save-dev</li>
</ul>
<h4 id="3-定义模块代码-同服务器端"><a href="#3-定义模块代码-同服务器端" class="headerlink" title="3. 定义模块代码(同服务器端)"></a>3. 定义模块代码(同服务器端)</h4><p>注意：<code>index.html</code>文件要运行在浏览器上，需要借助browserify将<code>app.js</code>文件打包编译，如果直接在<code>index.html</code>引入<code>app.js</code>就会报错！</p>
<h4 id="4-打包处理js"><a href="#4-打包处理js" class="headerlink" title="4. 打包处理js"></a>4. 打包处理js</h4><p>根目录下运行<code>browserify js/src/app.js -o js/dist/bundle.js</code></p>
<h4 id="5-页面使用引入"><a href="#5-页面使用引入" class="headerlink" title="5. 页面使用引入"></a>5. 页面使用引入</h4><p>在index.html文件中引入<code>&lt;script type=&quot;text/javascript&quot; src=&quot;js/dist/bundle.js&quot;&gt;&lt;/script&gt;</code></p>
<h2 id="AMD（Asynchronous-Module-Definition）"><a href="#AMD（Asynchronous-Module-Definition）" class="headerlink" title="AMD（Asynchronous Module Definition）"></a>AMD（Asynchronous Module Definition）</h2><p>异步模块定义，所谓异步是指模块和模块的依赖可以被异步加载，他们的加载不会影响它后面语句的运行。有效避免了采用同步加载方式中导致的页面假死现象。AMD代表：RequireJS。</p>
<p>AMD一开始是CommonJS规范中的一个草案，全称是Asynchronous Module Definition，即异步模块加载机制。后来由该草案的作者以RequireJS实现了AMD规范，所以一般说AMD也是指RequireJS。</p>
<p>RequireJS是一个工具库，主要用于客户端的模块管理。它的模块管理遵守AMD规范，<strong>RequireJS的基本思想是，通过define方法，将代码定义为模块；通过require方法，实现代码的模块加载</strong>。 </p>
<p>它主要有两个接口：<strong>define</strong> 和 <strong>require</strong>。define 是模块开发者关注的方法，而 require 则是模块使用者关注的方法。</p>
<h3 id="define-函数："><a href="#define-函数：" class="headerlink" title="define() 函数："></a>define() 函数：</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">define(id?, dependencies?, factory);</span><br><span class="line"><span class="comment">//id ：可选参数，它指的是模块的名字。</span></span><br><span class="line"><span class="comment">//dependencies：可选参数，定义中模块所依赖模块的数组。</span></span><br><span class="line"><span class="comment">//factory：模块初始化要执行的函数或对象</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，dependencies有多少个元素，factory就有多少个传参，位置一一对应。<br>使用栗子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">define(<span class="string">"alpha"</span>, [<span class="string">"require"</span>, <span class="string">"exports"</span>, <span class="string">"beta"</span>], <span class="function"><span class="keyword">function</span> (<span class="params">require, exports, beta</span>) </span>&#123;  </span><br><span class="line">    exports.verb = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;            </span><br><span class="line">        <span class="keyword">return</span> beta.verb();            </span><br><span class="line">        <span class="comment">//Or:</span></span><br><span class="line">        <span class="comment">//return require("beta").verb();        </span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="require-函数"><a href="#require-函数" class="headerlink" title="require() 函数"></a>require() 函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="built_in">module</span>], callback);</span><br><span class="line"><span class="comment">//module：一个数组，里面的成员就是要加载的模块.</span></span><br><span class="line"><span class="comment">//callback：模块加载成功之后的回调函数。</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是 ，module 有多少个元素，callback 就有多少个传参，位置一一对应。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>],<span class="function"><span class="keyword">function</span>(<span class="params">a,b,c</span>)</span>&#123;    <span class="comment">//code here &#125;);</span></span><br></pre></td></tr></table></figure>

<h3 id="AMD的优缺点"><a href="#AMD的优缺点" class="headerlink" title="AMD的优缺点"></a>AMD的优缺点</h3><p>AMD 运行时核心思想是「Early Executing」，也就是提前执行依赖 AMD 的这个特性有好有坏：</p>
<ul>
<li><p>首先，尽早执行依赖可以尽早发现错误。　　</p>
</li>
<li><p>另外，尽早执行依赖通常可以带来更好的用户体验，也容易产生浪费。</p>
</li>
<li><p>引用AMD的Javscript库： 目前，主要有两个Javascript库实现了AMD规范：require.js和curl.js</p>
</li>
<li><p>在浏览器环境中异步加载模块；并行加载多个模块；</p>
</li>
<li><p>开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅；不符合通用的模块化思维方式，是一种妥协的实现。</p>
</li>
</ul>
<h3 id="AMD在浏览器端的实现步骤"><a href="#AMD在浏览器端的实现步骤" class="headerlink" title="AMD在浏览器端的实现步骤"></a>AMD在浏览器端的实现步骤</h3><h4 id="1-下载require-js-并引入"><a href="#1-下载require-js-并引入" class="headerlink" title="1. 下载require.js, 并引入"></a>1. 下载require.js, 并引入</h4><ul>
<li>官网: <code>http://www.requirejs.cn/</code></li>
<li>github : <code>https://github.com/requirejs/requirejs</code></li>
</ul>
<p>然后将require.js导入项目: js/libs/require.js</p>
<h4 id="2-创建项目结构"><a href="#2-创建项目结构" class="headerlink" title="2. 创建项目结构"></a>2. 创建项目结构</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">|-js</span><br><span class="line">  |-libs</span><br><span class="line">    |-<span class="built_in">require</span>.js</span><br><span class="line">  |-modules</span><br><span class="line">    |-alerter.js</span><br><span class="line">    |-dataService.js</span><br><span class="line">  |-main.js</span><br><span class="line">|-index.html</span><br></pre></td></tr></table></figure>



<h4 id="3-定义require-js的模块"><a href="#3-定义require-js的模块" class="headerlink" title="3. 定义require.js的模块"></a>3. 定义require.js的模块</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dataService.js文件</span></span><br><span class="line"><span class="comment">// 定义没有依赖的模块</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> msg = <span class="string">'www.baidu.com'</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getMsg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> msg.toUpperCase()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123; getMsg &#125; <span class="comment">// 暴露模块</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//alerter.js文件</span></span><br><span class="line"><span class="comment">// 定义有依赖的模块</span></span><br><span class="line">define([<span class="string">'dataService'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">dataService</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">'Tom'</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">showMsg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(dataService.getMsg() + <span class="string">', '</span> + name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 暴露模块</span></span><br><span class="line">  <span class="keyword">return</span> &#123; showMsg &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js文件</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">require</span>.config(&#123;</span><br><span class="line">    baseUrl: <span class="string">'js/'</span>, <span class="comment">//基本路径 出发点在根目录下</span></span><br><span class="line">    paths: &#123;</span><br><span class="line">      <span class="comment">//映射: 模块标识名: 路径</span></span><br><span class="line">      alerter: <span class="string">'./modules/alerter'</span>, <span class="comment">//此处不能写成alerter.js,会报错</span></span><br><span class="line">      dataService: <span class="string">'./modules/dataService'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">require</span>([<span class="string">'alerter'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">alerter</span>) </span>&#123;</span><br><span class="line">    alerter.showMsg()</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.html文件</span></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;Modular Demo&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;!-- 引入<span class="built_in">require</span>.js并指定js主文件的入口 --&gt;</span><br><span class="line">    &lt;script data-main=<span class="string">"js/main"</span> src=<span class="string">"js/libs/require.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="4-页面引入require-js模块"><a href="#4-页面引入require-js模块" class="headerlink" title="4. 页面引入require.js模块:"></a>4. 页面引入require.js模块:</h4><p>在index.html引入 <code>&lt;script data-main=&quot;js/main&quot; src=&quot;js/libs/require.js&quot;&gt;&lt;/script&gt;</code></p>
<p><strong>此外在项目中如何引入第三方库</strong>？只需在上面代码的基础稍作修改：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// alerter.js文件</span></span><br><span class="line">define([<span class="string">'dataService'</span>, <span class="string">'jquery'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">dataService, $</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">'Tom'</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">showMsg</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(dataService.getMsg() + <span class="string">', '</span> + name)</span><br><span class="line">  &#125;</span><br><span class="line">  $(<span class="string">'body'</span>).css(<span class="string">'background'</span>, <span class="string">'green'</span>)</span><br><span class="line">  <span class="comment">// 暴露模块</span></span><br><span class="line">  <span class="keyword">return</span> &#123; showMsg &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js文件</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">require</span>.config(&#123;</span><br><span class="line">    baseUrl: <span class="string">'js/'</span>, <span class="comment">//基本路径 出发点在根目录下</span></span><br><span class="line">    paths: &#123;</span><br><span class="line">      <span class="comment">//自定义模块</span></span><br><span class="line">      alerter: <span class="string">'./modules/alerter'</span>, <span class="comment">//此处不能写成alerter.js,会报错</span></span><br><span class="line">      dataService: <span class="string">'./modules/dataService'</span>,</span><br><span class="line">      <span class="comment">// 第三方库模块</span></span><br><span class="line">      jquery: <span class="string">'./libs/jquery-1.10.1'</span> <span class="comment">//注意：写成jQuery会报错</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">require</span>([<span class="string">'alerter'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">alerter</span>) </span>&#123;</span><br><span class="line">    alerter.showMsg()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>上例是在alerter.js文件中引入jQuery第三方库，main.js文件也要有相应的路径配置。 <strong>小结</strong>：通过两者的比较，可以得出<strong>AMD模块定义的方法非常清晰，不会污染全局环境，能够清楚地显示依赖关系</strong>。AMD模式可以用于浏览器环境，并且允许非同步加载模块，也可以根据需要动态加载模块。</p>
<h2 id="UMD规范"><a href="#UMD规范" class="headerlink" title="UMD规范"></a>UMD规范</h2><h2 id="CMD（Common-Module-Definition）"><a href="#CMD（Common-Module-Definition）" class="headerlink" title="CMD（Common Module Definition）"></a>CMD（Common Module Definition）</h2><p>CMD是SeaJS在推广过程中生产的对模块定义的规范，在Web浏览器端的模块加载器中，SeaJS与RequireJS并称，SeaJS作者为阿里的玉伯。</p>
<p>CMD规范专门用于浏览器端，模块的加载是异步的，模块使用时才会加载执行。CMD规范整合了CommonJS和AMD规范的特点。在 Sea.js 中，所有 JavaScript 模块都遵循 CMD模块定义规范。</p>
<h3 id="CMD语法"><a href="#CMD语法" class="headerlink" title="CMD语法"></a>CMD语法</h3><h4 id="定义暴露模块："><a href="#定义暴露模块：" class="headerlink" title="定义暴露模块："></a><strong>定义暴露模块：</strong></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义没有依赖的模块</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>)</span>&#123;</span><br><span class="line">  exports.xxx = value</span><br><span class="line">  <span class="built_in">module</span>.exports = value</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义有依赖的模块</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//引入依赖模块(同步)</span></span><br><span class="line">  <span class="keyword">var</span> module2 = <span class="built_in">require</span>(<span class="string">'./module2'</span>)</span><br><span class="line">  <span class="comment">//引入依赖模块(异步)</span></span><br><span class="line">    <span class="built_in">require</span>.async(<span class="string">'./module3'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">m3</span>) </span>&#123;</span><br><span class="line">    &#125;)</span><br><span class="line">  <span class="comment">//暴露模块</span></span><br><span class="line">  exports.xxx = value</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="引入使用模块："><a href="#引入使用模块：" class="headerlink" title="引入使用模块："></a><strong>引入使用模块：</strong></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">require</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> m1 = <span class="built_in">require</span>(<span class="string">'./module1'</span>)</span><br><span class="line">  <span class="keyword">var</span> m4 = <span class="built_in">require</span>(<span class="string">'./module4'</span>)</span><br><span class="line">  m1.show()</span><br><span class="line">  m4.show()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="CMD的优缺点"><a href="#CMD的优缺点" class="headerlink" title="CMD的优缺点"></a>CMD的优缺点</h3><ul>
<li>优点：依赖就近，延迟执行 可以很容易在 Node.js 中运行；</li>
<li>缺点：依赖 SPM 打包，模块的加载逻辑偏重；</li>
</ul>
<h3 id="sea-js使用步骤"><a href="#sea-js使用步骤" class="headerlink" title="sea.js使用步骤"></a>sea.js使用步骤</h3><h4 id="1-下载sea-js-并引入"><a href="#1-下载sea-js-并引入" class="headerlink" title="1. 下载sea.js, 并引入"></a>1. 下载sea.js, 并引入</h4><ul>
<li>官网: <a href="http://seajs.org/" target="_blank" rel="noopener">seajs.org/</a></li>
<li>github : <a href="https://github.com/seajs/seajs" target="_blank" rel="noopener">github.com/seajs/seajs</a></li>
</ul>
<p>然后将sea.js导入项目: js/libs/sea.js</p>
<h4 id="2-创建项目结构-1"><a href="#2-创建项目结构-1" class="headerlink" title="2. 创建项目结构"></a>2. 创建项目结构</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">|-js</span><br><span class="line">  |-libs</span><br><span class="line">    |-sea.js</span><br><span class="line">  |-modules</span><br><span class="line">    |-module1.js</span><br><span class="line">    |-module2.js</span><br><span class="line">    |-module3.js</span><br><span class="line">    |-module4.js</span><br><span class="line">    |-main.js</span><br><span class="line">|-index.html</span><br></pre></td></tr></table></figure>

<h4 id="3-定义sea-js的模块代码"><a href="#3-定义sea-js的模块代码" class="headerlink" title="3. 定义sea.js的模块代码"></a>3. 定义sea.js的模块代码</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// module1.js文件</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//内部变量数据</span></span><br><span class="line">  <span class="keyword">var</span> data = <span class="string">'atguigu.com'</span></span><br><span class="line">  <span class="comment">//内部函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'module1 show() '</span> + data)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//向外暴露</span></span><br><span class="line">  exports.show = show</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// module2.js文件</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    msg: <span class="string">'I Will Back'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// module3.js文件</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> API_KEY = <span class="string">'abc123'</span></span><br><span class="line">  exports.API_KEY = API_KEY</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// module4.js文件</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//引入依赖模块(同步)</span></span><br><span class="line">  <span class="keyword">var</span> module2 = <span class="built_in">require</span>(<span class="string">'./module2'</span>)</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'module4 show() '</span> + module2.msg)</span><br><span class="line">  &#125;</span><br><span class="line">  exports.show = show</span><br><span class="line">  <span class="comment">//引入依赖模块(异步)</span></span><br><span class="line">  <span class="built_in">require</span>.async(<span class="string">'./module3'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">m3</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'异步引入依赖模块3  '</span> + m3.API_KEY)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js文件</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params">require</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> m1 = <span class="built_in">require</span>(<span class="string">'./module1'</span>)</span><br><span class="line">  <span class="keyword">var</span> m4 = <span class="built_in">require</span>(<span class="string">'./module4'</span>)</span><br><span class="line">  m1.show()</span><br><span class="line">  m4.show()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="4-在index-html中引入"><a href="#4-在index-html中引入" class="headerlink" title="4. 在index.html中引入"></a>4. 在index.html中引入</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"js/libs/sea.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script type="text/</span>javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">  seajs.use('./js/modules/main')</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="ES6模块化（-重点介绍-）"><a href="#ES6模块化（-重点介绍-）" class="headerlink" title="ES6模块化（==重点介绍==）"></a>ES6模块化（==重点介绍==）</h2><p>ES6模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。所以说ES6是<strong>编译时加载</strong>，不同于CommonJS的运行时加载(实际加载的是一整个对象)，ES6模块不是对象，而是通过export命令显式指定输出的代码，输入时也采用静态命令的形式。</p>
<p>ES6 的模块自动采用严格模式，不管你有没有在模块头部加上<code>&quot;use strict&quot;;</code>。</p>
<p>严格模式主要有以下限制。</p>
<ul>
<li>变量必须声明后再使用</li>
<li>函数的参数不能有同名属性，否则报错</li>
<li>不能使用<code>with</code>语句</li>
<li>不能对只读属性赋值，否则报错</li>
<li>不能使用前缀 0 表示八进制数，否则报错</li>
<li>不能删除不可删除的属性，否则报错</li>
<li>不能删除变量<code>delete prop</code>，会报错，只能删除属性<code>delete global[prop]</code></li>
<li><code>eval</code>不会在它的外层作用域引入变量</li>
<li><code>eval</code>和<code>arguments</code>不能被重新赋值</li>
<li><code>arguments</code>不会自动反映函数参数的变化</li>
<li>不能使用<code>arguments.callee</code></li>
<li>不能使用<code>arguments.caller</code></li>
<li>禁止<code>this</code>指向全局对象</li>
<li>不能使用<code>fn.caller</code>和<code>fn.arguments</code>获取函数调用的堆栈</li>
<li>增加了保留字（比如<code>protected</code>、<code>static</code>和<code>interface</code>）</li>
</ul>
<p>上面这些限制，模块都必须遵守。由于严格模式是 ES5 引入的，不属于 ES6，所以请参阅相关 ES5 书籍，本书不再详细介绍了。</p>
<p>其中，尤其需要注意<code>this</code>的限制。ES6 模块之中，顶层的<code>this</code>指向<code>undefined</code>，即不应该在顶层代码使用<code>this</code>。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。</p>
<h4 id="export"><a href="#export" class="headerlink" title="export"></a>export</h4><p>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。下面是一个 JS 文件，里面使用export命令输出变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cUl</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ulEle = <span class="built_in">document</span>.createElement(<span class="string">"ul"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> liEle = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</span><br><span class="line">        liEle.innerHTML = <span class="string">"无序列表"</span> + i;</span><br><span class="line">        ulEle.appendChild(liEle);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ulEle;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> ul = cUl();</span><br><span class="line"><span class="keyword">export</span> &#123;ul&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="import"><a href="#import" class="headerlink" title="import"></a>import</h4><p>使用<code>export</code>命令定义了模块的对外接口以后，其他 JS 文件就可以通过<code>import</code>命令加载这个模块。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;table&#125; <span class="keyword">from</span> <span class="string">"../test/test_table.js"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;div&#125; <span class="keyword">from</span> <span class="string">"../test/test_div.js"</span> ;</span><br><span class="line"><span class="keyword">import</span> &#123;ul&#125; <span class="keyword">from</span> <span class="string">"../test/test_ul.js"</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;table, div, ul&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="ES6-模块与-CommonJS-模块的差异"><a href="#ES6-模块与-CommonJS-模块的差异" class="headerlink" title="ES6 模块与 CommonJS 模块的差异"></a>ES6 模块与 CommonJS 模块的差异</h3><p>它们有两个重大差异：</p>
<p><strong>1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用</strong>。</p>
<p><strong>2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口</strong>。</p>
<p>第二个差异是因为 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p>
<p>下面重点解释第一个差异，我们还是举上面那个CommonJS模块的加载机制例子:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; counter, incCounter &#125; <span class="keyword">from</span> <span class="string">'./lib'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 3</span></span><br><span class="line">incCounter();</span><br><span class="line"><span class="built_in">console</span>.log(counter); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p>ES6 模块的运行机制与 CommonJS 不一样。<strong>ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块</strong>。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1></font>



]]></content>
      <categories>
        <category>前端模块化</category>
      </categories>
      <tags>
        <tag>前端模块化</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6模块</title>
    <url>/yinyiwang/2020/04/21/2020-04-21-ES6%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在 ES6 前， 实现模块化使用的是 RequireJS 或者 seaJS（分别是基于 AMD 规范的模块化库， 和基于 CMD 规范的模块化库）。<br>ES6 引入了模块化，其设计思想是在编译时就能确定模块的依赖关系，以及输入和输出的变量。<br>ES6 的模块化分为导出（export） @与导入（import）两个模块。</p>
<a id="more"></a>

<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>ES6 的模块自动开启严格模式，不管你有没有在模块头部加上 <strong>use strict;</strong>。<br>模块中可以导入和导出各种类型的变量，如函数，对象，字符串，数字，布尔值，类等。<br>每个模块都有自己的上下文，每一个模块内声明的变量都是局部变量，不会污染全局作用域。<br>每一个模块只加载一次（是单例的）， 若再去加载同目录下同文件，直接从内存中读取。</p>
<h2 id="export-与-import"><a href="#export-与-import" class="headerlink" title="export 与 import"></a>export 与 import</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>模块导入导出各种类型的变量，如字符串，数值，函数，类。</p>
<ul>
<li>导出的函数声明与类声明必须要有名称（export default 命令另外考虑）。 </li>
<li>不仅能导出声明还能导出引用（例如函数）。</li>
<li>export 命令可以出现在模块的任何位置，但必需处于模块顶层。</li>
<li>import 命令会提升到整个模块的头部，首先执行。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*-----export [test.js]-----*/</span></span><br><span class="line"><span class="keyword">let</span> myName = <span class="string">"Tom"</span>;</span><br><span class="line"><span class="keyword">let</span> myAge = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> myfn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"My name is"</span> + myName + <span class="string">"! I'm '"</span> + myAge + <span class="string">"years old."</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myClass =  <span class="class"><span class="keyword">class</span> <span class="title">myClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> a = <span class="string">"yeah!"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; myName, myAge, myfn, myClass &#125; </span><br><span class="line"><span class="comment">/*-----import [xxx.js]-----*/</span></span><br><span class="line"><span class="keyword">import</span> &#123; myName, myAge, myfn, myClass &#125; <span class="keyword">from</span> <span class="string">"./test.js"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myfn());<span class="comment">// My name is Tom! I'm 20 years old.</span></span><br><span class="line"><span class="built_in">console</span>.log(myAge);<span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(myName);<span class="comment">// Tom</span></span><br><span class="line"><span class="built_in">console</span>.log(myClass.a );<span class="comment">// yeah!</span></span><br></pre></td></tr></table></figure>
<p>建议使用大括号指定所要输出的一组变量写在文档尾部，明确导出的接口。<br>函数与类都需要有对应的名称，导出文档尾部也避免了无对应名称。</p>
<h3 id="as-的用法"><a href="#as-的用法" class="headerlink" title="as 的用法"></a>as 的用法</h3><p>export 命令导出的接口名称，须和模块内部的变量有一一对应关系。<br>导入的变量名，须和导出的接口名称相同，即顺序可以不一致。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*-----export [test.js]-----*/</span></span><br><span class="line"><span class="keyword">let</span> myName = <span class="string">"Tom"</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; myName <span class="keyword">as</span> exportName &#125;</span><br><span class="line"><span class="comment">/*-----import [xxx.js]-----*/</span></span><br><span class="line"><span class="keyword">import</span> &#123; exportName &#125; <span class="keyword">from</span> <span class="string">"./test.js"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(exportName);<span class="comment">// Tom</span></span><br><span class="line"><span class="comment">// 使用 as 重新定义导出的接口名称，隐藏模块内部的变量</span></span><br><span class="line"><span class="comment">/*-----export [test1.js]-----*/</span></span><br><span class="line"><span class="keyword">let</span> myName = <span class="string">"Tom"</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; myName &#125;</span><br><span class="line"><span class="comment">/*-----export [test2.js]-----*/</span></span><br><span class="line"><span class="keyword">let</span> myName = <span class="string">"Jerry"</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; myName &#125;</span><br><span class="line"><span class="comment">/*-----import [xxx.js]-----*/</span></span><br><span class="line"><span class="keyword">import</span> &#123; myName <span class="keyword">as</span> name1 &#125; <span class="keyword">from</span> <span class="string">"./test1.js"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; myName <span class="keyword">as</span> name2 &#125; <span class="keyword">from</span> <span class="string">"./test2.js"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name1);<span class="comment">// Tom</span></span><br><span class="line"><span class="built_in">console</span>.log(name2);<span class="comment">// Jerry</span></span><br></pre></td></tr></table></figure>
<p>不同模块导出接口名称命名重复， 使用 as 重新定义变量名。</p>
<h3 id="import-命令的特点"><a href="#import-命令的特点" class="headerlink" title="import 命令的特点"></a>import 命令的特点</h3><p><strong>只读属性</strong>：不允许在加载模块的脚本里面，改写接口的引用指向，即可以改写 import 变量类型为对象的属性值，不能改写 import 变量类型为基本类型的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;a&#125; <span class="keyword">from</span> <span class="string">"./xxx.js"</span></span><br><span class="line">a = &#123;&#125;; <span class="comment">// error</span></span><br><span class="line"><span class="keyword">import</span> &#123;a&#125; <span class="keyword">from</span> <span class="string">"./xxx.js"</span></span><br><span class="line">a.foo = <span class="string">"hello"</span>; <span class="comment">// a = &#123; foo : 'hello' &#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>单例模式</strong>：多次重复执行同一句 import 语句，那么只会执行一次，而不会执行多次。import 同一模块，声明不同接口引用，会声明对应变量，但只执行一次 import 。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; a &#125; <span class="string">"./xxx.js"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; a &#125; <span class="string">"./xxx.js"</span>;</span><br><span class="line"><span class="comment">// 相当于 import &#123; a &#125; "./xxx.js";</span></span><br><span class="line"><span class="keyword">import</span> &#123; a &#125; <span class="keyword">from</span> <span class="string">"./xxx.js"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; b &#125; <span class="keyword">from</span> <span class="string">"./xxx.js"</span>;</span><br><span class="line"><span class="comment">// 相当于 import &#123; a, b &#125; from "./xxx.js";</span></span><br></pre></td></tr></table></figure>
<p><strong>静态执行特性</strong>：import 是静态执行，所以不能使用表达式和变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="string">"f"</span> + <span class="string">"oo"</span> &#125; <span class="keyword">from</span> <span class="string">"methods"</span>;</span><br><span class="line"><span class="comment">// error</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">module</span> = <span class="string">"methods"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="built_in">module</span>;</span><br><span class="line"><span class="comment">// error</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">"method1"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">"method2"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// error</span></span><br></pre></td></tr></table></figure>
<h3 id="export-default-命令"><a href="#export-default-命令" class="headerlink" title="export default 命令"></a>export default 命令</h3><ul>
<li>在一个文件或模块中，export、import 可以有多个，export default 仅有一个。</li>
<li>export default 中的 default 是对应的导出接口变量。</li>
<li>通过 export 方式导出，在导入时要加{ }，export default 则不需要。</li>
<li>export default 向外暴露的成员，可以使用任意变量来接收。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">"My name is Tom!"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> a; <span class="comment">// 仅有一个</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">var</span> c = <span class="string">"error"</span>; </span><br><span class="line"><span class="comment">// error，default 已经是对应的导出变量，不能跟着变量声明语句</span></span><br><span class="line"><span class="keyword">import</span> b <span class="keyword">from</span> <span class="string">"./xxx.js"</span>; <span class="comment">// 不需要加&#123;&#125;， 使用任意变量接收</span></span><br></pre></td></tr></table></figure>
<h2 id="复合使用"><a href="#复合使用" class="headerlink" title="复合使用"></a>复合使用</h2>export 与 import 可以在同一模块使用，使用特点：</li>
<li>可以将导出接口改名，包括 default。 </li>
<li>复合使用 export 与 import ，也可以导出全部，当前模块导出的接口会覆盖继承导出的。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">"methods"</span>;</span><br><span class="line"><span class="comment">// 约等于下面两段语句，不过上面导入导出方式该模块没有导入 foo 与 bar</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">"methods"</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; foo, bar &#125;;</span><br><span class="line"><span class="comment">/* ------- 特点 1 --------*/</span></span><br><span class="line"><span class="comment">// 普通改名</span></span><br><span class="line"><span class="keyword">export</span> &#123; foo <span class="keyword">as</span> bar &#125; <span class="keyword">from</span> <span class="string">"methods"</span>;</span><br><span class="line"><span class="comment">// 将 foo 转导成 default</span></span><br><span class="line"><span class="keyword">export</span> &#123; foo <span class="keyword">as</span> <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">"methods"</span>;</span><br><span class="line"><span class="comment">// 将 default 转导成 foo</span></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> foo &#125; <span class="keyword">from</span> <span class="string">"methods"</span>;</span><br><span class="line"><span class="comment">/* ------- 特点 2 --------*/</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">"methods"</span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>— ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>模块</tag>
      </tags>
  </entry>
  <entry>
    <title>致对象</title>
    <url>/yinyiwang/2020/04/22/2020-04-22-%E8%87%B4%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/04/22/rS7L4ZChb23kvIE.jpg" alt=""></p>
<p>那时年少爱幻想<br>告别了灯红酒绿<br>来到了零一的世界<br>这是你的世界<br>也是我的梦想</p>
<p>我们厮杀过<br>那一行行灰色<br>见证着我对你的伤害<br>这一根根白发<br>承载着你对我的报复</p>
<p>我们也相爱过<br>为了完美<br>我曾无数次将你雕琢<br>作为回报<br>你曾无数次给我喜悦</p>
<p>这一生<br>大概就这样了<br>待来世<br>我捧你上王座</p>
<p><img src="https://i.loli.net/2020/04/22/bQwtpnWPGA4dfE3.png" alt=""></p>
]]></content>
  </entry>
  <entry>
    <title>ES6迭代器</title>
    <url>/yinyiwang/2020/04/24/2020-04-24-ES6%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<p style = 'color:red'>这是一个p标签</p>

<p><img src="https://i.loli.net/2020/04/24/zX21NdsLFHcA5OZ.jpg" alt="K9DIWTU0D4KID_thumbnail"></p>
<h2 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h2><p>Iterator 是 ES6 引入的一种新的遍历机制，迭代器有两个核心概念：</p>
<ul>
<li>迭代器是一个统一的接口，它的作用是使各种数据结构可被便捷的访问，它是通过一个键为Symbol.iterator 的方法来实现。</li>
<li>迭代器是用于遍历数据结构元素的指针（如数据库中的游标）。</li>
</ul>
<a id="more"></a>

<h3 id="迭代过程"><a href="#迭代过程" class="headerlink" title="迭代过程"></a>迭代过程</h3><p>迭代的过程如下：</p>
<ul>
<li>通过 Symbol.iterator 创建一个迭代器，指向当前数据结构的起始位置</li>
<li>随后通过 next 方法进行向下迭代指向下一个位置， next 方法会返回当前位置的对象，对象包含了 value 和 done 两个属性， value 是当前属性的值， done 用于判断是否遍历结束</li>
<li>当 done 为 true 时则遍历结束</li>
</ul>
<p>下面通过一个简单的例子进行说明：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> items = [<span class="string">"zero"</span>, <span class="string">"one"</span>, <span class="string">"two"</span>]; </span><br><span class="line"><span class="keyword">const</span> it = items[<span class="built_in">Symbol</span>.iterator]();  </span><br><span class="line">it.next(); </span><br><span class="line">&gt;&#123;<span class="attr">value</span>: <span class="string">"zero"</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125; </span><br><span class="line">it.next(); </span><br><span class="line">&gt;&#123;<span class="attr">value</span>: <span class="string">"one"</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125; </span><br><span class="line">it.next(); </span><br><span class="line">&gt;&#123;<span class="attr">value</span>: <span class="string">"two"</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125; </span><br><span class="line">it.next(); </span><br><span class="line">&gt;&#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子，首先创建一个数组，然后通过 Symbol.iterator 方法创建一个迭代器，之后不断的调用 next 方法对数组内部项进行访问，当属性 done 为 true 时访问结束。</p>
<p>迭代器是协议（使用它们的规则）的一部分，用于迭代。该协议的一个关键特性就是它是顺序的：迭代器一次返回一个值。这意味着如果可迭代数据结构是非线性的（例如树），迭代将会使其线性化。</p>
<h3 id="可迭代的数据结构"><a href="#可迭代的数据结构" class="headerlink" title="可迭代的数据结构"></a>可迭代的数据结构</h3><p>以下是可迭代的值:</p>
<ul>
<li>Array</li>
<li>String</li>
<li>Map</li>
<li>Set</li>
<li>Dom元素（正在进行中）</li>
</ul>
<p>我们将使用 <strong>for…of</strong> 循环（参见下文的 for…of 循环）对数据结构进行迭代。</p>
<p><strong>Array</strong></p>
<p>数组 ( Array ) 和类型数组 ( TypedArray ) 他们是可迭代的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> [<span class="string">"zero"</span>, <span class="string">"one"</span>, <span class="string">"two"</span>]) &#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(item); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// output: </span></span><br><span class="line"><span class="comment">// zero </span></span><br><span class="line"><span class="comment">// one </span></span><br><span class="line"><span class="comment">// two</span></span><br></pre></td></tr></table></figure>

<p><strong>String</strong></p>
<p>字符串是可迭代的，单他们遍历的是 Unicode 码，每个码可能包含一个到两个的 Javascript 字符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> c <span class="keyword">of</span> <span class="string">'z\uD83D\uDC0A'</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(c); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// output: </span></span><br><span class="line"><span class="comment">// z </span></span><br><span class="line"><span class="comment">// \uD83D\uDC0A</span></span><br></pre></td></tr></table></figure>

<p><strong>Map</strong></p>
<p>Map 主要是迭代它们的 entries ，每个 entry 都会被编码为 [key, value] 的项， entries 是以确定的形势进行迭代，其顺序是与添加的顺序相同。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(); </span><br><span class="line">map.set(<span class="number">0</span>, <span class="string">"zero"</span>); </span><br><span class="line">map.set(<span class="number">1</span>, <span class="string">"one"</span>);  </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> map) &#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(item); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// output: </span></span><br><span class="line"><span class="comment">// [0, "zero"] </span></span><br><span class="line"><span class="comment">// [1, "one"]</span></span><br></pre></td></tr></table></figure>

<p>注意： WeakMaps 不可迭代</p>
<p><strong>Set</strong></p>
<p>Set 是对其元素进行迭代，迭代的顺序与其添加的顺序相同</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set(); </span><br><span class="line"><span class="keyword">set</span>.add("zero"); </span><br><span class="line"><span class="keyword">set</span>.add("one");  </span><br><span class="line">for (let item of <span class="keyword">set</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// output: </span></span><br><span class="line"><span class="comment">// zero </span></span><br><span class="line"><span class="comment">// one</span></span><br></pre></td></tr></table></figure>

<p>注意： WeakSets 不可迭代</p>
<p><strong>arguments</strong></p>
<p>arguments 目前在 ES6 中使用越来越少，但也是可遍历的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">args</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> <span class="built_in">arguments</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; args(<span class="string">"zero"</span>, <span class="string">"one"</span>); </span><br><span class="line"><span class="comment">// output: </span></span><br><span class="line"><span class="comment">// zero </span></span><br><span class="line"><span class="comment">// one</span></span><br></pre></td></tr></table></figure>

<h3 id="普通对象不可迭代"><a href="#普通对象不可迭代" class="headerlink" title="普通对象不可迭代"></a>普通对象不可迭代</h3><p>普通对象是由 object 创建的，不可迭代：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TypeError </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> &#123;&#125;) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="for…of循环"><a href="#for…of循环" class="headerlink" title="for…of循环"></a>for…of循环</h2><p>for…of 是 ES6 新引入的循环，用于替代 for..in 和 forEach() ，并且支持新的迭代协议。它可用于迭代常规的数据类型，如 <code>Array</code> 、 <code>String</code> 、 <code>Map</code>和 <code>Set</code> 等等。</p>
<h3 id="迭代常规数据类型"><a href="#迭代常规数据类型" class="headerlink" title="迭代常规数据类型"></a>迭代常规数据类型</h3><p><strong>Array</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nums = [<span class="string">"zero"</span>, <span class="string">"one"</span>, <span class="string">"two"</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num); </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// TypedArray </span></span><br><span class="line"><span class="keyword">const</span> typedArray1 = <span class="keyword">new</span> <span class="built_in">Int8Array</span>(<span class="number">6</span>); </span><br><span class="line">typedArray1[<span class="number">0</span>] = <span class="number">10</span>; </span><br><span class="line">typedArray1[<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> typedArray1) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>String</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">"zero"</span>;  </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> str) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Map</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>(); </span><br><span class="line">myMap.set(<span class="number">0</span>, <span class="string">"zero"</span>); </span><br><span class="line">myMap.set(<span class="number">1</span>, <span class="string">"one"</span>); </span><br><span class="line">myMap.set(<span class="number">2</span>, <span class="string">"two"</span>);  </span><br><span class="line"><span class="comment">// 遍历 key 和 value </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> myMap) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key + <span class="string">" = "</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> myMap.entries()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key + <span class="string">" = "</span> + value);</span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 只遍历 key </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> myMap.keys()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 只遍历 value </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> myMap.values()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Set</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mySet = <span class="keyword">new</span> <span class="built_in">Set</span>(); </span><br><span class="line">mySet.add(<span class="string">"zero"</span>); </span><br><span class="line">mySet.add(<span class="string">"one"</span>); </span><br><span class="line">mySet.add(<span class="string">"two"</span>);  </span><br><span class="line"><span class="comment">// 遍历整个 set </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> mySet) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 只遍历 key 值 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> mySet.keys()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 只遍历 value </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> mySet.values()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 遍历 key 和 value ，两者会相等 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> mySet.entries()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key + <span class="string">" = "</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可迭代的数据结构-1"><a href="#可迭代的数据结构-1" class="headerlink" title="可迭代的数据结构"></a>可迭代的数据结构</h3><p>of 操作数必须是可迭代，这意味着如果是普通对象则无法进行迭代。如果数据结构类似于数组的形式，则可以借助 Array.from() 方法进行转换迭代。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayLink = &#123;</span><br><span class="line">    length: <span class="number">2</span>, </span><br><span class="line">    <span class="number">0</span>: <span class="string">"zero"</span>, </span><br><span class="line">    <span class="number">1</span>: <span class="string">"one"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 报 TypeError 异常 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arrayLink) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 正常运行 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> <span class="built_in">Array</span>.from(arrayLink)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output: </span></span><br><span class="line"><span class="comment">// zero </span></span><br><span class="line"><span class="comment">// one</span></span><br></pre></td></tr></table></figure>

<p><strong>let 、const 和 var 用于 for..of</strong></p>
<p>如果使用 let 和 const ，每次迭代将会创建一个新的存储空间，这可以保证作用域在迭代的内部。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nums = [<span class="string">"zero"</span>, <span class="string">"one"</span>, <span class="string">"two"</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num);</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 报 ReferenceError </span></span><br><span class="line"><span class="built_in">console</span>.log(num);</span><br></pre></td></tr></table></figure>

<p>从上面的例子我们看到，最后一句会报异常，原因 num 的作用域只在循环体内部，外部无效。使用 var 则不会出现上述情况，因为 var 会作用于全局，迭代将不会每次都创建一个新的存储空间。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nums = [<span class="string">"zero"</span>, <span class="string">"one"</span>, <span class="string">"two"</span>];</span><br><span class="line">forv (<span class="keyword">var</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num);</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">console</span>.log(num);</span><br><span class="line"><span class="comment">// output: two</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/04/24/oEYfrkFBCDzR7e2.png" alt="01"></p>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>迭代器</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6_Promise</title>
    <url>/yinyiwang/2020/04/25/2020-04-25-ES6-Promise/</url>
    <content><![CDATA[<p>ECMAscript 6 原生提供了 Promise 对象。<br>Promise 对象代表了未来将要发生的事件，用来传递异步操作的消息。</p>
<a id="more"></a>

<h3 id="Promise-对象有以下两个特点"><a href="#Promise-对象有以下两个特点" class="headerlink" title="Promise 对象有以下两个特点:"></a>Promise 对象有以下两个特点:</h3><p>1、对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态：</p>
<ul>
<li><code>pending</code>: 初始状态，不是成功或失败状态。</li>
<li><code>fulfilled</code>: 意味着操作成功完成。</li>
<li><code>rejected</code>: 意味着操作失败。</li>
</ul>
<p>只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是 Promise 这个名字的由来，它的英语意思就是「承诺」，表示其他手段无法改变。</p>
<p>2、一旦状态改变，就不会再变，任何时候都可以得到这个结果。</p>
<p>Promise 对象的状态改变，只有两种可能：从 Pending 变为 Resolved 和从 Pending 变为 Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p>
<h3 id="Promise-优缺点"><a href="#Promise-优缺点" class="headerlink" title="Promise 优缺点"></a>Promise 优缺点</h3><p>有了 Promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise 对象提供统一的接口，使得控制异步操作更加容易。</p>
<p>Promise 也有一些缺点。首先，无法取消 Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。第三，当处于 Pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p>
<h3 id="Promise-创建"><a href="#Promise-创建" class="headerlink" title="Promise 创建"></a>Promise 创建</h3><p>要想创建一个 promise 对象、可以使用 new 来调用 Promise 的构造器来进行实例化。<br>下面是创建 promise 的步骤：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 异步处理    </span></span><br><span class="line">    <span class="comment">// 处理结束后、调用resolve 或 reject </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Promise 构造函数包含一个参数和一个带有 resolve（解析）和 reject（拒绝）两个参数的回调。在回调中执行一些操作（例如异步），如果一切都正常，则调用 resolve，否则调用 reject。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myFirstPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 当异步代码执行成功时，我们才会调用resolve(...), </span></span><br><span class="line">    <span class="comment">// 当异步代码失败时就会调用reject(...)</span></span><br><span class="line">    <span class="comment">// 在本例中，我们使用setTimeout(...)来模拟异步代码</span></span><br><span class="line">    <span class="comment">// 实际编码时可能是XHR请求或是HTML5的一些API方法.    </span></span><br><span class="line">	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		resolve(<span class="string">"成功!"</span>); <span class="comment">//代码正常执行！</span></span><br><span class="line">	&#125;, <span class="number">250</span>); </span><br><span class="line">&#125;);  </span><br><span class="line">myFirstPromise.then(<span class="function"><span class="keyword">function</span>(<span class="params">successMessage</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//successMessage的值是上面调用resolve(...)方法传入的值.    </span></span><br><span class="line">    <span class="comment">//successMessage参数不一定非要是字符串类型，这里只是举个例子</span></span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">"Yay! "</span> + successMessage); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>对于已经实例化过的 promise 对象可以调用 promise.then() 方法，传递 resolve 和 reject 方法作为回调。</p>
<p>promise.then() 是 promise 最为常用的方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">promise.then(onFulfilled, onRejected)</span><br></pre></td></tr></table></figure>

<p>promise简化了对error的处理，上面的代码我们也可以这样写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">promise.then(onFulfilled).catch(onRejected)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Promise-Ajax"><a href="#Promise-Ajax" class="headerlink" title="Promise Ajax"></a>Promise Ajax</h2><p>下面是一个用 Promise 对象实现的 Ajax 操作的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">URL</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        req.open(<span class="string">'GET'</span>, URL, <span class="literal">true</span>);</span><br><span class="line">        req.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (req.status === <span class="number">200</span>) &#123;</span><br><span class="line">                resolve(req.responseText);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                reject(<span class="keyword">new</span> <span class="built_in">Error</span>(req.statusText));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        req.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            reject(<span class="keyword">new</span> <span class="built_in">Error</span>(req.statusText));</span><br><span class="line">        &#125;;</span><br><span class="line">        req.send();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> URL = <span class="string">"/try/ajax/testpromise.php"</span>;</span><br><span class="line">ajax(URL).then(<span class="function"><span class="keyword">function</span> <span class="title">onFulfilled</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">'内容是：'</span> + value);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> <span class="title">onRejected</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">'错误：'</span> + error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，resolve 方法和 reject 方法调用时，都带有参数。它们的参数会被传递给回调函数。</p>
<p>reject 方法的参数通常是 Error 对象的实例，而 resolve 方法的参数除了正常的值以外，还可能是另一个 Promise 实例，比如像下面这样。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ... some code</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ... some code  resolve(p1);</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上面代码中，p1 和 p2 都是 Promise 的实例，但是 p2 的 resolve 方法将 p1 作为参数，这时 p1 的状态就会传递给 p2。如果调用的时候，p1 的状态是 pending，那么 p2 的回调函数就会等待 p1 的状态改变；如果 p1 的状态已经是 fulfilled 或者 rejected，那么 p2 的回调函数将会立刻执行。</p>
<hr>
<h2 id="Promise-prototype-then方法：链式操作"><a href="#Promise-prototype-then方法：链式操作" class="headerlink" title="Promise.prototype.then方法：链式操作"></a>Promise.prototype.then方法：链式操作</h2><p>Promise.prototype.then 方法返回的是一个新的 Promise 对象，因此可以采用链式写法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getJSON(<span class="string">"/posts.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> json.post;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// proceed</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面的代码使用 then 方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</p>
<p>如果前一个回调函数返回的是Promise对象，这时后一个回调函数就会等待该Promise对象有了运行结果，才会进一步调用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getJSON(<span class="string">"/post/1.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getJSON(post.commentURL);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">comments</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对comments进行处理</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这种设计使得嵌套的异步操作，可以被很容易得改写，从回调函数的”横向发展”改为”向下发展”。</p>
<hr>
<h2 id="Promise-prototype-catch方法：捕捉错误"><a href="#Promise-prototype-catch方法：捕捉错误" class="headerlink" title="Promise.prototype.catch方法：捕捉错误"></a>Promise.prototype.catch方法：捕捉错误</h2><p>Promise.prototype.catch 方法是 Promise.prototype.then(null, rejection) 的别名，用于指定发生错误时的回调函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getJSON(<span class="string">"/posts.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">posts</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// some code</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 处理前一个回调函数运行时发生的错误</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'发生错误！'</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Promise 对象的错误具有”冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个 catch 语句捕获。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getJSON(<span class="string">"/post/1.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getJSON(post.commentURL);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">comments</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// some code</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 处理前两个回调函数的错误</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Promise-all方法，Promise-race方法"><a href="#Promise-all方法，Promise-race方法" class="headerlink" title="Promise.all方法，Promise.race方法"></a>Promise.all方法，Promise.race方法</h2><p>Promise.all 方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.all([p1,p2,p3]);</span><br></pre></td></tr></table></figure>

<p>上面代码中，Promise.all 方法接受一个数组作为参数，p1、p2、p3 都是 Promise 对象的实例。（Promise.all 方法的参数不一定是数组，但是必须具有 <strong>iterator 接口</strong>，且返回的每个成员都是 Promise 实例。）</p>
<p>p 的状态由 p1、p2、p3 决定，分成两种情况。</p>
<ul>
<li>只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。</li>
<li>只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。</li>
</ul>
<p>下面是一个具体的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成一个Promise对象的数组 </span></span><br><span class="line"><span class="keyword">var</span> promises = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>].map(<span class="function"><span class="keyword">function</span>(<span class="params">id</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getJSON(<span class="string">"/post/"</span> + id + <span class="string">".json"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Promise</span>.all(promises).then(<span class="function"><span class="keyword">function</span>(<span class="params">posts</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Promise.race 方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.race([p1,p2,p3]);</span><br></pre></td></tr></table></figure>

<p>上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的Promise实例的返回值，就传递给p的返回值。</p>
<p>如果Promise.all方法和Promise.race方法的参数，不是Promise实例，就会先调用下面讲到的Promise.resolve方法，将参数转为Promise实例，再进一步处理。</p>
<hr>
<h2 id="Promise-resolve-方法，Promise-reject-方法"><a href="#Promise-resolve-方法，Promise-reject-方法" class="headerlink" title="Promise.resolve 方法，Promise.reject 方法"></a>Promise.resolve 方法，Promise.reject 方法</h2><p>有时需要将现有对象转为Promise对象，Promise.resolve方法就起到这个作用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> jsPromise = <span class="built_in">Promise</span>.resolve($.ajax(<span class="string">'/whatever.json'</span>));</span><br></pre></td></tr></table></figure>

<p>上面代码将 jQuery 生成 deferred 对象，转为一个新的 ES6 的 Promise 对象。</p>
<p>如果 Promise.resolve 方法的参数，不是具有 then 方法的对象（又称 thenable 对象），则返回一个新的 Promise 对象，且它的状态为fulfilled。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve(<span class="string">'Hello'</span>);</span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span> (<span class="params">s</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(s)</span><br><span class="line">&#125;); </span><br><span class="line"><span class="comment">// Hello</span></span><br></pre></td></tr></table></figure>

<p>上面代码生成一个新的Promise对象的实例p，它的状态为<code>fulfilled</code>，所以回调函数会立即执行，Promise.resolve方法的参数就是回调函数的参数。</p>
<p>如果Promise.resolve方法的参数是一个Promise对象的实例，则会被原封不动地返回。</p>
<p>Promise.reject(reason)方法也会返回一个新的Promise实例，该实例的状态为<code>rejected</code>。Promise.reject方法的参数reason，会被传递给实例的回调函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.reject(<span class="string">'出错了'</span>);</span><br><span class="line">p.then(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span> (<span class="params">s</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(s)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure>

<p>上面代码生成一个Promise对象的实例p，状态为<code>rejected</code>，回调函数会立即执行。</p>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>Apache-Jmeter简单配置及使用</title>
    <url>/yinyiwang/2020/04/28/2020-04-28-Apache-Jmeter%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Node模块Express简介</title>
    <url>/yinyiwang/2020/05/30/2020-05-30-Node%E6%A8%A1%E5%9D%97Express%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Express是目前最流行的基于Node.js的Web开发框架，可以快速地搭建一个完整功能的网站。</p>
<a id="more"></a>

<p>Express上手非常简单，首先新建一个项目目录，假定叫做hello-world。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ mkdir hello-world</span><br></pre></td></tr></table></figure>

<p>进入该目录，新建一个package.json文件，内容如下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"hello-world"</span>,</span><br><span class="line">  <span class="string">"description"</span>: <span class="string">"hello world test app"</span>,</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"0.0.1"</span>,</span><br><span class="line">  <span class="string">"private"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="string">"express"</span>: <span class="string">"4.x"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码定义了项目的名称、描述、版本等，并且指定需要4.0版本以上的Express。</p>
<p>然后，就可以安装了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$ npm install</span><br></pre></td></tr></table></figure>

<p>执行上面的命令以后，在项目根目录下，新建一个启动文件，假定叫做index.js。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.use(express.static(__dirname + <span class="string">'/public'</span>));</span><br><span class="line">app.listen(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20200530%20/14-37-59-3sBRp7.png" alt="1"></p>
<p>然后，运行上面的启动脚本。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ node index</span><br></pre></td></tr></table></figure>

<p>现在就可以访问<code>http://localhost:8080</code>，它会在浏览器中打开当前目录的public子目录（严格来说，是打开public目录的index.html文件）。如果public目录之中有一个图片文件<code>my_image.png</code>，那么可以用<code>http://localhost:8080/my_image.png</code>访问该文件。</p>
<p>你也可以在index.js之中，生成动态网页。<br><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20200530%20/14-39-34-etX7RH.png" alt="2"></p>
<p>然后，在命令行下运行启动脚本，就可以在浏览器中访问项目网站了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ node index</span><br></pre></td></tr></table></figure>

<p>上面代码会在本机的3000端口启动一个网站，网页显示Hello World。</p>
<p>启动脚本index.js的<code>app.get</code>方法，用于指定不同的访问路径所对应的回调函数，这叫做“路由”（routing）。上面代码只指定了根目录的回调函数，因此只有一个路由记录。实际应用中，可能有多个路由记录。</p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20200530%20/14-43-06-TVQccv.png" alt="3"></p>
<p>这时，最好就把路由放到一个单独的文件中，比如新建一个routes子目录。</p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20200530%20/14-44-25-oYAFro.png" alt="4"></p>
<p>然后，原来的index.js就变成下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="keyword">var</span> routes = <span class="built_in">require</span>(<span class="string">'./routes'</span>)(app);</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>



<h2 id="运行原理"><a href="#运行原理" class="headerlink" title="运行原理"></a>运行原理</h2><h3 id="底层：http模块"><a href="#底层：http模块" class="headerlink" title="底层：http模块"></a>底层：http模块</h3><p>Express框架建立在node.js内置的http模块上。http模块生成服务器的原始代码如下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line"><span class="keyword">var</span> app = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">  response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>&#125;);</span><br><span class="line">  response.end(<span class="string">"Hello world!"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="string">"localhost"</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码的关键是http模块的createServer方法，表示生成一个HTTP服务器实例。该方法接受一个回调函数，该回调函数的参数，分别为代表HTTP请求和HTTP回应的request对象和response对象。</p>
<p>Express框架的核心是对http模块的再包装。上面的代码用Express改写如下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.send(<span class="string">'Hello world!'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<p>比较两段代码，可以看到它们非常接近。原来是用<code>http.createServer</code>方法新建一个app实例，现在则是用Express的构造方法，生成一个Epress实例。两者的回调函数都是相同的。Express框架等于在http模块之上，加了一个中间层。</p>
<h3 id="什么是中间件"><a href="#什么是中间件" class="headerlink" title="什么是中间件"></a>什么是中间件</h3><p>简单说，中间件（middleware）就是处理HTTP请求的函数。它最大的特点就是，一个中间件处理完，再传递给下一个中间件。App实例在运行过程中，会调用一系列的中间件。</p>
<p>每个中间件可以从App实例，接收三个参数，依次为request对象（代表HTTP请求）、response对象（代表HTTP回应），next回调函数（代表下一个中间件）。每个中间件都可以对HTTP请求（request对象）进行加工，并且决定是否调用next方法，将request对象再传给下一个中间件。</p>
<p>一个不进行任何操作、只传递request对象的中间件，就是下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uselessMiddleware</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码的next就是下一个中间件。如果它带有参数，则代表抛出一个错误，参数为错误文本。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uselessMiddleware</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  next(<span class="string">'出错了！'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抛出错误以后，后面的中间件将不再执行，直到发现一个错误处理函数为止。</p>
<h3 id="use方法"><a href="#use方法" class="headerlink" title="use方法"></a>use方法</h3><p>use是express注册中间件的方法，它返回一个函数。下面是一个连续调用两个中间件的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">request, response, next</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"In comes a "</span> + request.method + <span class="string">" to "</span> + request.url);</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">  response.writeHead(<span class="number">200</span>, &#123; <span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span> &#125;);</span><br><span class="line">  response.end(<span class="string">"Hello world!\n"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">http.createServer(app).listen(<span class="number">1337</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码使用<code>app.use</code>方法，注册了两个中间件。收到HTTP请求后，先调用第一个中间件，在控制台输出一行信息，然后通过<code>next</code>方法，将执行权传给第二个中间件，输出HTTP回应。由于第二个中间件没有调用<code>next</code>方法，所以request对象就不再向后传递了。</p>
<p><code>use</code>方法内部可以对访问路径进行判断，据此就能实现简单的路由，根据不同的请求网址，返回不同的网页内容。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">request, response, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (request.url == <span class="string">"/"</span>) &#123;</span><br><span class="line">    response.writeHead(<span class="number">200</span>, &#123; <span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span> &#125;);</span><br><span class="line">    response.end(<span class="string">"Welcome to the homepage!\n"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">request, response, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (request.url == <span class="string">"/about"</span>) &#123;</span><br><span class="line">    response.writeHead(<span class="number">200</span>, &#123; <span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span> &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">  response.writeHead(<span class="number">404</span>, &#123; <span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span> &#125;);</span><br><span class="line">  response.end(<span class="string">"404 error!\n"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">http.createServer(app).listen(<span class="number">1337</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码通过<code>request.url</code>属性，判断请求的网址，从而返回不同的内容。注意，<code>app.use</code>方法一共登记了三个中间件，只要请求路径匹配，就不会将执行权交给下一个中间件。因此，最后一个中间件会返回404错误，即前面的中间件都没匹配请求路径，找不到所要请求的资源。</p>
<p>除了在回调函数内部判断请求的网址，use方法也允许将请求网址写在第一个参数。这代表，只有请求路径匹配这个参数，后面的中间件才会生效。无疑，这样写更加清晰和方便。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.use(<span class="string">'/path'</span>, someMiddleware);</span><br></pre></td></tr></table></figure>

<p>上面代码表示，只对根目录的请求，调用某个中间件。</p>
<p>因此，上面的代码可以写成下面的样子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">"/home"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">request, response, next</span>) </span>&#123;</span><br><span class="line">  response.writeHead(<span class="number">200</span>, &#123; <span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span> &#125;);</span><br><span class="line">  response.end(<span class="string">"Welcome to the homepage!\n"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">"/about"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">request, response, next</span>) </span>&#123;</span><br><span class="line">  response.writeHead(<span class="number">200</span>, &#123; <span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span> &#125;);</span><br><span class="line">  response.end(<span class="string">"Welcome to the about page!\n"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">  response.writeHead(<span class="number">404</span>, &#123; <span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span> &#125;);</span><br><span class="line">  response.end(<span class="string">"404 error!\n"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">http.createServer(app).listen(<span class="number">1337</span>);</span><br></pre></td></tr></table></figure>



<h2 id="Express的方法"><a href="#Express的方法" class="headerlink" title="Express的方法"></a>Express的方法</h2><h3 id="all方法和HTTP动词方法"><a href="#all方法和HTTP动词方法" class="headerlink" title="all方法和HTTP动词方法"></a>all方法和HTTP动词方法</h3><p>针对不同的请求，Express提供了use方法的一些别名。比如，上面代码也可以用别名的形式来写。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">"express"</span>);</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line">app.all(<span class="string">"*"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">request, response, next</span>) </span>&#123;</span><br><span class="line">  response.writeHead(<span class="number">200</span>, &#123; <span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span> &#125;);</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">"/"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">  response.end(<span class="string">"Welcome to the homepage!"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">"/about"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">  response.end(<span class="string">"Welcome to the about page!"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">"*"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">  response.end(<span class="string">"404!"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">http.createServer(app).listen(<span class="number">1337</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码的all方法表示，所有请求都必须通过该中间件，参数中的“*”表示对所有路径有效。get方法则是只有GET动词的HTTP请求通过该中间件，它的第一个参数是请求的路径。由于get方法的回调函数没有调用next方法，所以只要有一个中间件被调用了，后面的中间件就不会再被调用了。</p>
<p>除了get方法以外，Express还提供post、put、delete方法，即HTTP动词都是Express的方法。</p>
<p>这些方法的第一个参数，都是请求的路径。除了绝对匹配以外，Express允许模式匹配。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">"/hello/:who"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.end(<span class="string">"Hello, "</span> + req.params.who + <span class="string">"."</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码将匹配“/hello/alice”网址，网址中的alice将被捕获，作为req.params.who属性的值。需要注意的是，捕获后需要对网址进行检查，过滤不安全字符，上面的写法只是为了演示，生产中不应这样直接使用用户提供的值。</p>
<p>如果在模式参数后面加上问号，表示该参数可选。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">'/hello/:who?'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(req.params.id) &#123;</span><br><span class="line">    	res.end(<span class="string">"Hello, "</span> + req.params.who + <span class="string">"."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    	res.send(<span class="string">"Hello, Guest."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>下面是一些更复杂的模式匹配的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">'/forum/:fid/thread/:tid'</span>, middleware)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配/commits/71dbb9c</span></span><br><span class="line"><span class="comment">// 或/commits/71dbb9c..4c084f9这样的git格式的网址</span></span><br><span class="line">app.get(<span class="regexp">/^\/commits\/(\w+)(?:\.\.(\w+))?$/</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="keyword">from</span> = req.params[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">var</span> to = req.params[<span class="number">1</span>] || <span class="string">'HEAD'</span>;</span><br><span class="line">  res.send(<span class="string">'commit range '</span> + <span class="keyword">from</span> + <span class="string">'..'</span> + to);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h3 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h3><p>set方法用于指定变量的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.set(<span class="string">"views"</span>, __dirname + <span class="string">"/views"</span>);</span><br><span class="line"></span><br><span class="line">app.set(<span class="string">"view engine"</span>, <span class="string">"jade"</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码使用set方法，为系统变量“views”和“view engine”指定值。</p>
<h3 id="response对象"><a href="#response对象" class="headerlink" title="response对象"></a>response对象</h3><p><strong>（1）response.redirect方法</strong></p>
<p>response.redirect方法允许网址的重定向。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">response.redirect(<span class="string">"/hello/anime"</span>);</span><br><span class="line">response.redirect(<span class="string">"http://www.example.com"</span>);</span><br><span class="line">response.redirect(<span class="number">301</span>, <span class="string">"http://www.example.com"</span>);</span><br></pre></td></tr></table></figure>

<p><strong>（2）response.sendFile方法</strong></p>
<p>response.sendFile方法用于发送文件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">response.sendFile(<span class="string">"/path/to/anime.mp4"</span>);</span><br></pre></td></tr></table></figure>

<p><strong>（3）response.render方法</strong></p>
<p>response.render方法用于渲染网页模板。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">"/"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">  response.render(<span class="string">"index"</span>, &#123; <span class="attr">message</span>: <span class="string">"Hello World"</span> &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码使用render方法，将message变量传入index模板，渲染成HTML网页。</p>
<h3 id="requst对象"><a href="#requst对象" class="headerlink" title="requst对象"></a>requst对象</h3><p><strong>（1）request.ip</strong></p>
<p>request.ip属性用于获得HTTP请求的IP地址。</p>
<p><strong>（2）request.files</strong></p>
<p>request.files用于获取上传的文件。</p>
<h3 id="搭建HTTPs服务器"><a href="#搭建HTTPs服务器" class="headerlink" title="搭建HTTPs服务器"></a>搭建HTTPs服务器</h3><p>使用Express搭建HTTPs加密服务器，也很简单。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">  key: fs.readFileSync(<span class="string">'E:/ssl/myserver.key'</span>),</span><br><span class="line">  cert: fs.readFileSync(<span class="string">'E:/ssl/myserver.crt'</span>),</span><br><span class="line">  passphrase: <span class="string">'1234'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> https = <span class="built_in">require</span>(<span class="string">'https'</span>);</span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">  res.send(<span class="string">'Hello World Expressjs'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = https.createServer(options, app);</span><br><span class="line">server.listen(<span class="number">8084</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Server is running on port 8084'</span>);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>express</category>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>express</tag>
      </tags>
  </entry>
  <entry>
    <title>最全面的Cookie知识点总结</title>
    <url>/yinyiwang/2020/09/25/2020-09-25-%E6%9C%80%E5%85%A8%E9%9D%A2%E7%9A%84Cookie%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210301%20/20-13-36-xhQInZ.png" alt="文章架构图"></p>
<blockquote>
<p>完整阅读本文大约需要二十分钟时间，可根据文章结构图直接阅读自己需要的部分。</p>
</blockquote>
<h2 id="Cookie-产生的背景"><a href="#Cookie-产生的背景" class="headerlink" title="Cookie 产生的背景"></a>Cookie 产生的背景</h2><blockquote>
<p>所有新技术的出现都是为了解决某一痛点。 ——《前端三昧》</p>
</blockquote>
<a id="more"></a>

<p>我们都知道，<code>HTTP 协议</code>是==无状态的==，服务器无法知道两个请求是否来自同一个浏览器，也不知道用户上一次做了什么，每次请求都是完全相互独立，这严重阻碍了<code>交互式 Web</code> 应用程序的实现。例子：</p>
<ul>
<li>购物车：在典型的网上购物场景中，用户浏览了几个页面，买了一盒饼干和两瓶饮料。最后结帐时，由于 <code>HTTP</code> 的无状态性，不通过额外的手段，服务器并不知道用户到底买了什么。</li>
<li>登录状态：我们常用的“记住密码”功能，在以前如果不是用 <code>Cookie</code> 记住了登录凭据，想要实现该功能将会很复杂。</li>
</ul>
<p>正是为了解决这些交互方面存在的痛点，<code>Cookie</code> 应运而生。</p>
<h2 id="Cookie-概述"><a href="#Cookie-概述" class="headerlink" title="Cookie 概述"></a>Cookie 概述</h2><blockquote>
<p> <code>Cookie</code>（ 也叫 <code>Web Cookie</code> 或<code>浏览器  Cookie</code> ）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。</p>
</blockquote>
<p>存储 <code>Cookie</code> 是浏览器提供的功能。<code>Cookie</code>  其实是存储在浏览器中的纯文本，浏览器的安装目录下会专门有一个  <code>Cookie</code>  文件夹来存放各个域下设置的 <code>Cookie</code>（非内存 <code>Cookie</code>）。</p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210301%20/20-13-43-QsXwT5.png" alt="Cookie存放的位置"></p>
<p>通常，它用于==告知服务端两个请求是否来自同一浏览器==，或者用来==保存一些状态信息==，<code>Cookie</code>  使基于无状态的 <code>HTTP</code> 协议记录稳定的状态信息成为了可能。常用的有以下方面：</p>
<ul>
<li>对话（<code>session</code>）管理：保存登录、购物车等需要记录的信息。</li>
<li>简单的缓存：存储一些简单的业务数据，比如购物车等需要记录的信息。</li>
<li>个性化：保存用户的偏好，比如网页的字体大小、背景色等等。</li>
<li>追踪：记录和分析用户行为。</li>
</ul>
<blockquote>
<p><code>Cookie</code> 主要是用来存储状态的。</p>
</blockquote>
<p><code>Cookie</code> 曾一度用于客户端数据的存储，因当时并没有其它合适的存储办法而作为唯一的存储手段。现在来说，这样做虽然可行，但是并不推荐，因为 <code>Cookie</code> 的设计目标并不是这个，它:</p>
<ul>
<li>容量很小（ 4KB ）</li>
<li>缺乏数据操作接口</li>
<li>影响性能</li>
</ul>
<p>客户端储存应该更多的考虑使用 <code>localStorage</code> 、<code>sesseionStorage</code> 和 <code>IndexedDB</code>。</p>
<p>查看浏览器上存储的 <code>Cookie</code> 的方法如下图：</p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210301%20/20-13-47-G5egfg.png" alt="查看Cookie的步骤和方法"></p>
<p>当然，浏览器可以设置不接受 <code>Cookie</code>，也可以设置不向服务器发送 <code>Cookie</code>。<code>window.navigator.cookieEnabled</code>属性返回一个布尔值，表示浏览器是否打开 <code>Cookie</code> 功能。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 浏览器是否打开 Cookie 功能</span></span><br><span class="line"><span class="built_in">window</span>.navigator.cookieEnabled <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>本文所有的讨论都是在浏览器的 <code>window.navigator.cookieEnabled</code> 为 ==true== 的前提下进行的。</p>
</blockquote>
<h2 id="Cookie-的工作流程"><a href="#Cookie-的工作流程" class="headerlink" title="Cookie 的工作流程"></a>Cookie 的工作流程</h2><p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210301%20/20-13-51-8zf2s2.png" alt="Cookie的工作原理"></p>
<h2 id="Cookie-的限制"><a href="#Cookie-的限制" class="headerlink" title="Cookie 的限制"></a>Cookie 的限制</h2><h3 id="格式限制"><a href="#格式限制" class="headerlink" title="格式限制"></a>格式限制</h3><p><code>Cookie</code> 只能存储纯文本格式，因为：</p>
<ul>
<li>每条 <code>Cookie</code> 的大小有限制</li>
<li>为用户信息安全考虑，<code>Cookie</code> 中存储的是不可执行语句</li>
</ul>
<h3 id="大小和条数限制"><a href="#大小和条数限制" class="headerlink" title="大小和条数限制"></a>大小和条数限制</h3><p>由于 <code>Cookie</code> 是保存在客户端上的，所以浏览器加入了一些限制确保 <code>Cookie</code> 不会被恶意使用，同时不会占据太多磁盘空间，所以 <code>Cookie</code> 的数量和大小是有限的。</p>
<p>不同浏览器对 <code>Cookie</code> 数量和大小的限制，是不一样的。一般来说，单个域设置的 <code>Cookie</code> 不应超过 ==50个==，每个 Cookie 的大小不能超过 ==4KB== 。超过限制以后，<code>Cookie</code> 将被==忽略==，不会被设置。</p>
<blockquote>
<p>其限制的原因，主要在于阻止 <code>Cookie</code> 的滥用，而且 <code>Cookie</code> 会被发送到服务器端，如果数量太大的话，会严重影响请求的性能。以上这两个限制条件，就是 <code>Cookie</code> 为什么会被浏览器自动删除的原因了。</p>
</blockquote>
<h3 id="域限制"><a href="#域限制" class="headerlink" title="域限制"></a>域限制</h3><p>不可跨域读取，<code>Cookie</code> 是被哪个域写入的，就只能被这个域及其子域读取。比如：</p>
<p>由 <code>test.com</code> 写入的 <code>Cookie</code> 可以被 <code>test.com</code> 和 <code>test.com/child</code> 读取，而不能被 <code>example.com</code> 读取。</p>
<h3 id="路径限制"><a href="#路径限制" class="headerlink" title="路径限制"></a>路径限制</h3><p>存储 <code>Cookie</code> 时会指定路径，该路径的子级可以读取该 <code>Cookie</code>，但是它的父级却读取不到——==子可以读取父，但父不能拿到子==，例如：</p>
<p>由 <code>test.com/parent/child</code> 存储下的 <code>Cookie</code>，可以被 <code>test.com/parent/child/child</code> 读取，但不能被 <code>test.com/parent</code> 读取。</p>
<blockquote>
<p>一般会将 <code>Cookie</code> 存在根路径下，可以避免这种情况的发生。</p>
</blockquote>
<h3 id="时效限制"><a href="#时效限制" class="headerlink" title="时效限制"></a>时效限制</h3><p>每个 <code>Cookie</code> 都有时效性，默认的有效期是==会话级别==（ <code>Seesion Cookie</code> ）：就是当浏览器关闭，那么 <code>Cookie</code> 立即销毁，但是我们也可以在存储的时候手动设置  <code>Cookie</code> 的过期时间，具体设置方法会在下文讲到。</p>
<h2 id="Cookie-的属性"><a href="#Cookie-的属性" class="headerlink" title="Cookie 的属性"></a>Cookie 的属性</h2><p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210301%20/20-13-57-0YvIFL.png" alt="Cookie的属性"></p>
<h3 id="Name-Value"><a href="#Name-Value" class="headerlink" title="Name/Value"></a>Name/Value</h3><p>设置 <code>Cookie</code> 的名称及相对应的值，对于认证 <code>Cookie</code>，<code>Value</code> 值包括 <code>Web</code> 服务器所提供的访问令牌 。</p>
<h3 id="Domain"><a href="#Domain" class="headerlink" title="Domain"></a>Domain</h3><p>指定了可以访问该 <code>Cookie</code> 的 Web 站点或域。</p>
<p><code>Cookie</code> 机制并未遵循严格的同源策略，允许一个子域可以设置或获取其父域的 <code>Cookie</code>。</p>
<p>当需要实现单点登录方案时，<code>Cookie</code> 的上述特性非常有用，然而也增加了 <code>Cookie</code> 受攻击的危险，比如攻击者可以借此发动会话定置攻击。因而，浏览器禁止在 <code>Domain</code> 属性中设置 .org、.com 等通用顶级域名、以及在国家及地区顶级域下注册的二级域名，以减小攻击发生的范围。</p>
<h3 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h3><p><code>Path</code> 标识指定了主机下的哪些路径可以接受 <code>Cookie</code>（该 URL 路径必须存在于请求 URL 中）。以字符 <code>%x2F (&quot;/&quot;)</code>  作为路径分隔符，子路径也会被匹配。</p>
<h3 id="Expires-Max-Age"><a href="#Expires-Max-Age" class="headerlink" title="Expires/Max-Age"></a>Expires/Max-Age</h3><p>设置 <code>Cookie</code> 的生存期。有两种存储类型的 <code>Cookie</code> ：会话性与持久性。</p>
<p><code>Expires</code> 属性指定一个具体的到期时间，到了这个指定的时间之后，浏览器就不再保留这个 <code>Cookie</code> ,它的值是 UTC 格式，可以使用 <code>Date.prototype.toUTCString()</code>  格式进行转换。</p>
<p><code>Max-Age</code> 属性制定了从现在开始 <code>Cookie</code> 存在的秒数，比如 60 * 60 * 24 * 365（即一年）。过了这个时间以后，浏览器就不再保留这个 <code>Cookie</code></p>
<blockquote>
<p>如果没有设置这两个选项，则会使用默认值。 <code>domain</code> 的默认值为设置该 <code>Cookie</code> 的网页所在的域名， <code>path</code> 默认值为设置该 <code>Cookie</code> 的网页所在的目录。</p>
</blockquote>
<ul>
<li><code>Expires</code> 属性缺省时，为会话性 <code>Cookie(Session Cookie)</code> ，仅保存在客户端内存中，并在用户关闭浏览器时失效。</li>
<li>持久性 <code>Cookie</code> 会保存在用户的硬盘中，直至生存期到或用户直接在网页中单击“注销”等按钮结束会话时才会失效。</li>
</ul>
<blockquote>
<p>当 <code>Cookie</code> 的过期时间被设定时，设定的日期和时间只与客户端相关，而不是服务端。</p>
</blockquote>
<h3 id="HTTPOnly"><a href="#HTTPOnly" class="headerlink" title="HTTPOnly"></a>HTTPOnly</h3><p>这个选项用来设置 <code>Cookie</code> 是否能通过 <code>JavaScript</code> 去访问。默认情况下， <code>Cookie</code> 不会带 <code>HTTPOnly</code> 选项(即为空)，所以默认情况下，客户端是可以通过 <code>JavaScript</code> 代码去访问（包括读取、修改、删除等）这个 <code>Cookie</code> 的。当 <code>Cookie</code> 带 <code>HTTPOnly</code> 选项时，客户端则无法通过js代码去访问（包括读取、修改、删除等）这个 <code>Cookie</code> 。</p>
<p>用于防止客户端脚本通过 <code>document.cookie</code> 属性访问 <code>Cookie</code> ，有助于保护 <code>Cookie</code> 不被跨站脚本攻击窃取或篡改。但是，<code>HTTPOnly</code> 的应用仍存在局限性，一些浏览器可以阻止客户端脚本对 <code>Cookie</code> 的读操作，但允许写操作；此外大多数浏览器仍允许通过 <code>XMLHTTP</code> 对象读取 <code>HTTP</code> 响应中的 <code>Set-Cookie</code> 头  。</p>
<blockquote>
<p>在客户端是不能通过 <code>JAvaScript</code> 代码去设置一个 <code>httpOnly</code> 类型的 <code>Cookie</code> 的，这种类型的 <code>Cookie</code> 只能通过服务端来设置。</p>
</blockquote>
<h3 id="Secure"><a href="#Secure" class="headerlink" title="Secure"></a>Secure</h3><p>指定是否使用 <code>HTTPS</code> 安全协议发送 <code>Cookie</code> 。</p>
<p>使用 <code>HTTPS</code> 安全协议，可以保护 <code>Cookie</code> 在浏览器和 <code>Web</code> 服务器间的传输过程中不被窃取和篡改。该方法也可用于 <code>Web</code> 站点的身份鉴别，即在 <code>HTTPS</code> 的连接建立阶段，浏览器会检查 <code>Web</code> 网站的 <code>SSL</code> 证书的有效性。</p>
<p>但是基于兼容性的原因（比如有些网站使用自签署的证书）在检测到 <code>SSL</code> 证书无效时，浏览器并不会立即终止用户的连接请求，而是显示安全风险信息，用户仍可以选择继续访问该站点。由于许多用户缺乏安全意识，因而仍可能连接到 <code>Pharming</code> 攻击所伪造的网站 。</p>
<blockquote>
<p>如果当前协议是 HTTP，浏览器会自动忽略服务器发来的 Secure。</p>
</blockquote>
<h3 id="SameSite"><a href="#SameSite" class="headerlink" title="SameSite"></a>SameSite</h3><p><code>Cookie</code> 允许服务器要求某个 <code>Cookie</code> 在跨站请求时不会被发送，（其中 <code>Site</code> 由可注册域定义），从而可以阻止跨站请求伪造攻击（<code>CSRF</code>）。</p>
<p><code>SameSite cookies</code> 是相对较新的一个字段，所有主流浏览器都已经得到支持。下面是例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set</span>-Cookie: key=value; SameSite=Strict</span><br></pre></td></tr></table></figure>

<p><code>SameSite</code> 可以有下面三种值：</p>
<ul>
<li><strong><code>None</code></strong>。浏览器会在同站请求、跨站请求下继续发送 <code>Cookies</code>，不区分大小写。</li>
<li><strong><code>Strict</code>。</strong>浏览器将只在访问相同站点时发送 <code>Cookie</code>。（在原有 <code>Cookies</code> 的限制条件上的加强）。</li>
<li><strong><code>Lax</code>。</strong>与 <strong><code>Strict</code></strong> 类似，但用户从外部站点导航至URL时（例如通过链接）除外。 在新版本浏览器中，为默认选项，<code>Same-site cookies</code> 将会为一些跨站子请求保留，如图片加载或者 <code>frames</code> 的调用，但只有当用户从外部站点导航到 <code>URL</code> 时才会发送。如 link 链接。</li>
</ul>
<blockquote>
<p>以前，如果 <code>SameSite</code> 属性没有设置，或者没有得到运行浏览器的支持，那么它的行为等同于 <code>None</code>，<code>Cookies</code> 会被包含在任何请求中——包括跨站请求。</p>
<p>大多数主流浏览器正在将 <code>SameSite</code> 的默认值迁移至 <code>Lax</code>。如果想要指定 <code>Cookies</code> 在同站、跨站请求都被发送，现在需要明确指定 <code>SameSite</code>  为 <code>None</code>。</p>
</blockquote>
<h3 id="Cookie-prefixes"><a href="#Cookie-prefixes" class="headerlink" title="Cookie prefixes"></a>Cookie prefixes</h3><p><code>Cookie</code> 机制的使得服务器无法确认  <code>Cookie</code>  是在安全来源上设置的，甚至无法确定   <code>Cookie</code>   最初是在哪里设置的。</p>
<p>子域上的易受攻击的应用程序可以使用 <code>Domain</code> 属性设置  <code>Cookie</code>  ，从而可以访问所有其他子域上的该   <code>Cookie</code>  。会话定置攻击中可能会滥用此机制。</p>
<p>但是，作为 <code>深度防御措施</code>，可以使用 <code>Cookie</code> 前缀来断言有关  <code>Cookie</code>  的特定事实。有两个前缀可用：</p>
<ul>
<li><p><strong><code>__Host-</code></strong></p>
<p>  如果    <code>Cookie</code>  名称具有此前缀，则仅当它也用 <code>Secure</code> 属性标记，是从安全来源发送的，不包括 <code>Domain</code> 属性，并将 <code>Path</code> 属性设置为 <code>/</code> 时，它才在 <code>Set-Cookie</code> 标头中接受。这样，这些 <code>Cookie</code> 可以被视为 “<code>domain-locked</code>”。</p>
</li>
<li><p><strong><code>__Secure-</code></strong></p>
<p>  如果 <code>Cookie</code> 名称具有此前缀，则仅当它也用 <code>Secure</code> 属性标记，是从安全来源发送的，它才在 <code>Set-Cookie</code> 标头中接受。该前缀限制要弱于 <code>__Host-</code> 前缀。</p>
</li>
</ul>
<p>带有这些前缀点 <code>Cookie</code>， 如果不符合其限制的会被浏览器拒绝。请注意，这确保了如果子域要创建带有前缀的  <code>Cookie</code>，那么它将要么局限于该子域，要么被完全忽略。由于应用服务器仅在确定用户是否已通过身份验证或 CSRF 令牌正确时才检查特定的  <code>Cookie</code>  名称，因此，这有效地充当了针对会话劫持的防御措施。</p>
<p><code>Cookie</code> 各个属性的兼容性如下图所示：</p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210301%20/20-14-03-KXp4C1.png" alt="Cookie属性的兼容性"></p>
<h2 id="HTTP-Cookie-和-document-cookie"><a href="#HTTP-Cookie-和-document-cookie" class="headerlink" title="HTTP Cookie 和 document.cookie"></a>HTTP Cookie 和 document.cookie</h2><h3 id="HTTP-Cookie"><a href="#HTTP-Cookie" class="headerlink" title="HTTP Cookie"></a>HTTP Cookie</h3><p>服务器如果希望在浏览器保存 <code>Cookie</code>，就要在 <code>HTTP</code> 回应的头信息里面，放置一个<code>Set-Cookie</code>字段。</p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210301%20/20-14-08-TfXiZ0.png" alt="HTTP设置Cookie"></p>
<p>浏览器收到响应后通常会保存下 <code>Cookie</code>，之后对该服务器每一次请求中都通过  <code>Cookie</code> 请求头部将 <code>Cookie</code> 信息发送给服务器。另外，<code>Cookie</code> 的过期时间、域、路径、有效期、适用站点都可以根据需要来指定。</p>
<p><code>HTTP</code> 回应可以包含多个 <code>Set-Cookie</code> 字段，即在浏览器生成多个 <code>Cookie</code>。下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">HTTP/<span class="number">1.0</span> <span class="number">200</span> OK</span><br><span class="line">Content-type: text/html</span><br><span class="line"><span class="built_in">Set</span>-Cookie: yummy_cookie=choco</span><br><span class="line"><span class="built_in">Set</span>-Cookie: tasty_cookie=strawberry</span><br><span class="line"></span><br><span class="line">[page content]</span><br></pre></td></tr></table></figure>

<p>除了 <code>Cookie</code> 的值，<code>Set-Cookie</code>字段还可以附加 <code>Cookie</code> 的属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set</span>-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Expires=&lt;date&gt;</span><br><span class="line">Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Max-Age=&lt;non-zero-digit&gt;</span><br><span class="line">Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Domain=&lt;domain-value&gt;</span><br><span class="line">Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Path=&lt;path-value&gt;</span><br><span class="line">Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; Secure</span><br><span class="line">Set-Cookie: &lt;cookie-name&gt;=&lt;cookie-value&gt;; HttpOnly</span><br></pre></td></tr></table></figure>

<p>一个 <code>Set-Cookie</code> 字段里面，可以同时包括多个属性，没有次序的要求。</p>
<blockquote>
<p>如果服务器想改变一个早先设置的 <code>Cookie</code>，必须同时满足四个条件：<code>Cookie</code> 的 <code>key</code>、<code>domain</code>、<code>path</code> 和 <code>secure</code> 都匹配。否则，会创建一个新的 <code>Cookie</code>。</p>
</blockquote>
<p>浏览器接收了响应头提供的 <code>Cookie</code> 之后，每一次访问该域时，都会携带该 <code>Cookie</code> 值：</p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210301%20/20-14-13-gx8jqV.png" alt="HTTP的请求头中携带Cookie"></p>
<p><code>Cookie</code> 字段可以包含多个 Cookie，使用分号（<code>;</code>）分隔。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">GET /sample_page.html HTTP/<span class="number">1.1</span></span><br><span class="line">Host: www.example.org</span><br><span class="line">Cookie: yummy_cookie=choco; tasty_cookie=strawberry</span><br></pre></td></tr></table></figure>

<h3 id="document-cookie"><a href="#document-cookie" class="headerlink" title="document.cookie"></a>document.cookie</h3><p>通过 <code>document.cookie</code> 属性可创建新的 <code>Cookie</code>，也可通过该属性访问==非 HttpOnly== 标记的 <code>Cookie</code>。</p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210301%20/20-14-16-yFjJPU.png" alt="Document获取Cookie"></p>
<p>上图从 <code>document.cookie</code> 一次性读出多个 <code>Cookie</code>，它们之间使用分号分隔。必须手动还原，才能取出每一个 <code>Cookie</code> 的值。</p>
<p>写入的时候，<code>Cookie</code> 的值必须写成 <code>key=value</code> 的形式。注意，等号两边不能有空格。另外，写入 <code>Cookie</code> 的时候，必须对分号、逗号和空格进行转义（它们都不允许作为 <code>Cookie</code> 的值），这可以用 <code>encodeURIComponent</code> 方法达到。比如，我们要存储一个对象到 <code>Cookie</code>中，可以通过下面代码实现：</p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210301%20/20-14-21-ahuObS.png" alt="document.cookie设置"></p>
<p>设置完成后，在浏览器查看：</p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210301%20/20-14-26-SjLqFk.png" alt="查看设置的Cookie"></p>
<p>那要怎么才能读取到这次设置的 <code>Cookie</code> 呢？方法如下：</p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210301%20/20-14-29-03gnBu.png" alt="读取设置的cookie_people"></p>
<p>读取到的结果如下：</p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210301%20/20-14-32-oXvzsY.png" alt="读取设置的cookie"></p>
<blockquote>
<p><code>document.cookie</code> 一次只能写入一个 <code>Cookie</code>，而且写入并不是覆盖，而是添加。</p>
</blockquote>
<h2 id="Cookie-的安全隐患"><a href="#Cookie-的安全隐患" class="headerlink" title="Cookie 的安全隐患"></a>Cookie 的安全隐患</h2><blockquote>
<p>信息被存在 <code>Cookie</code> 中时，需要明白 <code>Cookie</code> 的值时可以被访问，且可以被终端用户所修改的。根据应用程序的不同，可能需要使用服务器查找的不透明标识符，或者研究诸如 <code>JSON Web Tokens</code> 之类的替代身份验证/机密机制。</p>
<p>当机器处于不安全环境时，切记<em>不能</em>通过 <code>HTTP Cookie</code> 存储、传输敏感信息。</p>
</blockquote>
<h3 id="Cookie-捕获-重放"><a href="#Cookie-捕获-重放" class="headerlink" title="Cookie 捕获/重放"></a>Cookie 捕获/重放</h3><p>攻击者可以通过木马等恶意程序，或使用跨站脚本攻击等手段偷窃存放在用户硬盘或内存中的 <code>Cookie</code>。借助网络攻击手段，包括：</p>
<ul>
<li>在不安全的局域网中被动地监听网络通信；</li>
<li>通过攻击网络用户的路由器，或通过搭建恶意的无线路由器等手法，控制路由基础设施，将网络流量重定向到攻击者控制的主机；</li>
<li>发动 <code>DNSPharming</code> (域欺骗)攻击，通过 <code>DNS 缓存中毒</code>、<code>DNS 应答欺骗</code>、或修改用户端的本地域名解析文件等方法攻击 <code>DNS</code> 系统，导致用户对合法网站的访问请求被重定向到恶意网站等等，同样可能窃取 <code>Cookie</code>。</li>
</ul>
<p>对于捕获到的认证 <code>Cookie</code>，攻击者往往会猜测其中的访问令牌，试图获取会话ID、用户名与口令、用户角色、时间戳等敏感信息；或者直接重放该 <code>Cookie</code>，假冒受害者的身份发动攻击  。</p>
<h3 id="恶意-Cookies"><a href="#恶意-Cookies" class="headerlink" title="恶意 Cookies"></a>恶意 Cookies</h3><p><code>Cookies</code> 是文本文件， 一般情况下认为它不会造成安全威胁。 但是，如果在 <code>Cookies</code> 中通过特殊标记语言，引入可执行代码，就很可能给用户造成严重的安全隐患。<code>HTML</code> 为区别普通文本和标记语言，用符号 <code>“&lt;&gt;”</code> 来指示 <code>HTML</code> 代码。 这些 <code>HTML</code> 代码或者定义 <code>Web</code> 网页格式，或者引入 <code>Web</code> 浏览器可执行代码段。 <code>Web</code> 服务 器可以使用 <code>Cookies</code> 信息创建动态网页。假使 <code>Cookies</code> 包含可执行恶意代码段，那么在显示合成有该 <code>Cookies</code> 的网页时，就会自动执行这段恶意代码。当然，恶意代码能否真正造成危害，还取决于 <code>Web</code> 站点的安全配置策略 。</p>
<h3 id="会话定置"><a href="#会话定置" class="headerlink" title="会话定置"></a>会话定置</h3><p>会话定置(<code>Session Fixation</code>)攻击是指，攻击者向受害者主机注入自己控制的认证 <code>Cookie</code> 等信息，使得受害者以攻击者的身份登录网站，从而窃取受害者的会话信息。</p>
<p>注入 <code>Cookie</code> 的方法包括：</p>
<ul>
<li>使用跨站脚本或木马等恶意程序；</li>
<li>或伪造与合法网站同域的站点，并利用各种方法欺骗用户访问该仿冒网站，从而通过HTTP响应中的Set-Cookie头将攻击者拥有的该域Cookie发送给用户等。</li>
</ul>
<h3 id="CSRF-攻击"><a href="#CSRF-攻击" class="headerlink" title="CSRF 攻击"></a>CSRF 攻击</h3><p>跨站请求伪造（<code>Cross-Site Request Forgery</code>，简称<code>CSRF</code>）是指：</p>
<p>攻击者可能利用网页中的恶意代码强迫受害者浏览器向被攻击的 <code>Web</code> 站点发送伪造的请求，篡夺受害者的认证 <code>Cookie</code> 等身份信息，从而假冒受害者对目标站点执行指定的操作。</p>
<p>Firefox、Opera 等浏览器使用单进程机制，多个窗口或标签使用同一个进程，共享 <code>Cookie</code> 等会话数据。IE 则混合使用单进程与多进程模式，一个窗口中的多个标签，以及使用 “CTRL+N”  或单击网页中的链接打开的新窗口使用同一进程，共享会话数据；只有直接运行IE可执行程序打开窗口时，才会创建新的进程。Chrome 虽然使用多进程机制，然而经测试发现，其不同的窗口或标签之间仍会共享会话数据，除非使用隐身访问方式。</p>
<p>因而，用户同时打开多个浏览器窗口或标签访问互联网资源时，就为 <code>CSRF</code> 攻击篡夺用户的会话 <code>Cookie</code> 创造了条件。另外，如果一个Web 站点提供持久化 <code>Cookie</code>，则 <code>CSRF</code> 攻击将更直接、更容易。</p>
<blockquote>
<p>缓解 Cookie 攻击的方法如下：</p>
<ul>
<li>对用户输入进行过滤来阻止 XSS；</li>
<li>任何敏感操作都需要确认；</li>
<li>用于敏感信息的 Cookie 只能拥有较短的生命周期；</li>
</ul>
</blockquote>
<h2 id="安全使用-Cookie"><a href="#安全使用-Cookie" class="headerlink" title="安全使用 Cookie"></a>安全使用 Cookie</h2><p>有两种方法可以确保 <code>Cookie</code> 被安全发送，并且不会被意外的参与者或脚本访问：<code>Secure</code> 属性和 <code>HttpOnly</code> 属性。</p>
<p>标记为 <code>Secure</code> 的 <code>Cookie</code> 只应通过被 <code>HTTPS</code> 协议加密过的请求发送给服务端，因此可以预防 <code>man-in-the-middle</code> 攻击者的攻击。但即便设置了 <code>Secure</code> 标记，敏感信息也不应该通过 <code>Cookie</code> 传输，因为 <code>Cookie</code> 有其固有的不安全性，<code>Secure</code> 标记也无法提供确实的安全保障, 例如，可以访问客户端硬盘的人可以读取它。</p>
<p><code>JavaScript Document.cookie API</code> 无法访问带有 <code>HttpOnly</code> 属性的 <code>Cookie</code>；此类 <code>Cookie</code> 仅作用于服务器。例如，例如，持久化服务器端会话的 <code>Cookie</code> 不需要对 <code>JavaScript</code> 可用，而应具有 <code>HttpOnly</code> 属性。此预防措施有助于缓解跨站点脚本（<code>XSS</code>）攻击。</p>
<h2 id="Cookie-的替代方案"><a href="#Cookie-的替代方案" class="headerlink" title="Cookie 的替代方案"></a>Cookie 的替代方案</h2><p>由于 <code>Cookie</code>  在使用上存在较多限制，近年来，随着技术的发展成熟，出现了几种可替代 <code>Cookie</code> 的方案，且已被大多数主流浏览器支持。</p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210301%20/20-14-37-nGt5Fy.png" alt="Cookie的替代方案"></p>
<ul>
<li><strong>Web Storage、window.localStorage</strong> </li>
</ul>
<p>在浏览器中存储数据的另一种方法是 ==Web Storage API==。<code>window.sessionStorage</code> 和 <code>window.localStorage</code> 属性与持续时间中的会话和永久 <code>Cookie</code> 相对应，但是存储限制比 <code>Cookie</code>大，并且永远不会发送到服务器。</p>
<ul>
<li><strong>IndexedDB</strong></li>
</ul>
<p>可以使用 <code>IndexedDB API</code> 或基于它构建的库来存储更多结构化的数据。</p>
<ul>
<li><strong>Web SQL</strong></li>
</ul>
<p><code>Web SQL</code> 是一种利用数据库进行数据存储并利用 SQL 处理检索任务的 API。</p>
<hr>
<blockquote>
<p>欢迎大家来到我的「山头」，我是「前端三昧」的作者 <em>隐逸王</em>  ——  一个想要做山大王的男人！</p>
<p>愿和你一起领略前端三昧，发现前端之美！</p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Cookie</category>
      </categories>
      <tags>
        <tag>Cookie</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK安装说明及环境变量的配置</title>
    <url>/yinyiwang/2021/02/22/2021-02-22-JDK%E5%AE%89%E8%A3%85%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h2 id="JDK简介"><a href="#JDK简介" class="headerlink" title="JDK简介"></a>JDK简介</h2><p>JDK  —— Java Development ToolKit (Java 开发工具包)。JDK 是整个 Java 的核心，包括了 Java 运行环境（Java Runtime Envirnment），一堆 Java 工具（ javac/java/jdb 等）和 Java 基础的类库（即 Java API 包括 rt.jar）。</p>
<a id="more"></a>

<p>最主流的 JDK 是Sun公司发布的 JDK，除了 Sun 之外，还有很多公司和组织都开发了属于自己的 JDK，例如国外 IBM 公司开发了属于自己的 JDK，国内淘宝也开发了属于自己的 JDK，各个组织开发自己的 JDK 都是为了在某些方面得到一些提高，以适应自己的需求，比如 IBM 的 JDK 据说运行效率就比 SUN 的 JDK 高的多。但不管怎么说，我们还是需要先把基础的 Sun JDK 掌握好。</p>
<p>JDK 是 Java 开发工具包，在其安装目录下面有六个文件夹、一些描述文件、一个 src 压缩文件。bin、include、lib、 jre 这四个文件夹起作用，demo、sample 是一些例子。可以看出来 JDK 包含 JRE，而 JRE 包含 JVM。</p>
<ul>
<li>bin：最主要的是编译器(javac.exe)</li>
<li>include：java 和 JVM 交互用的头文件</li>
<li>lib：类库</li>
<li>jre：java运行环境（注意：这里的 bin、lib 文件夹和 jre 里的 bin、lib 是不同的）</li>
</ul>
<p>总的来说 JDK 是用于 Java 程序的开发,而 jre 则是只能运行 class 而没有编译的功能。 </p>
<p>JDK 是提供给 Java 开发人员使用的，其中包含了 Java 的开发工具，也包括了 JRE。所以安装了 JDK，就不用在单独安装 JRE了。 其中的开发工具包括编译工具 ( javac.exe ) 打包工具 ( jar.exe ) 等</p>
<p>在 JDK 的安装目录下有一个 jre 目录，里面有两个文件夹 bin 和 lib，在这里可以认为 bin 里的就是 jvm，lib 中则是 jvm 工作所需要的类库，而 jvm 和 lib 合起来就称为 jre。</p>
<h2 id="JDK的安装"><a href="#JDK的安装" class="headerlink" title="JDK的安装"></a>JDK的安装</h2><p>访问 <a href="https://www.oracle.com/java/technologies/javase-downloads.html" target="_blank" rel="noopener">Oracle官网</a>，找到最新版本的 JDK 进行下载</p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210301%20/20-11-01-1nSTQ5.png" alt="Oracle官网"></p>
<h2 id="关于环境变量（Environment-Variable）"><a href="#关于环境变量（Environment-Variable）" class="headerlink" title="关于环境变量（Environment Variable）"></a>关于环境变量（<em>Environment Variable</em>）</h2><ul>
<li><p>变量</p>
<p>  就是可以随意给其赋值的一个存储单元。</p>
</li>
<li><p>环境</p>
<p>  如果把操作系统当做是一个最大的软件，其它软件如Office、JVM、LOL等等都是运行在这个软件之内的小软件。那么，相对于这些小软件来说，它们所处的「环境」就是操作系统这个软件。</p>
</li>
<li><p>合起来就是“环境中的变量”</p>
<p>  「环境变量」就是操作系统这个软件中的变量，即：操作系统提供给你的<strong>全局变量</strong>！</p>
</li>
<li><p>环境变量的作用</p>
<p>  环境变量在任何程序中的作用都是“被赋值/被取值”！这个全局变量操作系统可以使用，其内的小软件也可以使用！</p>
</li>
</ul>
<h2 id="Java中的环境变量"><a href="#Java中的环境变量" class="headerlink" title="Java中的环境变量"></a>Java中的环境变量</h2><blockquote>
<p>环境变量大体上是给操作系统的直接上层程序用的。比如Linux中的<code>shell</code>、<code>.sh</code>文件；Windows中的<code>cmd</code>、<code>.bat</code>文件。</p>
</blockquote>
<p><strong>常见的Java相关环境变量及其作用</strong></p>
<ol>
<li><p><code>PATH</code></p>
<p> <code>PATH</code>是操作系统用的，用来指定操作系统需要使用到的可执行程序的位置。</p>
<p> 对于Java来说，通常需要把 JDK 的 bin 目录添加进入<code>PATH</code>中，这样你就可以在任意目录下使用 bin 下面的可执行程序，如<code>javac.exe</code>、<code>java.exe</code>等。</p>
<p> <strong>这个变量一定要保证将 JRE/JDK 的 bin 纳入其中</strong>（这里我说的其实不严谨，你可以把<code>javaw.exe</code>等这类文件复制一份放到任意一个<code>PATH</code>路径下，不一定是JRE/JDK也行）<strong>，这样很多Java程序才能启动，比如<code>Eclipse</code>。</strong></p>
</li>
<li><p><code>JAVA_HOME</code></p>
<p> <code>JAVA_HOME</code>是一个约定，通常它指的是JDK的目录。如果需要JDK的话，大部分程序会默认去环境变量中取<code>JAVA_HOME</code>这个变量。</p>
<blockquote>
<p>例如，Tomcat的<code>.bat/.sh</code>文件中就会默认去取<code>JAVA_HOME</code>来用。</p>
</blockquote>
<p> <strong>所以，这个变量最需要设置。设置它，可保你万无一失，一生平安……</strong></p>
</li>
<li><p><code>JRE_HOME</code></p>
<p> 同样，这也是一个约定的变量，通常指JRE目录。其实大部分Java程序不需要JDK，而是只需要其子集JRE，所以很多程序也会去取这个变量来用。</p>
<p> 例如，Tomcat中某些<code>.bat</code>文件中这样说到：</p>
 <figure class="highlight bat"><table><tr><td class="code"><pre><span class="line"><span class="comment">rem   JAVA_HOME       Must point at your Java Development Kit installation.</span></span><br><span class="line"><span class="comment">rem                   Using JRE_HOME instead works as well.</span></span><br><span class="line"><span class="comment">rem</span></span><br><span class="line"><span class="comment">rem   JRE_HOME        Must point at your Java Runtime installation.</span></span><br><span class="line"><span class="comment">rem                   Defaults to JAVA_HOME if empty. If JRE_HOME and JAVA_HOME</span></span><br><span class="line"><span class="comment">rem                   are both set, JRE_HOME is used.123456</span></span><br></pre></td></tr></table></figure>

<p> 大意是说：Tomcat去取这俩变量，只要任意一个不为空就行，都不为空就用JRE_HOME了。因为Tomcat不需要JDK中的工具，它只是运行Java程序而已。</p>
<p> <strong>这个变量如果你明确知道应用程序只需要设置这个就行（比如上面Tomcat的注释），那么它可以代替JAVA_HOME，且最好就用这个。</strong></p>
</li>
<li><p><code>CLASSPATH</code></p>
<p> <code>CLASSPATH</code>是约定的一个可以设置我们自己的<code>.class, jar</code>文件所在目录的变量。不过某个Java程序可以自己决定取与不取这个变量。Tomcat 在某些情况下会去取，你自己的 Java 程序你不设置就会忽略它的。</p>
<p> 这和Java可执行程序：<code>java.exe</code>的可选配置<code>-cp/-classpath</code>不是一个东西，仅是用意相似：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java [-options] class [args...]</span><br><span class="line">       (执行类)</span><br><span class="line">或  java [-options] -jar jarfile [args...]</span><br><span class="line">       (执行 jar 文件)</span><br><span class="line">其中选项包括:</span><br><span class="line">-cp &lt;目录和 zip&#x2F;jar 文件的类搜索路径&gt;</span><br><span class="line">-classpath &lt;目录和 zip&#x2F;jar 文件的类搜索路径&gt;</span><br><span class="line">              用 : 分隔的目录, JAR 档案</span><br><span class="line">              和 ZIP 档案列表, 用于搜索类文件。123456789</span><br></pre></td></tr></table></figure>

<p> 结论：基本上，你不需要它。</p>
</li>
<li><p><code>CATALINA_HOME</code></p>
<p> 这是Tomcat用的。叫CATALINA这个名字我估计是因为Tomcat默认服务（也就<code>&lt;Service&gt;&lt;/Service&gt;</code>标签）的名字就是CATALINA。当然，是不是其实不重要，毕竟变量的名字可以随意起（但最好见名知意），重要的是它存什么值。它的值代表当前tomat根目录，比如：<code>E:\apache-tomcat-7.0.55</code>。</p>
<p> <strong>这个变量，仅当你移动了<code>.bat/.sh</code>等用来启动Tomcat的文件（就是不在原来的<code>tomcat\bin</code>下面了）时才需要指定。</strong>比如，在Linux中你将<code>catalina.sh</code>复制到<code>/etc/rc.d/init.d/</code>下做自启动服务时就需要设置一下。</p>
</li>
</ol>
<p><strong>Java代码中也有API能获取环境变量：</strong></p>
<ul>
<li><p>获取并打印</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打印单个环境变量</span></span><br><span class="line"><span class="keyword">final</span> String env = System.getenv(<span class="string">"PATH"</span>);</span><br><span class="line">System.out.println(env);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印所有环境变量</span></span><br><span class="line"><span class="keyword">final</span> Map&lt;String, String&gt; envMap = System.getenv();</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, String&gt; env : envMap.entrySet()) &#123;</span><br><span class="line">    System.out.println(env.getKey() + <span class="string">"="</span> + env.getValue());</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>最后我们总结一下：</p>
<ol>
<li><p><strong>需要</strong>在操作系统下设置的变量：</p>
<ol>
<li><code>PATH</code>中包含JRE/JDK的<code>bin</code>目录。</li>
<li><code>JAVA_HOME</code>或者<code>JRE_HOME</code>。都设也可以，偷懒就只设 <code>JAVA_HOME</code>就可以。</li>
</ol>
</li>
<li><p><strong>很少</strong>需要设置的：</p>
<p> <code>CLASSPATH</code>、<code>CATALINA_HOME</code>。</p>
</li>
</ol>
<h2 id="window-下-JDK-环境变量的设置"><a href="#window-下-JDK-环境变量的设置" class="headerlink" title="window 下 JDK 环境变量的设置"></a>window 下 JDK 环境变量的设置</h2><ol>
<li>安装完成后，右击”我的电脑”，点击”属性”，选择”高级系统设置”；</li>
</ol>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210301%20/20-11-10-Jpnbtp.png" alt="img"></p>
<ol start="2">
<li>选择”高级”选项卡，点击”环境变量”；</li>
</ol>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210301%20/20-11-13-0ySx99.png" alt="img"></p>
<ol start="3">
<li>然后就会出现如下图所示的画面：</li>
</ol>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210301%20/20-11-19-T61m05.png" alt="img"></p>
<p>在 “系统变量” 中设置 3 项属性，JAVA_HOME、PATH、CLASSPATH (大小写无所谓),若已存在则点击”编辑”，不存在则点击”新建”。</p>
<blockquote>
<p><strong>注意：</strong>如果使用 1.5 以上版本的 JDK，不用设置 CLASSPATH 环境变量，也可以正常编译和运行 Java 程序。</p>
</blockquote>
<p>变量设置参数如下：</p>
<ul>
<li><p>变量名：<strong>JAVA_HOME</strong></p>
</li>
<li><p>变量值：<strong>C:\Program Files (x86)\Java\jdk1.8.0_91</strong>     // 要根据自己的实际路径配置</p>
</li>
<li><p>变量名：<strong>CLASSPATH</strong></p>
</li>
<li><p>变量值：<strong>.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;</strong>     //记得前面有个”.”</p>
</li>
<li><p>变量名：<strong>Path</strong></p>
</li>
<li><p>变量值：<strong>%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;</strong></p>
</li>
</ul>
<h4 id="JAVA-HOME-设置"><a href="#JAVA-HOME-设置" class="headerlink" title="JAVA_HOME 设置"></a>JAVA_HOME 设置</h4><p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210301%20/20-11-26-ldAxvZ.png" alt="img"></p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210301%20/20-11-32-DkpB9w.png" alt="img"></p>
<h4 id="PATH设置"><a href="#PATH设置" class="headerlink" title="PATH设置"></a>PATH设置</h4><p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210301%20/20-11-38-bGLZmu.png" alt="img"></p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210301%20/20-11-42-BegabF.png" alt="img"></p>
<blockquote>
<p><strong>注意：</strong>在 Windows10 中，Path 变量里是分条显示的，我们需要将 <strong>%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;</strong> 分开添加，否则无法识别：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%JAVA_HOME%\bin;</span><br><span class="line">%JAVA_HOME%\jre\bin;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210301%20/20-11-46-yZ0XlB.png" alt="img"></p>
<p>更多内容可参考：<a href="https://www.runoob.com/w3cnote/windows10-java-setup.html" target="_blank" rel="noopener">Windows 10 配置Java 环境变量</a></p>
</blockquote>
<h4 id="CLASSPATH-设置"><a href="#CLASSPATH-设置" class="headerlink" title="CLASSPATH 设置"></a>CLASSPATH 设置</h4><p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210301%20/20-11-51-dipATw.png" alt="img"></p>
<p>这是 Java 的环境配置，配置完成后，你可以启动 Eclipse 来编写代码，它会自动完成java环境的配置。</p>
<h4 id="测试JDK是否安装成功"><a href="#测试JDK是否安装成功" class="headerlink" title="测试JDK是否安装成功"></a>测试JDK是否安装成功</h4><p>1、”开始”-&gt;”运行”，键入”cmd”；</p>
<p>2、键入命令: <strong>java -version</strong>、<strong>java</strong>、<strong>javac</strong> 几个命令，出现以下信息，说明环境变量配置成功；</p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210301%20/20-11-55-f9iw18.png" alt="img"></p>
<h2 id="MACOS-下设置-JDK-环境变量"><a href="#MACOS-下设置-JDK-环境变量" class="headerlink" title="MACOS 下设置 JDK 环境变量"></a>MACOS 下设置 JDK 环境变量</h2><ol>
<li><p>打开终端，输入：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">open -e .bash_profile</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置一个<code>JAVA_HOME</code>的环境变量，它指向JDK的安装目录。在打开的 .bash_profile 中添加：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=`/Library/Java/JavaVirtualMachines/jdk-15.0.2.jdk/Contents/Home`</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：在 Mac 上，JDK 的路径和 window 上不同</p>
</blockquote>
</li>
<li><p>设置 <code>PATH</code> 环境变量，把<code>JAVA_HOME</code>的<code>bin</code>目录附加到系统环境变量<code>PATH</code>上。在打开的 .bash_profile 中添加：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>

<p> 把<code>JAVA_HOME</code>的<code>bin</code>目录添加到<code>PATH</code>中是为了在任意文件夹下都可以运行<code>java</code>。</p>
</li>
<li><p>最后，保存 .bash_profile 文件，在终端输入：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> .bash_profile</span><br></pre></td></tr></table></figure>

<p> 打开终端，输入命令<code>java -version</code>，如果一切正常，你会看到如下输出:</p>
<p> <img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210301%20/20-12-00-9U4yuc.png" alt="iShot2021-02-23 09.31.21"></p>
</li>
</ol>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>细心的童鞋还可以在<code>JAVA_HOME</code>的<code>bin</code>目录下找到很多可执行文件：</p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210301%20/20-12-06-t5xLhz.png" alt="iShot2021-02-23 09.33.34"></p>
<ul>
<li>java：这个可执行程序其实就是JVM，运行Java程序，就是启动JVM，然后让JVM执行指定的编译后的代码；</li>
<li>javac：这是Java的编译器，它用于把Java源码文件（以<code>.java</code>后缀结尾）编译为Java字节码文件（以<code>.class</code>后缀结尾）；</li>
<li>jar：用于把一组<code>.class</code>文件打包成一个<code>.jar</code>文件，便于发布；</li>
<li>javadoc：用于从Java源码中自动提取注释并生成文档；</li>
<li>jdb：Java调试器，用于开发阶段的运行调试。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JDK</tag>
        <tag>Java</tag>
        <tag>环境变量</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJS系列——揭开require方法的面纱</title>
    <url>/yinyiwang/2020/11/21/2020-11-21-NodeJS%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E6%8F%AD%E5%BC%80require%E6%96%B9%E6%B3%95%E7%9A%84%E9%9D%A2%E7%BA%B1/</url>
    <content><![CDATA[<p>在 <code>NodeJS</code> 中有一个方法是我们使用频率最高的，那就是 <code>require</code> 方法。<code>NodeJs</code> 遵循 CommonJS 规范，该规范的核心是通过 require来加载其他依赖的模块。</p>
<p>但是，熟归熟，用归用，其中的原理是什么呢？今天就带大家揭开require的面纱，一睹真容。</p>
<a id="more"></a>

<h2 id="几个问题"><a href="#几个问题" class="headerlink" title="几个问题"></a>几个问题</h2><ol>
<li><p>module.exports 或者 exports 是全局变量吗？</p>
</li>
<li><p>模块的加载是同步还是异步？</p>
</li>
<li><p>循环引用会不会产生性能问题或者导致错误？</p>
</li>
</ol>
<h2 id="什么是-CommonJS"><a href="#什么是-CommonJS" class="headerlink" title="什么是 CommonJS"></a>什么是 CommonJS</h2><p>每一个文件就是一个模块，拥有自己独立的作用域，变量，以及方法等，对其他的模块都不可见。<code>CommonJS</code> 规范规定，每个模块内部，<code>module</code>  变量代表当前模块。这个变量是一个对象，它的 <code>exports</code> 属性（即<code>module.exports</code>）是对外的接口。</p>
<h2 id="Node-模块的分类"><a href="#Node-模块的分类" class="headerlink" title="Node 模块的分类"></a>Node 模块的分类</h2><ol>
<li><strong>build-in modules</strong> —— Nodejs 中以 C++ 形式提供的模块。</li>
<li><strong>constant module</strong> —— Nodejs 中定义常量的模块。</li>
<li><strong>native module</strong> —— Nodejs 中以 javascript 形式提供的模块。</li>
<li><strong>第三方module</strong> —— 由第三方提供的模块。</li>
</ol>
<h2 id="module-对象"><a href="#module-对象" class="headerlink" title="module 对象"></a>module 对象</h2><p>NodeJs 内部提供一个<code>Module</code>构建函数。所有模块都是<code>Module</code>的实例。</p>
<p>每个模块内部，都有一个<code>module</code>对象，代表当前模块。它有以下属性。</p>
<ol>
<li><p>module 对象的属性</p>
<ul>
<li><code>module.id</code> 模块的识别符，通常是带有绝对路径的模块文件名。</li>
<li><code>module.filename</code> 模块的文件名，带有绝对路径。</li>
<li><code>module.loaded</code> 返回一个布尔值，表示模块是否已经完成加载。</li>
<li><code>module.parent</code> 返回一个对象，表示调用该模块的模块（程序入口文件的module.parent为null）</li>
<li><code>module.children</code> 返回一个数组，表示该模块要用到的其他模块。</li>
<li><code>module.exports</code> 表示模块对外输出的值。</li>
</ul>
</li>
<li><p>module.exports 属性</p>
<p> <code>module.exports</code>属性表示当前模块对外输出的接口，其他文件加载该模块，实际上就是读取<code>module.exports</code>变量。<code>module.exports</code>属性表示当前模块对外输出的接口，其他文件加载该模块，实际上就是读取<code>module.exports</code>变量。</p>
</li>
<li><p>exports变量</p>
<p> 我们有时候会这么写：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(test);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span>.test = test;</span><br><span class="line"></span><br><span class="line"><span class="comment">// result.js</span></span><br><span class="line"><span class="keyword">const</span> test = <span class="built_in">require</span>(<span class="string">"./test"</span>)</span><br></pre></td></tr></table></figure>

<p> 这样也可以拿到正确的结果，这是因为：exports 变量指向 module.exports。这等同在每个模块头部，有一行这样的命令。</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> exports = <span class="built_in">module</span>.exports;</span><br></pre></td></tr></table></figure>

<p> 注意：不能直接给 <code>exports</code> 变量赋值，这样会改变 <code>exports</code> 的指向，不再指向 module.exports。在其他模块使用 <code>require</code> 方法是拿不到赋给 <code>exports</code> 的值的，因为  ==<em>require 方法获取的是其他模块的 module.exports 的值</em>==。</p>
<p> 建议：尽可能的使用 <strong>module.exports</strong> 来导出结果。</p>
</li>
</ol>
<h2 id="模块的流程"><a href="#模块的流程" class="headerlink" title="模块的流程"></a>模块的流程</h2><ul>
<li>创建模块</li>
<li>导出模块</li>
<li>加载模块</li>
<li>使用模块</li>
</ul>
<h2 id="require-方法"><a href="#require-方法" class="headerlink" title="require 方法"></a>require 方法</h2><blockquote>
<p>require 是 node 用来加载并执行其它文件导出的模块的方法。</p>
<p>在 NodeJs 中，我们引入的任何一个模块都对应一个 Module 实例，包括入口文件。</p>
</blockquote>
<p>完整步骤：</p>
<ol>
<li><p>调用父模块的 <code>require</code> 方法（父模块是指调用模块的当前模块）</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span> = <span class="function"><span class="keyword">function</span> <span class="title">require</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> mod.require(path);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用 Module 的 <code>_load</code> 方法</p>
</li>
<li><p>通过 <code>Module._resolveFilename</code> 获取模块的路径fileName</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> filename = Module._resolveFilename(request, parent, isMain);</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据 fileName 判断是否存在该模块的缓存</p>
<ul>
<li>如果存在缓存，则调用 <code>updateChildren</code> 方法在更新缓存内容，==并返回缓存==</li>
<li>如果不存在缓存，则继续执行</li>
</ul>
</li>
<li><p>当做原生模块，调用 <code>loadNativeModule</code> 方法进行加载</p>
<ul>
<li>如果加载成功，则==返回==该原生模块</li>
<li>否则，继续执行</li>
</ul>
</li>
<li><p>根据当前模块名（路径）和父模块对象生成一个Module实例：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">module</span> = cachedModule || <span class="keyword">new</span> Module(filename, parent);</span><br></pre></td></tr></table></figure>
</li>
<li><p>再判断该模块是否是入口文件</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (isMain) &#123;</span><br><span class="line">    process.mainModule = <span class="built_in">module</span>;</span><br><span class="line">    <span class="built_in">module</span>.id = <span class="string">'.'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将该模块的实例存入到 Module 的缓存中</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Module._cache[filename] = <span class="built_in">module</span>;</span><br></pre></td></tr></table></figure>

<p> <img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210103%20/18-38-57-PgWQrw.png" alt="image-20210103183848388"></p>
</li>
<li><p>该模块的实例调用自身的 <code>load</code> 方法，根据 fileName 加载模块</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.load(filename);</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取该模块文件的后缀名称</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> extension = findLongestRegisteredExtension(filename);</span><br></pre></td></tr></table></figure>

<p>如果后缀名称是ES Module格式的（.mjs），则判断Module是否支持.mjs文件的解析，如果不支持，则==抛出异常==。</p>
</li>
<li><p>根据后缀名称解析模块文件内容</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Module._extensions[extension](<span class="keyword">this</span>, filename);</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据fileName读取文件内容</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">content = fs.readFileSync(filename, <span class="string">'utf8'</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译并执行读取到的文件，调用 module 自身的 <code>_complile</code> 方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>._compile(content, filename);</span><br></pre></td></tr></table></figure>

<p><code>_compile</code> 主要内容步骤：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> compiledWrapper = wrapSafe(filename, content, <span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">const</span> dirname = path.dirname(filename);</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">require</span> = makeRequireFunction(<span class="keyword">this</span>, redirects);</span><br><span class="line"><span class="keyword">let</span> result;</span><br><span class="line"><span class="keyword">const</span> exports = <span class="keyword">this</span>.exports;</span><br><span class="line"><span class="keyword">const</span> thisValue = exports;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">module</span> = <span class="keyword">this</span>;</span><br><span class="line">result = compiledWrapper.call(thisValue, exports, <span class="built_in">require</span>, <span class="built_in">module</span>, filename, dirname);</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>

<p><code>wrapSafe</code> 方法的返回值</p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210104%20/09-59-59-3Pe3jG.png" alt="image-20210104095957580"></p>
<p>具体获得上图结果的代码是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = Module.wrap(content);</span><br><span class="line"><span class="keyword">return</span> vm.runInThisContext(wrapper, &#123;</span><br><span class="line">    filename,</span><br><span class="line">    lineOffset: <span class="number">0</span>,</span><br><span class="line">    displayErrors: <span class="literal">true</span>,</span><br><span class="line">    importModuleDynamically: <span class="keyword">async</span> (specifier) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> loader = asyncESM.ESMLoader;</span><br><span class="line">        <span class="keyword">return</span> loader.import(specifier, normalizeReferrerURL(filename));</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改该模块的加载状态为true</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.loaded = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>加载成功。</p>
</li>
</ol>
<p>通过上面的调试过程可得出以下结论：</p>
<ol>
<li>在NodeJs中，从入口文件开始，一切皆 Module</li>
<li>模块的加载是==同步==的</li>
<li>由于缓存机制的存在，模块的循环引用对性能的影响微乎其微，并且循环引用到的模块可能是不完整的，并且可能会导致错误</li>
</ol>
<p>require 查找模块的流程</p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210112%20/13-37-29-tie2Os.jpeg" alt="img"></p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210112%20/13-38-01-RkeGjR.jpeg" alt="img"></p>
]]></content>
      <categories>
        <category>NodeJs</category>
        <category>require</category>
        <category>module</category>
      </categories>
      <tags>
        <tag>Module</tag>
        <tag>nodejs</tag>
        <tag>require</tag>
      </tags>
  </entry>
  <entry>
    <title>JMeter 简介及安装</title>
    <url>/yinyiwang/2021/02/26/jmeter%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<blockquote>
<p>最近需要进行一组性能测试，用到了 <strong>JMeter</strong> 这个测试工具，简单记录下对它的了解以及安装过程。</p>
</blockquote>
<a id="more"></a>

<h2 id="JMeter-简介"><a href="#JMeter-简介" class="headerlink" title="JMeter 简介"></a>JMeter 简介</h2><p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210301%20/15-00-08-fnMAIf.png" alt="image-20210226205547298"></p>
<p>全名为 <strong>Apache JMeter</strong></p>
<p><code>JMeter</code> 是一个软件，使负载测试或业绩为导向的业务（功能）测试不同的协议或技术。<br>它是 Apache 软件基金会的Stefano Mazzocchi JMeter 最初开发的。<br>它主要对 Apache JServ（现在称为如 Apache Tomcat 项目）的性能进行测试。<br>Apache 后来重新设计 JMeter 增强的图形用户界面和添加功能测试能力。</p>
<h2 id="JMeter-的作用"><a href="#JMeter-的作用" class="headerlink" title="JMeter 的作用"></a>JMeter 的作用</h2><p>Apache JMeter 是100%纯 JAVA 桌面应用程序，被设计为用于测试客户端/服务端结构的软件(例如 web 应用程序)。<br>JMeter 可以用来测试静态和动态资源的性能，例如：静态文件，Java Servlet,CGI Scripts,Java Object,数据库和 FTP 服务器等等。<br>JMeter 可用于模拟大量负载来测试一台服务器，网络或者对象的健壮性或者分析不同负载下的整体性能。     </p>
<p>同时，JMeter 可以帮助你对你的应用程序进行回归测试。通过你创建的测试脚本和 assertions 来验证你的程序返回了所期待的值。<br>为了更高的适应性，JMeter 允许调用二次开发的 jar 包来丰富你的测试场景；JMeter 允许你使用正则表达式来创建这些 assertions.</p>
<h2 id="JMeter-的使用范围"><a href="#JMeter-的使用范围" class="headerlink" title="JMeter 的使用范围"></a>JMeter 的使用范围</h2><p>JMeter 是一个具有图形界面，使用 Swing 图形 API 的 Java 桌面应用程序，因此可以运行在任何环境/工作站接受一个 Java 虚拟机，例如：在 Windows，Linux，MAC等。</p>
<h2 id="JMeter-支持的协议"><a href="#JMeter-支持的协议" class="headerlink" title="JMeter 支持的协议"></a>JMeter 支持的协议</h2><ul>
<li>web —— HTTP，HTTPS 站点的 Web1.0的Web 2.0 (ajax, flex and flex-ws-amf)</li>
<li>Web Services: —— SOAP / XML-RPC</li>
<li>通过 JDBC 驱动程序的数据库</li>
<li>目录: —— LDAP</li>
<li>通过 JMS 面向消息的服务</li>
<li>Service: —— POP3, IMAP, SMTP</li>
<li>FTP 服务</li>
</ul>
<h2 id="JMeter-的特点"><a href="#JMeter-的特点" class="headerlink" title="JMeter 的特点"></a>JMeter 的特点</h2><p>以下是一些  JMeter 的特点：</p>
<ul>
<li>它是免费的。开放源码软件。</li>
<li>它具有简单，直观的图形用户界面。</li>
<li>JMeter中负载和性能测试许多不同的服务器类型：网站 - - HTTP，HTTPS，SOAP，数据库通过 JDBC，LDAP，JMS，邮件 POP3</li>
<li>它是独立于平台的工具。在 Linux / UNIX，JMeter 中 JMeter 中 shell 脚本点击可以调用。在 Windows 上，它可以调用启动 JMeter.bat 文件。</li>
<li>它具有完整的 Swing 和轻量级组件支持（预编译的 JAR 使用包 javax.swing 中*）。</li>
<li>JMeter 测试计划存储为XML格式。这意味着可以使用文本编辑器生成一个测试计划。</li>
<li>它的完整的多线程框架，允许并发多线程和同步采样不同的功能由单独的线程组采样。</li>
<li>它是高度可扩展的。</li>
<li>也可用于执行应用程序的自动化测试和功能测试。</li>
</ul>
<h2 id="JMeter-的安装"><a href="#JMeter-的安装" class="headerlink" title="JMeter 的安装"></a>JMeter 的安装</h2><ol>
<li><p>进入 <a href="https://JMeter.apache.org/" target="_blank" rel="noopener">Apache JMeter 官网 </a>，选择 <strong>Download Release</strong>，如下图：</p>
<p> <img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210301%20/15-00-14-tVazaK.png" alt="image-20210226190149441"></p>
</li>
<li><p>根据操作系统，选择要下载的压缩包：</p>
<p> <img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210301%20/15-00-22-rpeUwp.png" alt="image-20210226190809394"></p>
<blockquote>
<p>注意事项：</p>
<ol>
<li>注意图片标题中的 Java 版本要求，这里要求的是 Java8 及以上的版本。</li>
<li>我们一般选择 <strong>Binaries</strong> 下的压缩包，除非是你想要使用它的源码做研究，则可以选择 Source 下的资源包。</li>
</ol>
</blockquote>
</li>
<li><p>解压下载下来的压缩包，得到如下的文件结构：</p>
<p> <img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210301%20/15-00-27-WXk5Jo.png" alt="image-20210226191501823"></p>
</li>
<li><p>打开 <strong>bin</strong> 目录，通过双击 <strong>ApacheJMeter.jar</strong> 即可启动JMeter：</p>
<p> <img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210301%20/15-00-31-NnT9V8.png" alt="image-20210226192035951"></p>
<blockquote>
<ol>
<li>也可以通过可执行文件进行启动，不同系统上的可执行文件在上图中有标出。</li>
<li>JMeter 的运行需要 Java 环境的支持，需要提前安装 <strong>JDK</strong> 。</li>
</ol>
</blockquote>
</li>
</ol>
<h2 id="JMeter-根目录结构说明"><a href="#JMeter-根目录结构说明" class="headerlink" title="JMeter 根目录结构说明"></a>JMeter 根目录结构说明</h2><ol>
<li><p><strong>backup 目录</strong>   </p>
<p> 脚本备份目录，里边的文件都是以 .jmx 后缀结尾的文件。</p>
<p> 实际开始安装解压后是不存在这个目录的，在使用过 JMeter 后，JMeter 自动创建这个目录，然后备份了脚本文件。</p>
</li>
<li><p><strong>bin 目录</strong>  </p>
<p> 可执行文件目录</p>
<ul>
<li><p>Jmeter.bat：是启动 JMeter 的主脚本。</p>
</li>
<li><p>Jmeter-server.bar：是用来实现联机负载。</p>
</li>
<li><p>Jmeter.properties：是 JMeter 主要的配置文件，超过 80% 的配置项都是通过这个文件实现。（PS：修改配置文件后，要重启 Jmeter 才能生效）。</p>
<blockquote>
<p>Jmeter.bat  打开 Jmeter 主界面。</p>
<p>Jmeter 使用的日志文件名称被定义到 Jmeter.properties 中，默认在 Jmeter.log 可查看日志。</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>dosc 目录</strong></p>
<p> docs 目录下的文件是 JMeter 的 Java Docs。 </p>
<p> printable_docs 的 usermanual 子目录下的内容是 JMeter 的用户手册文档，其中 component_reference.html 是最常用到的核心元件帮助文档。该目录下存放的是 JMeter 官方文档的 API 文档，主要是用于<em>二次开发</em>。</p>
</li>
<li><p><strong>extras 目录</strong></p>
<p> 该目录下的文件提供了对构建工具 Ant 的支持，可以使用 Ant 来实现测试自动化，例如批量脚本执行，产生 HTML格式的报表，测试运行时，可以把测试数据记录下来，Jmeter 会自动生成一个 .jtl 文件，将该文件放到 extras 目录下，运行 “ant -Dtest=文件名 report”，就可以生成测试统计报表。</p>
</li>
<li><p><strong>lib 目录</strong></p>
<p> 该目录包含两个子目录，其中 ext 子目录存放有 JMeter 的核心 jar 包，另一个 junit 子目录存放 JUnit 测试脚本。</p>
<p> 用户扩展所依赖的包，应该直接放到 lib 目录下，而非 lib/ext 下。</p>
<blockquote>
<p>注意：无法识别 zip 格式的包文件，所以需要的包文件均要求以 .jar 结尾</p>
</blockquote>
</li>
<li><p><strong>Licenses JMeter 软件许可文件目录</strong></p>
</li>
<li><p><strong>printable_docs 目录</strong></p>
<p> 该目录存放的是 JMeter 官方提供的帮助文档。</p>
<p> printable_docs 的 demos 子目录下有一些常用的 JMeter 脚本案例，可以作为参考。</p>
</li>
<li><p><strong>LICENSE JMeter ——许可说明</strong></p>
</li>
<li><p><strong>NOTICE JMeter ——简单信息说明</strong></p>
</li>
<li><p><strong>README.md ——JMeter 官方基本介绍</strong></p>
</li>
</ol>
<h2 id="bin-目录说明"><a href="#bin-目录说明" class="headerlink" title="bin 目录说明"></a>bin 目录说明</h2><h4 id="window-下"><a href="#window-下" class="headerlink" title="window 下"></a>window 下</h4><ul>
<li><p><strong>JMeter.bat</strong></p>
<p>  启动 JMeter (默认 GUI 模式)</p>
</li>
<li><p><strong>jmeterw.cmd</strong></p>
<p>  启动 JMeter 没有 windows shell 控制台 (默认 GUI 模式)</p>
</li>
<li><p><strong>JMeter-n.cmd</strong></p>
<p>  删除一个 JMX 文件在运行非 GUI 测试</p>
</li>
<li><p><strong>JMeter-n-r.cmd</strong></p>
<p>  删除一个 JMX 文件在运行非 GUI 远程测试</p>
</li>
<li><p><strong>JMeter-t.cmd</strong></p>
<p>  删除一个 JMX 文件在 GUI 模式下加载它</p>
</li>
<li><p><strong>JMeter-server.bat</strong></p>
<p>  在服务器模式启动 JMeter</p>
</li>
<li><p><strong>mirror-server.cmd</strong></p>
<p>  在非 GUI 模式下运行 JMeter 镜像服务器</p>
</li>
<li><p><strong>shutdown.cm</strong></p>
<p>  运行关闭客户端，以优雅地停止非 GUI 实例</p>
</li>
<li><p><strong>stoptest.cmd</strong></p>
<p>  运行关闭客户端，停止非 GUI 实例</p>
</li>
</ul>
<h4 id="在大多数-Linux-UNIX-系统上"><a href="#在大多数-Linux-UNIX-系统上" class="headerlink" title="在大多数 Linux / UNIX 系统上"></a>在大多数 Linux / UNIX 系统上</h4><ul>
<li><p><strong>JMeter</strong></p>
<p>  启动 JMeter (默认 GUI 模式). 定义一些可能不适用于所有 JVM 的 JVM 设置。</p>
</li>
<li><p><strong>JMeter-server</strong></p>
<p>  在服务器模式启动 JMeter (使用适当的参数调用 JMeter 脚本)</p>
</li>
<li><p><strong>JMeter.sh</strong></p>
<p>  非常基础的 JMeter 脚本 (你可能需要调整 JVM 选项，比如内存设置).</p>
</li>
<li><p><strong>mirror-server.sh</strong></p>
<p>  在非 GUI 模式下运行 JMeter 镜像服务器</p>
</li>
<li><p><strong>shutdown.sh</strong></p>
<p>  运行关闭客户端，以优雅地停止非 GUI 实例</p>
</li>
<li><p><strong>stoptest.sh</strong></p>
<p>  运行关闭客户端，停止非 GUI 实例</p>
</li>
</ul>
<h2 id="JMeter-插件安装"><a href="#JMeter-插件安装" class="headerlink" title="JMeter 插件安装"></a>JMeter 插件安装</h2><ol>
<li><p>进入 <a href="https://JMeter-plugins.org/install/Install/" target="_blank" rel="noopener">JMeter 插件网站</a>，下载  JMeter 插件包</p>
<p> <img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210301%20/15-00-41-NTIwDe.png" alt="image-20210226193950155"></p>
</li>
<li><p>解压插件，找到 JMeterPlugins-Extras.jar，把 JMeterPlugins-Extras.jar 放到 apache-JMeter-5.4.1\lib\ext 目录。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>JMeter</tag>
      </tags>
  </entry>
  <entry>
    <title>（鸡汤文）这一次我终于搞懂了 JavaScript 定时器的 this 指向！</title>
    <url>/yinyiwang/2021/07/05/%EF%BC%88%E9%B8%A1%E6%B1%A4%E6%96%87%EF%BC%89%E8%BF%99%E4%B8%80%E6%AC%A1%E6%88%91%E7%BB%88%E4%BA%8E%E6%90%9E%E6%87%82%E4%BA%86-JavaScript-%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84-this-%E6%8C%87%E5%90%91%EF%BC%81/</url>
    <content><![CDATA[<h2 id="开篇语"><a href="#开篇语" class="headerlink" title="开篇语"></a>开篇语</h2><p>忽然有一种感觉，每次学习一个知识点就像是谈一场恋爱：从初次邂逅，到彼此了解，一切都那么的符合恋爱的过程！</p>
<p>如果这个知识点再有点”调皮“的话，那简直是让人欲仙欲死而又不可自拔！因为你永远不知道它还有多少面纱等着你揭开，当你自以为对它已经足够了解的时候，冷不防就是一个盲点迎面砸来。</p>
<a id="more"></a>

<p>它简直就像一个”宝藏女孩“，你要时刻做好迎接”惊喜“的准备！</p>
<p>可能正是因为这种新鲜感，我才能一直保持一种类似亢奋的状态吧。当然，这只是针对知识而言，对待情感我还是很保守很专一的&lt;(￣︶￣)&gt;</p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210620%20/18-26-23-TC6v8z.jpg" alt="宝藏女孩"></p>
<p>这两天，我就在和定时器谈恋爱，哦不，是在学习定时器(￣▽￣)~*，可没想到，又给陷进去了……</p>
<p>这不，上一篇文章写完定时器的返回值后，刚觉得自己对它已经了解的清清楚楚明明白白了，够我炫耀一阵子了，谁成想，喘口气的功夫，它又给我整出了幺蛾子。</p>
<h2 id="惑起"><a href="#惑起" class="headerlink" title="惑起"></a>惑起</h2><p>写完上篇文章后，我就琢磨着里面的实现代码还可以优化一下，于是给改成了下面这个样子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">""</span> <span class="attr">class</span>=<span class="string">"example-form"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"name"</span>&gt;</span></span><br><span class="line">            名称</span><br><span class="line">        <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"input-ele"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">id</span>=<span class="string">"name"</span> <span class="attr">placeholder</span>=<span class="string">"please input your name"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">autocomplete</span>=<span class="string">"off"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"margin-top:50px;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"res"</span>&gt;</span></span><br><span class="line">            输入</span><br><span class="line">        <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">class</span>=<span class="string">"input-ele"</span> <span class="attr">type</span>=<span class="string">"multipart"</span> <span class="attr">name</span>=<span class="string">"res"</span> <span class="attr">id</span>=<span class="string">"res"</span> <span class="attr">readonly</span></span></span><br><span class="line"><span class="tag">            <span class="attr">placeholder</span>=<span class="string">"这里是每一次输入的结果"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> resEle = <span class="built_in">document</span>.querySelector(<span class="string">"#res"</span>);</span></span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">changeOutputVal</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">            resEle.value += <span class="string">`\n<span class="subst">$&#123; <span class="keyword">this</span>.value &#125;</span>`</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">throttle</span><span class="params">(fun, delay)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> last, deferTimer</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">let</span> now = <span class="built_in">Date</span>.now();</span></span><br><span class="line">                if (last &amp;&amp; now &lt; last + delay) &#123;</span><br><span class="line">                    clearTimeout(deferTimer);</span><br><span class="line"><span class="actionscript">                    deferTimer = setTimeout(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line">                        last = now;</span><br><span class="line"><span class="actionscript">                        fun.apply(<span class="keyword">this</span>);</span></span><br><span class="line">                    &#125;, delay)</span><br><span class="line"><span class="actionscript">                &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line">                    last = now;</span><br><span class="line"><span class="actionscript">                    fun.apply(<span class="keyword">this</span>);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> inputEle = <span class="built_in">document</span>.querySelector(<span class="string">"#name"</span>);</span></span><br><span class="line"><span class="actionscript">        inputEle.addEventListener(<span class="string">"input"</span>, throttle(changeOutputVal, <span class="number">1000</span>));</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我的修改依据是：</p>
<ol>
<li>throttle 方法返回的是一个匿名函数，这个函数正好充当 input 事件的回调函数</li>
<li>input 事件回调函数中的 this 指向的是 inputEle</li>
<li>匿名函数中将 this 绑定给了 fun 参数，而实际使用中传入的是 changeOutputVal 方法</li>
<li>所以 changeOutputVal 方法中的 this 指的就是 inputEle，所以在它里面可以通过 <code>this.value</code> 获取到 inputEle 的值</li>
</ol>
<p>看，这逻辑多严谨，简直头头是道啊 \（￣︶￣）/</p>
<p>按理说，是没问题的吧，结果却出问题了。欲知详情，请看大屏幕：</p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210620%20/19-03-03-MbbndB.gif" alt="错误结果"></p>
<p>这个 <strong>undefined</strong> 是什么鬼？！从哪冒出来的？难道我的延时器没用对？</p>
<h2 id="解惑"><a href="#解惑" class="headerlink" title="解惑"></a>解惑</h2><p>面对我的质疑，setTimeout 理直气壮地说：人家回调函数中的 this 本来就是指向 window 对象的嘛，你也没早问啊！</p>
<p>那么，问题来了：为什么延时器中的 this 指向的是 window 呢？setTimeout 自己也解释不清楚了。</p>
<p>得，看来前人诚不我欺也——自己动手，丰衣足食！</p>
<p>凡事不决找 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout" target="_blank" rel="noopener">MDN</a>，绝对靠谱！我们来看看 MDN 怎么说：</p>
<blockquote>
<p>由<code>setTimeout()</code>调用的代码运行在与所在函数完全分离的执行环境上。这会导致，这些代码中包含的 <code>this</code> 关键字在非严格模式会指向 <code>window</code> (或全局)对象，严格模式下为 undefined，这和所期望的<code>this</code>的值是不一样的。</p>
</blockquote>
<p>看到这个解释，我才明白：this 指向 window 对象，原来是因为<strong>执行环境</strong>的不同导致的。</p>
<p>在上面的代码中，因为 window 对象没有 value 这个属性，所以 <code>window.value = undefined</code>。</p>
<p>感觉自己在专业的方向上又迈进了一小步，容我小小地嘚瑟一下！</p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210620%20/19-24-24-HuRZq9.jpeg" alt="嘚瑟"></p>
<h2 id="改错"><a href="#改错" class="headerlink" title="改错"></a>改错</h2><p>既然知道问题出在哪，那就好办了，我们只需要将 setTimeout 回到函数内部的 this 指向改变一下就好，这里有以下方案。</p>
<h3 id="使用变量引用外部-this"><a href="#使用变量引用外部-this" class="headerlink" title="使用变量引用外部 this"></a>使用变量引用外部 this</h3><p>关键代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// some code here</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> that = <span class="keyword">this</span>;</span><br><span class="line">    deferTimer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        last = now;</span><br><span class="line">        fun.apply(that);</span><br><span class="line">    &#125;, delay)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// some code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用箭头函数"><a href="#使用箭头函数" class="headerlink" title="使用箭头函数"></a>使用箭头函数</h3><p>利用箭头函数不会改变 this 的指向的特性，改造如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// some code here</span></span><br><span class="line">    </span><br><span class="line">    deferTimer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        last = now;</span><br><span class="line">        fun.apply(<span class="keyword">this</span>);</span><br><span class="line">    &#125;, delay)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// some code here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>知错能改，善莫大焉！</p>
<p>写到这里，我居然体会到了古人那种”朝闻道，夕死可矣“的满足感。</p>
<p>在编程这条路上，可能遍布荆棘，但只要我们勤耕不辍，总能开辟出属于自己的康庄大道！</p>
<p><strong>这鸡汤太美味，我先干为敬，你们随意！ｂ（￣▽￣）ｄ</strong></p>
<p>~</p>
<p>~</p>
<p>~ 本文完，感谢阅读！</p>
<p>~</p>
<blockquote>
<p>学习有趣的知识，结识有趣的朋友，塑造有趣的灵魂！</p>
<p>我是〖编程三昧〗的作者 <strong>隐逸王</strong>，我的公众号是『编程三昧』，欢迎关注，希望大家多多指教！</p>
<p>你来，怀揣期望，我有墨香相迎！ 你归，无论得失，唯以余韵相赠！</p>
<p>知识与技能并重，内力和外功兼修，理论和实践两手都要抓、两手都要硬！</p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript - 定时器</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>定时器</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Electron构建桌面应用（一）—— Electron的安装</title>
    <url>/yinyiwang/2021/03/12/%E4%BD%BF%E7%94%A8Electron%E6%9E%84%E5%BB%BA%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%20Electron%E7%9A%84%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>报错</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Failed to download repo simulatedgreg/electron-vue: end of central directory record signature not found</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210312%20/19-52-51-23ERKt.png" alt="初始化报错"></p>
<p>解决</p>
<p>就webpack -v检查是否装了webpack(如果没有全局安装时，每次新建项目都需要重新安装)，执行npm install webpack -g即可。</p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210312%20/19-55-16-C95SYx.png" alt="安装webpack"></p>
<h3 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h3><p>我尝试过用npm下载Electron，不过那速度很美丽。所以我选择了淘宝国内镜像。</p>
<h3 id="cnpm"><a href="#cnpm" class="headerlink" title="cnpm"></a>cnpm</h3><p>通过npm安装cnpm…这速度当然非常美丽。<br>建议边吃饭边看电视边看小说，然后等待。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<h3 id="通过cnpm安装Electron"><a href="#通过cnpm安装Electron" class="headerlink" title="通过cnpm安装Electron"></a>通过cnpm安装Electron</h3><p>全局安装electron，可能会有权限问题所以使用sudo来进行安装。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo cnpm install -g electron</span><br></pre></td></tr></table></figure>



<h2 id="启动Electron"><a href="#启动Electron" class="headerlink" title="启动Electron"></a>启动Electron</h2><h3 id="通过Electron提供的快速工程打开一个简单的electron项目"><a href="#通过Electron提供的快速工程打开一个简单的electron项目" class="headerlink" title="通过Electron提供的快速工程打开一个简单的electron项目"></a>通过Electron提供的快速工程打开一个简单的electron项目</h3><p><a href="https://electronjs.org/docs/tutorial/first-app#尝试此例" target="_blank" rel="noopener">教程地址</a><br>当然你这一步骤需要git，所以你还额外需要安装git。百度一下，自己动一下手。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 克隆这仓库</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/electron/electron-quick-start</span><br><span class="line"><span class="comment"># 进入仓库</span></span><br><span class="line"><span class="built_in">cd</span> electron-quick-start</span><br><span class="line"><span class="comment"># 安装依赖库</span></span><br><span class="line">npm install</span><br><span class="line"><span class="comment"># 运行应用</span></span><br><span class="line">npm start</span><br></pre></td></tr></table></figure>

<p>如果程序正常运行的话，你会看见弹出一个electron工程窗口！</p>
<h3 id="大功告成"><a href="#大功告成" class="headerlink" title="大功告成"></a>大功告成</h3><p>完结！开玩笑的<br>当然，你已经成功创建了一个electron项目，即使他还是那么简陋。所以它还仅仅不够。<br>以下<a href="https://molunerfinn.com/electron-vue-1/#electron-vue安装" target="_blank" rel="noopener">代码出处</a></p>
<h2 id="安装Electron-vue"><a href="#安装Electron-vue" class="headerlink" title="安装Electron-vue"></a>安装Electron-vue</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果你没有vue-cli的话需要全局安装</span></span><br><span class="line">npm install -g vue-cli</span><br><span class="line"><span class="comment"># 然后使用vue-cli来安装electron-vue的模板</span></span><br><span class="line">vue init simulatedgreg/electron-vue my-project</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line"><span class="built_in">cd</span> my-project</span><br><span class="line">yarn <span class="comment"># or npm install</span></span><br><span class="line"><span class="comment"># 进入开发模式</span></span><br><span class="line">yarn run dev <span class="comment"># or npm run dev</span></span><br></pre></td></tr></table></figure>



<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210313%20/22-32-32-IKyRTi.png" alt="下载模板速度很慢"></p>
<h3 id="npm-install-正文开始"><a href="#npm-install-正文开始" class="headerlink" title="npm install(正文开始)"></a>npm install(正文开始)</h3><p>安装依赖，实际上我是在这步才安装cnpm，因为npm的下载速度实在太美丽。</p>
<h3 id="cnpm-install"><a href="#cnpm-install" class="headerlink" title="cnpm install"></a>cnpm install</h3><p>安装所需的依赖。然而，我使用这步安装完所有的依赖，但我执行cnpm run dev又出问题了。所以我不得不安装yarn。</p>
<h3 id="yarn"><a href="#yarn" class="headerlink" title="yarn"></a>yarn</h3><h4 id="安装yarn"><a href="#安装yarn" class="headerlink" title="安装yarn"></a>安装yarn</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 我是使用aptitude来安装，win/mac请忽视这一步</span></span><br><span class="line">$ sudo aptitude update &amp;&amp; sudo aptitude install yarn</span><br><span class="line"><span class="comment"># or sudo apt-get update &amp;&amp; sudo apt-get install yarn</span></span><br></pre></td></tr></table></figure>

<h4 id="踩坑yarn"><a href="#踩坑yarn" class="headerlink" title="踩坑yarn"></a>踩坑yarn</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 当我cd到my-project文件</span></span><br><span class="line">$ yarn</span><br><span class="line">00h00m00s 0/0: : ERROR: There are no scenarios; must have at least one.</span><br><span class="line"><span class="comment"># 却收获一个错误</span></span><br><span class="line"><span class="comment"># 经过搜索可能是yarn版本低的问题</span></span><br><span class="line"><span class="comment"># 当然，如果你没报错的话，请忽视这一步骤</span></span><br><span class="line">$ sudo apt remove yarn</span><br><span class="line"></span><br><span class="line">$ curl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | sudo apt-key add -</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"deb https://dl.yarnpkg.com/debian/ stable main"</span> | sudo tee /etc/apt/sources.list.d/yarn.list</span><br><span class="line"></span><br><span class="line">$ sudo apt update &amp;&amp; sudo apt install yarn</span><br><span class="line"><span class="comment"># 最后在执行下yarn</span></span><br><span class="line">$ yarn</span><br><span class="line"><span class="comment"># 但是我yarn在下载依赖的时候，报错了</span></span><br><span class="line">libgconf-2.so.4: cannot open shared object file: No such file or directory</span><br><span class="line"><span class="comment"># 提示缺少libgconf-2.so.4</span></span><br><span class="line"><span class="comment"># 此时只需要下载libgconf2-4即可</span></span><br><span class="line">$ sudo apt-get install libgconf2-4</span><br><span class="line"><span class="comment"># 进入开发模式</span></span><br><span class="line">$ yarn run dev</span><br></pre></td></tr></table></figure>

<h2 id="大功告成-1"><a href="#大功告成-1" class="headerlink" title="大功告成"></a>大功告成</h2><p>大功告成！</p>
]]></content>
      <categories>
        <category>Electron</category>
        <category>electron-vue</category>
      </categories>
      <tags>
        <tag>Electron</tag>
        <tag>Electron-vue</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Electron 构建桌面应用（一）—— Electron 简介</title>
    <url>/yinyiwang/2021/03/12/%E4%BD%BF%E7%94%A8Electron%E6%9E%84%E5%BB%BA%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94Electron%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>electron杂烩</title>
    <url>/yinyiwang/2021/03/15/electron%E6%9D%82%E7%83%A9/</url>
    <content><![CDATA[<p>electron杂烩</p>
<p>获取某一页面的某个元素</p>
<p></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mainWindow.webContents.on(<span class="string">'dom-ready'</span>, () =&gt; &#123;</span><br><span class="line">  mainWindow.webContents</span><br><span class="line">    .executeJavaScript(</span><br><span class="line">      <span class="string">`</span></span><br><span class="line"><span class="string">      const waitForExternal = setInterval(() =&gt; &#123;</span></span><br><span class="line"><span class="string">        if (document.querySelector('.btn'))&#123;</span></span><br><span class="line"><span class="string">          clearInterval(waitForExternal);</span></span><br><span class="line"><span class="string">          console.log(11111);</span></span><br><span class="line"><span class="string">        &#125;else&#123;</span></span><br><span class="line"><span class="string">          console.log('no');</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      &#125;, 100);</span></span><br><span class="line"><span class="string">      `</span>,</span><br><span class="line">      <span class="literal">false</span>,</span><br><span class="line">      (result) =&gt;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'webContents exec callback: '</span> + result)</span><br><span class="line">    )</span><br><span class="line">    .then(<span class="function">(<span class="params">result</span>) =&gt;</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'webContents exec then: '</span> + result)</span><br><span class="line">    );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>ES6 迭代器简述</title>
    <url>/yinyiwang/2021/07/05/ES6-%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%AE%80%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h2><p>Iterator 是 ES6 引入的一种遍历机制，迭代器有两个核心概念：</p>
<ul>
<li>迭代器是一个统一的接口，它的作用是使各种数据结构可被便捷地访问，它是通过一个键为Symbol.iterator 的方法来实现。</li>
<li>迭代器是用于遍历数据结构元素的指针（如数据库中的游标）。</li>
</ul>
<a id="more"></a>

<h3 id="迭代过程"><a href="#迭代过程" class="headerlink" title="迭代过程"></a>迭代过程</h3><p>迭代的过程如下：</p>
<ul>
<li>通过 Symbol.iterator 创建一个迭代器，指向当前数据结构的起始位置</li>
<li>随后通过 next 方法进行向下迭代指向下一个位置， next 方法会返回当前位置的对象，对象包含了 value 和 done 两个属性， value 是当前属性的值， done 用于判断是否遍历结束</li>
<li>当 done 为 true 时则遍历结束</li>
</ul>
<p>下面通过一个简单的例子进行说明：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> items = [<span class="string">"zero"</span>, <span class="string">"one"</span>, <span class="string">"two"</span>]; </span><br><span class="line"><span class="keyword">const</span> it = items[<span class="built_in">Symbol</span>.iterator]();  </span><br><span class="line">it.next(); </span><br><span class="line"><span class="comment">// &#123;value: "zero", done: false&#125; </span></span><br><span class="line">it.next(); </span><br><span class="line"><span class="comment">// &#123;value: "one", done: false&#125; </span></span><br><span class="line">it.next(); </span><br><span class="line"><span class="comment">// &#123;value: "two", done: false&#125; </span></span><br><span class="line">it.next(); </span><br><span class="line"><span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<p>上面的例子，首先创建一个数组，然后通过 Symbol.iterator 方法创建一个迭代器，之后不断地调用 next 方法对数组内部项进行访问，当属性 done 为 true 时访问结束。</p>
<p>迭代器是协议（使用它们的规则）的一部分，用于迭代。该协议的一个关键特性就是它是顺序的：迭代器一次返回一个值。这意味着如果可迭代数据结构是非线性的（例如树），迭代将会使其线性化。</p>
<h3 id="可迭代的数据结构"><a href="#可迭代的数据结构" class="headerlink" title="可迭代的数据结构"></a>可迭代的数据结构</h3><p>以下是可迭代的值:</p>
<ul>
<li>Array</li>
<li>String</li>
<li>Map</li>
<li>Set</li>
<li>Dom元素（正在进行中）</li>
</ul>
<p>我们将使用 <strong>for…of</strong> 循环（参见下文的 for…of 循环）对数据结构进行迭代。</p>
<p><strong>Array</strong></p>
<p>数组 ( Array ) 和类型数组 ( TypedArray ) 他们是可迭代的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> [<span class="string">"zero"</span>, <span class="string">"one"</span>, <span class="string">"two"</span>]) &#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(item); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// zero </span></span><br><span class="line"><span class="comment">// one </span></span><br><span class="line"><span class="comment">// two</span></span><br></pre></td></tr></table></figure>

<p><strong>String</strong></p>
<p>字符串是可迭代的，但他们遍历的是 Unicode 码，每个码可能包含一个到两个的 Javascript 字符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> c <span class="keyword">of</span> <span class="string">'z\uD83D\uDC0A'</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(c); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// z </span></span><br><span class="line"><span class="comment">// \uD83D\uDC0A</span></span><br></pre></td></tr></table></figure>

<p><strong>Map</strong></p>
<p>Map 主要是迭代它们的 entries ，每个 entry 都会被编码为 [key, value] 的项， entries 是以确定的形式进行迭代，其顺序是与添加的顺序相同。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(); </span><br><span class="line">map.set(<span class="number">0</span>, <span class="string">"zero"</span>); </span><br><span class="line">map.set(<span class="number">1</span>, <span class="string">"one"</span>);  </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> map) &#123;  </span><br><span class="line">    <span class="built_in">console</span>.log(item); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// [0, "zero"] </span></span><br><span class="line"><span class="comment">// [1, "one"]</span></span><br></pre></td></tr></table></figure>

<p>注意： WeakMaps 不可迭代</p>
<p><strong>Set</strong></p>
<p>Set 是对其元素进行迭代，迭代的顺序与其添加的顺序相同</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set(); </span><br><span class="line"><span class="keyword">set</span>.add("zero"); </span><br><span class="line"><span class="keyword">set</span>.add("one");  </span><br><span class="line">for (let item of <span class="keyword">set</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// zero </span></span><br><span class="line"><span class="comment">// one</span></span><br></pre></td></tr></table></figure>

<p>注意： WeakSets 不可迭代</p>
<p><strong>arguments</strong></p>
<p>arguments 目前在 ES6 中使用越来越少，但也是可遍历的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">args</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> <span class="built_in">arguments</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">args(<span class="string">"zero"</span>, <span class="string">"one"</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// zero </span></span><br><span class="line"><span class="comment">// one</span></span><br></pre></td></tr></table></figure>

<h3 id="普通对象不可迭代"><a href="#普通对象不可迭代" class="headerlink" title="普通对象不可迭代"></a>普通对象不可迭代</h3><p>普通对象是由 object 创建的，不可迭代：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TypeError </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> &#123;&#125;) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Uncaught TypeError: &#123;&#125; is not iterable</span></span><br></pre></td></tr></table></figure>

<h2 id="for…of循环"><a href="#for…of循环" class="headerlink" title="for…of循环"></a>for…of循环</h2><p>for…of 是 ES6 新引入的循环，用于替代 for..in 和 forEach() ，并且支持新的迭代协议。它可用于迭代常规的数据类型，如 <code>Array</code> 、 <code>String</code> 、 <code>Map</code>和 <code>Set</code> 等等。</p>
<h3 id="迭代常规数据类型"><a href="#迭代常规数据类型" class="headerlink" title="迭代常规数据类型"></a>迭代常规数据类型</h3><p><strong>Array</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nums = [<span class="string">"zero"</span>, <span class="string">"one"</span>, <span class="string">"two"</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// zero</span></span><br><span class="line"><span class="comment">// one</span></span><br><span class="line"><span class="comment">// two</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> typedArray1 = <span class="keyword">new</span> <span class="built_in">Int8Array</span>(<span class="number">6</span>); </span><br><span class="line">typedArray1[<span class="number">0</span>] = <span class="number">10</span>; </span><br><span class="line">typedArray1[<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> typedArray1) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"><span class="comment">// 11</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p><strong>String</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">"zero"</span>;  </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> str) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// z</span></span><br><span class="line"><span class="comment">// e</span></span><br><span class="line"><span class="comment">// r</span></span><br><span class="line"><span class="comment">// o</span></span><br></pre></td></tr></table></figure>

<p><strong>Map</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myMap = <span class="keyword">new</span> <span class="built_in">Map</span>(); </span><br><span class="line">myMap.set(<span class="number">0</span>, <span class="string">"zero"</span>); </span><br><span class="line">myMap.set(<span class="number">1</span>, <span class="string">"one"</span>); </span><br><span class="line">myMap.set(<span class="number">2</span>, <span class="string">"two"</span>);  </span><br><span class="line"><span class="comment">// 遍历 key 和 value </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> myMap) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key + <span class="string">" = "</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> myMap.entries()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key + <span class="string">" = "</span> + value);</span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 只遍历 key </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> myMap.keys()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 只遍历 value </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> myMap.values()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Set</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mySet = <span class="keyword">new</span> <span class="built_in">Set</span>(); </span><br><span class="line">mySet.add(<span class="string">"zero"</span>); </span><br><span class="line">mySet.add(<span class="string">"one"</span>); </span><br><span class="line">mySet.add(<span class="string">"two"</span>);  </span><br><span class="line"><span class="comment">// 遍历整个 set </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> mySet) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 只遍历 key 值 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> mySet.keys()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 只遍历 value </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> mySet.values()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 遍历 key 和 value ，两者会相等 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> mySet.entries()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key + <span class="string">" = "</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="可迭代的数据结构-1"><a href="#可迭代的数据结构-1" class="headerlink" title="可迭代的数据结构"></a>可迭代的数据结构</h3><p>of 操作数必须是可迭代，这意味着如果是普通对象则无法进行迭代。如果数据结构类似于数组的形式，则可以借助 Array.from() 方法进行转换迭代。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayLink = &#123;</span><br><span class="line">    length: <span class="number">2</span>, </span><br><span class="line">    <span class="number">0</span>: <span class="string">"zero"</span>, </span><br><span class="line">    <span class="number">1</span>: <span class="string">"one"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 报 TypeError 异常 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arrayLink) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 正常运行 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> <span class="built_in">Array</span>.from(arrayLink)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output: </span></span><br><span class="line"><span class="comment">// zero </span></span><br><span class="line"><span class="comment">// one</span></span><br></pre></td></tr></table></figure>

<p><strong>let 、const 和 var 用于 for..of</strong></p>
<p>如果使用 let 和 const ，每次迭代将会创建一个新的存储空间，这可以保证作用域在迭代的内部。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nums = [<span class="string">"zero"</span>, <span class="string">"one"</span>, <span class="string">"two"</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num);</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 报 ReferenceError </span></span><br><span class="line"><span class="built_in">console</span>.log(num);</span><br></pre></td></tr></table></figure>

<p>从上面的例子我们看到，最后一句会报异常，原因 num 的作用域只在循环体内部，外部无效。使用 var 则不会出现上述情况，因为 var 会作用于全局，迭代将不会每次都创建一个新的存储空间。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nums = [<span class="string">"zero"</span>, <span class="string">"one"</span>, <span class="string">"two"</span>];</span><br><span class="line">forv (<span class="keyword">var</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num);</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">console</span>.log(num);</span><br><span class="line"><span class="comment">// output: two</span></span><br></pre></td></tr></table></figure>

<p>~</p>
<p>~</p>
<p>~本文完，感谢阅读！</p>
<p>~</p>
<blockquote>
<p>学习有趣的知识，结识有趣的朋友，塑造有趣的灵魂！</p>
<p>我是〖编程三昧〗的作者 <strong>隐逸王</strong>，我的公众号是『编程三昧』，欢迎关注，希望大家多多指教！</p>
<p>你来，怀揣期望，我有墨香相迎！ 你归，无论得失，唯以余韵相赠！</p>
<p>知识与技能并重，内力和外功兼修，理论和实践两手都要抓、两手都要硬！</p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript - ES6</category>
      </categories>
      <tags>
        <tag>迭代器</tag>
      </tags>
  </entry>
  <entry>
    <title>你真的了解“盒模型”吗？</title>
    <url>/yinyiwang/2021/07/05/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E2%80%9C%E7%9B%92%E6%A8%A1%E5%9E%8B%E2%80%9D%E5%90%97%EF%BC%9F/</url>
    <content><![CDATA[<blockquote>
<p>阅读时间：6min</p>
<p>目标：学习盒模型的基本理论，了解盒装模型的工作原理，了解盒模型与替代模型的区别以及如何进行切换。</p>
<p>前置条件：HTML和CSS基础知识。</p>
</blockquote>
<blockquote>
<p>在 CSS 中，所有的元素都被一个个的“盒子（box）”包围着，理解这些“盒子”的基本原理，是我们使用CSS实现准确布局、处理元素排列的关键。</p>
</blockquote>
<h2 id="什么是CSS-盒模型"><a href="#什么是CSS-盒模型" class="headerlink" title="什么是CSS 盒模型?"></a>什么是CSS 盒模型?</h2><p>完整的 CSS 盒模型应用于块级盒子，内联盒子只使用盒模型中定义的部分内容。模型定义了盒的每个部分 —— margin, border, padding, and content —— 合在一起就可以创建我们在页面上看到的内容。</p>
<a id="more"></a>

<h3 id="盒模型的各个部分"><a href="#盒模型的各个部分" class="headerlink" title="盒模型的各个部分"></a>盒模型的各个部分</h3><p> CSS中组成一个块级盒子需要:</p>
<ul>
<li><strong>Content box</strong><br>  这个区域是用来显示内容，大小可以通过设置 <code>width</code>和 <code>height</code>。</li>
<li><strong>Padding box</strong><br>  包围在内容区域外部的空白区域； 大小通过 <code>padding</code> 相关属性设置。</li>
<li><strong>Border box</strong><br>  边框盒包裹内容和内边距。大小通过 <code>border</code>相关属性设置。</li>
<li><strong>Margin box</strong><br>  这是最外面的区域，是盒子和其他元素之间的空白区域。大小通过 <code>margin</code>相关属性设置。</li>
</ul>
<p>如下图：</p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210602%20/18-55-02-seTlt2.png" alt="Diagram of the box model"></p>
<h3 id="标准盒模型"><a href="#标准盒模型" class="headerlink" title="标准盒模型"></a>标准盒模型</h3><p>在标准模型中，如果你给盒设置 <code>width</code> 和 <code>height</code>，实际设置的是 <em>content box</em>。 padding 和 border 再加上设置的宽高一起决定整个盒子的大小。 见下图。</p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210602%20/18-54-53-1cZ3Ge.jpg" alt="img"></p>
<p>假设定义了 <code>width</code>, <code>height</code>, <code>margin</code>, <code>border</code>, and <code>padding</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">  width: 350px;</span><br><span class="line">  height: 150px;</span><br><span class="line">  margin: 25px;</span><br><span class="line">  padding: 25px;</span><br><span class="line">  border: 5px solid black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果使用标准模型宽度 = 410px (350 + 25 + 25 + 5 + 5)，高度 = 210px (150 + 25 + 25 + 5 + 5)，padding 加 border 再加 content box。</p>
<blockquote>
<p><strong>注</strong>: margin 不计入实际大小 —— 当然，它会影响盒子在页面所占空间，但是影响的是盒子外部空间。盒子的范围到边框为止 —— 不会延伸到margin。</p>
</blockquote>
<h2 id="块级盒子-和-内联盒子"><a href="#块级盒子-和-内联盒子" class="headerlink" title="块级盒子 和 内联盒子"></a>块级盒子 和 内联盒子</h2><p>在 CSS 中我们广泛地使用两种“盒子” —— <strong>块级盒子</strong> (block box) 和 <strong>内联盒子</strong> (inline box)。这两种盒子会在<strong>页面流</strong>（page flow）和<strong>元素之间的关系</strong>方面表现出不同的行为:</p>
<h3 id="块级盒子的特性"><a href="#块级盒子的特性" class="headerlink" title="块级盒子的特性"></a>块级盒子的特性</h3><ul>
<li>盒子会在内联的方向上扩展并占据父容器在该方向上的所有可用空间，在绝大数情况下意味着盒子会和父容器一样宽。</li>
<li>每个盒子都会换行。</li>
<li><code>width</code> 和 <code>height</code> 属性可以发挥作用。</li>
<li>内边距（padding）, 外边距（margin） 和 边框（border） 会将其他元素从当前盒子周围“推开”。</li>
</ul>
<blockquote>
<p>除非特殊指定，诸如标题(<code>&lt;h1&gt;</code>等)和段落(<code>&lt;p&gt;</code>)默认情况下都是块级的盒子。</p>
</blockquote>
<h3 id="内联盒子的特性"><a href="#内联盒子的特性" class="headerlink" title="内联盒子的特性"></a>内联盒子的特性</h3><ul>
<li>盒子不会产生换行。</li>
<li><code>width</code> 和 <code>height</code>属性将不起作用。</li>
<li>垂直方向的内边距、外边距以及边框会被应用但是不会把其他处于 <code>inline</code> 状态的盒子推开。</li>
<li>水平方向的内边距、外边距以及边框会被应用且会把其他处于 <code>inline</code> 状态的盒子推开。</li>
</ul>
<blockquote>
<p>用做链接的 <code>&lt;a&gt;</code> 元素、 <code>&lt;span&gt;</code>、 <code>&lt;em&gt;</code> 以及 <code>&lt;strong&gt;</code> 都是默认处于 <code>inline</code> 状态的。</p>
</blockquote>
<p>我们通过对盒子<code>display</code>属性的设置，比如 <code>inline</code> 或者 <code>block</code> ，来控制盒子的外部显示类型。</p>
<h2 id="补充-内部和外部显示类型"><a href="#补充-内部和外部显示类型" class="headerlink" title="补充: 内部和外部显示类型"></a>补充: 内部和外部显示类型</h2><p>在这里最好也解释下<strong>内部</strong> 和 <strong>外部</strong> 显示类型。如上所述， css的box模型有一个外部显示类型，来决定盒子是块级还是内联。</p>
<p>同样盒模型还有内部显示类型，它决定了盒子内部元素是如何布局的。默认情况下是按照 <strong>正常文档流</strong> 布局，也意味着它们和其他块元素以及内联元素一样(如上所述).</p>
<p>但是，我们可以通过使用类似 <code>flex</code> 的 <code>display</code> 属性值来更改内部显示类型。 如果设置 <code>display: flex</code>，在一个元素上，外部显示类型是 <code>block</code>，但是内部显示类型修改为 <code>flex</code>。 该盒子的所有直接子元素都会成为flex元素，会根据 <strong>弹性盒子</strong>（Flexbox]规则进行布局。</p>
<h2 id="使用浏览器开发工具查案盒模型"><a href="#使用浏览器开发工具查案盒模型" class="headerlink" title="使用浏览器开发工具查案盒模型"></a>使用浏览器开发工具查案盒模型</h2><p>您的 浏览器开发者工具可以使您更容易地理解box模型。如果您在Firefox的DevTools中查看一个元素，您可以看到元素的大小以及它的外边距、内边距和边框。这是一个很好的检查元素大小的方式，可以便捷的判断您的盒子大小是否符合预期 !</p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210602%20/18-57-56-2S8bdm.png" alt="image-20210602185753877"></p>
<blockquote>
<p>学习有趣的知识，结识有趣的朋友，塑造有趣的灵魂！</p>
<p>大家好！我是〖编程三昧〗的作者 <strong>隐逸王</strong>，我的公众号是『编程三昧』，欢迎关注，希望大家多多指教！</p>
</blockquote>
]]></content>
      <categories>
        <category>CSS - 盒模型</category>
      </categories>
      <tags>
        <tag>盒模型</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS 变量简介</title>
    <url>/yinyiwang/2021/07/05/CSS-%E5%8F%98%E9%87%8F%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>复杂的网站都会有大量的CSS代码，通常也会有许多重复的值。</p>
<p>举个例子，同样一个颜色值可能在成千上百个地方被使用到，如果这个值发生了变化，需要全局搜索并且一个一个替换，效率不高且容易出错。</p>
<p>自定义属性在某个地方存储一个值，然后在其他许多地方引用它。另一个好处是语义化的标识。比如，<code>--main-text-color</code> 会比 <code>#00ff00</code> 更易理解，尤其是这个颜色值在其他上下文中也被使用到。</p>
<a id="more"></a>

<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210614%20/21-28-35-hfmmnQ.jpg" alt="css3-scaled"></p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>自定义属性</strong>（有时候也被称作<strong>CSS变量</strong>或者<strong>级联变量</strong>）是由CSS作者定义的，它包含的值可以在整个文档中重复使用。</p>
<p>由自定义属性标记设定值（比如： <strong><code>--main-color: black;</code></strong>），由 var() 函数来获取值（比如： <code>color: **var(--main-color)**;</code>）。</p>
<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>在构建大型站点时，作者通常会面对可维护性的挑战。在这些网页中，所使用的CSS 的数量是非常庞大的，并且在许多场合大量的信息会重复使用。</p>
<p>例如，在网页中维护一个配色方案，意味着一些颜色在 CSS 文件中多次出现，并被重复使用。当你修改配色方案时，不论是调整某个颜色或完全修改整个配色，都会成为一个复杂的问题，不容出错，而单纯查找替换是远远不够的。</p>
<p>如果使用了CSS 框架，这种情况会变得尤其糟糕，此时如果要修改颜色，则需要对框架本身进行修改。</p>
<p>在这些场合使用 LESS 或 Sass 类似的预处理器是非常有帮助的，但是这种通过添加额外步骤的方式，可能会增加系统的复杂性。</p>
<p>CSS变量为我们带来一些预处理器的便利，并且不需要额外的编译。</p>
<p>这些变量的第二个优势就是名称本身就包含了语义的信息。CSS 文件变得易读和理解。main-text-color比文档中的#00ff00更容易理解，特别是同样的颜色出现在不同的文件中的时候。</p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>下面是 CSS 变量的使用方法和步骤。</p>
<h3 id="CSS-中声明变量"><a href="#CSS-中声明变量" class="headerlink" title="CSS 中声明变量"></a>CSS 中声明变量</h3><p>我们都知道，在 JS 中要使用一个变量前，必须声明这个表变量。在 CSS 中也是一样的道理。</p>
<p>声明一个自定义属性，属性名需要以两个减号（<code>--</code>）开始，属性值则可以是任何有效的CSS值。和其他属性一样，自定义属性也是写在规则集之内的，如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">--bg-color</span>: <span class="number">#7F583F</span>;</span><br><span class="line">    <span class="attribute">--color</span>: <span class="number">#F7EFD2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>body</code>选择器里面声明了两个变量：<code>--bg-color</code>和<code>--color</code>。</p>
<p>它们与<code>color</code>、<code>font-size</code>等正式属性没有什么不同，只是没有默认含义。所以 CSS 变量（CSS variable）又叫做<strong>“CSS 自定义属性”</strong>（CSS custom properties）。</p>
<p>规则集所指定的选择器定义了自定义属性的可见作用域。通常的最佳实践是定义在根伪类 <code>:root</code>下，这样就可以在HTML文档的任何地方访问到它了：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">    <span class="attribute">--main-bg-color</span>: <span class="number">#eee</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>自定义属性名是大小写敏感的，<code>--my-color</code> 和 <code>--My-color</code> 会被认为是两个不同的自定义属性。</p>
</blockquote>
<h3 id="CSS-中使用变量"><a href="#CSS-中使用变量" class="headerlink" title="CSS 中使用变量"></a>CSS 中使用变量</h3><p>通过<code>var()</code>函数来读取变量。语法如下:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">var</span>(<span class="selector-tag">custom-property-name</span>, <span class="selector-tag">value</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p><em>name (必需)</em>    变量名（以两条破折号开头）。</p>
</li>
<li><p><em>value (可选)</em>    表示变量的默认值。如果该变量不存在，就会使用这个默认值。</p>
</li>
</ul>
<blockquote>
<p>变量名称必须以两个破折号（–）开头，且区分大小写！</p>
</blockquote>
<p>使用方法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">element</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">var</span>(--main-bg-color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变量也可以使用在变量声明中：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">  <span class="attribute">--primary-color</span>: <span class="number">#eee</span>;</span><br><span class="line">  <span class="attribute">--primary-bg-color</span>: <span class="built_in">var</span>(--main-bg-color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>变量值只能用作属性值，不能用作属性名。</p>
</blockquote>
<h3 id="JS-操作-CSS-变量"><a href="#JS-操作-CSS-变量" class="headerlink" title="JS 操作 CSS 变量"></a>JS 操作 CSS 变量</h3><p>在 JS 代码中，我们可能需要读取 CSS 变量的值，其方法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> root = <span class="built_in">document</span>.querySelector(<span class="string">":root"</span>);</span><br><span class="line"><span class="comment">// 设置 CSS 变量</span></span><br><span class="line">root.style.setProperty(<span class="string">"--main-bg-color"</span>, <span class="string">"red"</span>);</span><br><span class="line"><span class="comment">// 读取 CSS 变量</span></span><br><span class="line"><span class="keyword">const</span> computedStyle = getComputedStyle(root);</span><br><span class="line"><span class="keyword">const</span> mainBgColor = computedStyle.getPropertyValue(<span class="string">"--main-bg-color"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(mainBgColor);</span><br><span class="line"><span class="comment">// 删除 CSS 变量</span></span><br><span class="line">root.style.removeProperty(<span class="string">"--main-bg-color"</span>);</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是关于 CSS 变量的一些基本概念及使用方法，更多详情待后续！</p>
<p>灵活使用 CSS 变量，不仅可以提高生产力，也能够提高代码的可阅读性和维护性。</p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210614%20/21-29-00-By56Pn.png" alt="hero"></p>
<p>~</p>
<p>~</p>
<p>~ 本文完</p>
<blockquote>
<p>学习有趣的知识，结识有趣的朋友，塑造有趣的灵魂！</p>
<p>大家好！我是〖编程三昧〗的作者 <strong>隐逸王</strong>，我的公众号是『编程三昧』，欢迎关注，希望大家多多指教！</p>
<p>知识与技能并重，内力和外功兼修，理论和实践两手都要抓、两手都要硬！</p>
</blockquote>
]]></content>
      <categories>
        <category>CSS - CSS 变量</category>
      </categories>
      <tags>
        <tag>CSS 变量</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 中数组 sort() 方法的基本使用</title>
    <url>/yinyiwang/2021/07/05/JavaScript-%E4%B8%AD%E6%95%B0%E7%BB%84-sort-%E6%96%B9%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210608%20/17-41-29-iWvHDi.jpg" alt="cocktails-3252160_1920"></p>
<blockquote>
<p>在日常的代码开发中，关于数组排序的操作可不少，JavaScript 中可以调用 <code>sort</code> 方法对数组进行快速排序。</p>
</blockquote>
<a id="more"></a>

<p>今天，就数组的 <code>sort</code> 方法来学习一下，避免日后踩坑的悲惨遭遇。</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>sort 方法用于对数组的元素进行排序。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.sort([compareFunction])</span><br></pre></td></tr></table></figure>

<h4 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h4><p><strong>compareFunction</strong> (可选)</p>
<p>用来指定按某种顺序进行排列的函数。该函数有两个参数：</p>
<ul>
<li><strong>firstEl</strong>    第一个比较的元素</li>
<li><strong>secondEl</strong>    第二个比较的元素</li>
</ul>
<blockquote>
<p>该函数如果省略，元素按照转换为的字符串的各个字符的<strong>Unicode位点</strong>进行排序。</p>
</blockquote>
<h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>排序后的数组。</p>
<blockquote>
<p>请注意，数组已原地排序，并且不进行复制。</p>
</blockquote>
<h3 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h3><p>犹记得当年第一次使用数组排序的场景：查到有个 sort 方法后，赶紧用起来， 结果……，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">49</span>, <span class="number">5</span>, <span class="number">14</span>, <span class="number">89</span>, <span class="number">71</span>, <span class="number">3</span>, <span class="number">10</span>];</span><br><span class="line">arr.sort();</span><br><span class="line"><span class="comment">// 输出  [10, 14, 3, 49, 5, 71, 89]</span></span><br></pre></td></tr></table></figure>

<p>看到结果的瞬间，整个人有点方了。</p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210608%20/18-34-50-6RUn7b.jpg" alt="查看源图像"></p>
<p>这就有点不讲武德了，说好的排序呢？再三确认我的机器没毛病后，赶紧查文档，看看文档怎么说：</p>
<blockquote>
<p>如果没有指明 <code>compareFunction</code> ，那么元素会按照转换为的字符串的逐个字符的<a href="https://baike.baidu.com/item/%E7%BB%9F%E4%B8%80%E7%A0%81/2985798?fromtitle=Unicode&fromid=750500" target="_blank" rel="noopener"><strong>Unicode位点</strong></a>进行排序。</p>
</blockquote>
<p>这么一解释的话，上面数组的排序可以作一下理解：</p>
<ol>
<li><p>首先，将数组里的数字逐个转换为字符串，得到 <code>[&#39;49&#39;, &#39;5&#39;, &#39;14&#39;, &#39;89&#39;, &#39;71&#39;, &#39;3&#39;, &#39;10&#39;]</code> 。</p>
</li>
<li><p>再按照首位的字符的 Unicode 位点来算的话：</p>
<ul>
<li><p>1 的编码在 3 之前，所以 10 和 14 排在了 3 之前</p>
</li>
<li><p>3 的编码在 4 之前，所以 49 排在了 3 的后面</p>
<p>  ……</p>
<blockquote>
<p>如果首位字符的编码相同，则比较第二位字符的编码，比如 10 排在了 14之前（0 和 4 的比较结果）</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<p>道理貌似是通了，但是这不是我想要的结果，看来还是得靠比较函数 <code>compareFunction</code> ，我们来看看这个 <code>compareFunction</code> 到底是何方神圣。</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>基本用例如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">49</span>, <span class="number">5</span>, <span class="number">14</span>, <span class="number">89</span>, <span class="number">71</span>, <span class="number">3</span>, <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般写法</span></span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;   <span class="comment">// 按照升序排列 </span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line">arr.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果  [3, 5, 10, 14, 49, 71, 89]</span></span><br></pre></td></tr></table></figure>

<p>以上是按照<strong>升序排列</strong>的写法，如果要按照降序排列，只需把比较函数中的 <code>return a - b;</code> 改为 <code>return b - a;</code>。</p>
<h3 id="对象数组排序"><a href="#对象数组排序" class="headerlink" title="对象数组排序"></a>对象数组排序</h3><p><code>sort()</code> 方法除了可以用于数字数组和字符数组的排序外，还可用于对象数组的排序：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> items = [</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">'Edward'</span>, <span class="attr">value</span>: <span class="number">21</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">'Sharpe'</span>, <span class="attr">value</span>: <span class="number">37</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">'And'</span>, <span class="attr">value</span>: <span class="number">45</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">'The'</span>, <span class="attr">value</span>: <span class="number">-12</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">'Magnetic'</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">'Zeros'</span>, <span class="attr">value</span>: <span class="number">37</span>&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// sort by value</span></span><br><span class="line">items.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a.value - b.value)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// sort by name</span></span><br><span class="line">items.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> nameA = a.name.toUpperCase(); <span class="comment">// ignore upper and lowercase</span></span><br><span class="line">    <span class="keyword">var</span> nameB = b.name.toUpperCase(); <span class="comment">// ignore upper and lowercase</span></span><br><span class="line">    <span class="keyword">if</span> (nameA &lt; nameB) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nameA &gt; nameB) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// names must be equal</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="对非-ASCII-字符排序"><a href="#对非-ASCII-字符排序" class="headerlink" title="对非 ASCII 字符排序"></a>对非 ASCII 字符排序</h3><p>当排序非 ASCII 字符的字符串（如包含类似 e, é, è, a, ä 等字符的字符串）。一些非英语语言的字符串需要使用 <code>String.localeCompare</code>。这个函数可以将函数排序到正确的顺序。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> items = [<span class="string">'réservé'</span>, <span class="string">'premier'</span>, <span class="string">'cliché'</span>, <span class="string">'communiqué'</span>, <span class="string">'café'</span>, <span class="string">'adieu'</span>];</span><br><span class="line">items.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.localeCompare(b);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// items is ['adieu', 'café', 'cliché', 'communiqué', 'premier', 'réservé']</span></span><br></pre></td></tr></table></figure>

<h3 id="使用映射改善排序"><a href="#使用映射改善排序" class="headerlink" title="使用映射改善排序"></a>使用映射改善排序</h3><p><code>compareFunction</code> 可能需要对元素做多次映射以实现排序，尤其当 <code>compareFunction</code> 较为复杂，且元素较多的时候，某些 <code>compareFunction</code> 可能会导致很高的负载。使用 map 辅助排序将会是一个好主意。基本思想是首先将数组中的每个元素比较的实际值取出来，排序后再将数组恢复。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需要被排序的数组</span></span><br><span class="line"><span class="keyword">var</span> list = [<span class="string">'Delta'</span>, <span class="string">'alpha'</span>, <span class="string">'CHARLIE'</span>, <span class="string">'bravo'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对需要排序的数字和位置的临时存储</span></span><br><span class="line"><span class="keyword">var</span> mapped = list.map(<span class="function"><span class="keyword">function</span>(<span class="params">el, i</span>) </span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> &#123; <span class="attr">index</span>: i, <span class="attr">value</span>: el.toLowerCase() &#125;;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照多个值排序数组</span></span><br><span class="line">mapped.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> +(a.value &gt; b.value) || +(a.value === b.value) - <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据索引得到排序的结果</span></span><br><span class="line"><span class="keyword">var</span> result = mapped.map(<span class="function"><span class="keyword">function</span>(<span class="params">el</span>)</span>&#123;</span><br><span class="line">  	<span class="keyword">return</span> list[el.index];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>本文完，感谢阅读！</p>
<blockquote>
<p>学习有趣的知识，结识有趣的朋友，塑造有趣的灵魂！</p>
<p>大家好！我是〖编程三昧〗的作者 <strong>隐逸王</strong>，我的公众号是『编程三昧』，欢迎关注，希望大家多多指教！</p>
<p>知识与技能并重，内力和外功兼修，理论和实践两手都要抓、两手都要硬！</p>
</blockquote>
<p>~</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>数组 sort</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 实现输出斐波那契数列</title>
    <url>/yinyiwang/2021/07/05/JavaScript-%E5%AE%9E%E7%8E%B0%E8%BE%93%E5%87%BA%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<blockquote>
<p>问渠那得清如许，为有源头活水来。</p>
</blockquote>
<p>想要保持自己的技术活力，最有效的手段就是通过不断地输入来提供足够的养分。我们也不必刻意追求高深的或者新鲜的知识点，通过对一个基础问题的全方位多维度解析，同样也会收获不小。</p>
<a id="more"></a>

<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210625%20/18-58-21-En8h2e.jpeg" alt="发散思维"></p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>有这么一道题目需要我们来解答：</p>
<ul>
<li>试输出斐波那契数列的前10项，即 1、1、2、3、5、8、13、21、34、55。</li>
</ul>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>有些人看到题目中出现了“斐波那契数列”这个概念后，可能脑袋就蒙圈了，其实大可不必！</p>
<p>对于这道题，可以不用理会这个陌生概念，我们只需要关心后面它给出的数字规律即可。</p>
<p>我们可以看到，规律总结起来就一句话：<strong>从第三位开始，后面每项的值等于前两项之和</strong>，用式子表示的话就是：a<del>n</del> = a<del>n-1</del> + a<del>n-2</del>（n ≥ 2） 。</p>
<p>根据题目要求，其实就是要我们做两件事：</p>
<ol>
<li>生成每一项的值。</li>
<li>打印输出所有值。</li>
</ol>
<h2 id="基础解法"><a href="#基础解法" class="headerlink" title="基础解法"></a>基础解法</h2><p><strong>解题思路：</strong></p>
<ul>
<li>创建一个数组存放数列各项的值。</li>
<li>for 循环生成数列各项并存入数组（为了计算后面各项的值），打印生成的项。</li>
</ul>
<p><strong>代码实现如下：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>创建一个生成数列数组的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> </span>n 表示要生成多少项（即数组长度，不是数组下标）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFibArr</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 声明一个存放数据的数组</span></span><br><span class="line">    <span class="keyword">let</span> fibArr = [];</span><br><span class="line">    <span class="comment">// 从第三项(下标为2)开始，每一项都等于前两项之和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; n; index++) &#123;</span><br><span class="line">        index &lt; <span class="number">2</span> ? fibArr.push(<span class="number">1</span>) : fibArr.push(fibArr[index - <span class="number">1</span>] + fibArr[index - <span class="number">2</span>]);</span><br><span class="line">        <span class="built_in">console</span>.log(fibArr[index]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方法</span></span><br><span class="line">createFibArr(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong></p>
<p>这应该是最基本的解题方法，很容易就实现了。</p>
<p>但如果这是面试题的话，这样的答案只能说是中规中矩，没有出彩的地方，最重要的是体现不出我们与众不同的气质啊，所以，我们应该用点其他的手段来提升下自己的逼格！</p>
<h2 id="初级递归"><a href="#初级递归" class="headerlink" title="初级递归"></a>初级递归</h2><p><strong>解题思路：</strong></p>
<ul>
<li>通过递归的手段计算出各位置对应的值（这里有个前提是：第一项和第二项是确定值，否则，递归就不好用了）。</li>
<li>打印结果。</li>
</ul>
<p><strong>代码实现如下：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>计算出第 n 项的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> </span>n 表示每一项的下标值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;number&#125;</span> </span>下标为 n 的位置的值 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calFibValue</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.count(<span class="string">"执行次数："</span>)</span><br><span class="line">    <span class="keyword">return</span> n &lt; <span class="number">2</span> ? <span class="number">1</span> : (calFibValue(n - <span class="number">1</span>) + calFibValue(n - <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>打印计算结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> </span>n 代表要打印多少项</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printRes</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; n; index++) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(calFibValue(index));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用打印方法</span></span><br><span class="line">printRes(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行次数：: 276</span></span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong></p>
<p>递归的使用确实提升了代码的逼格，但是又引来了另外一个问题：性能问题。</p>
<p>每一项的值都是从第一项开始计算累加 出来的，比如计算第四项的值，其过程如下：</p>
<ol>
<li>返回第一项的值：1 。</li>
<li>返回第二项的值： 1 。</li>
<li>计算第三项的值为 1 + 1 = 2 。</li>
<li>计算第四项的值为 2 + 1 = 3 。</li>
</ol>
<p>在计算第五项值的时候，还要经过上面这个过程来获取第四项的值，进行了大量的重复运算。</p>
<p>为了惊艳面试官，我们还需要再做优化！</p>
<h2 id="递归优化"><a href="#递归优化" class="headerlink" title="递归优化"></a>递归优化</h2><p><strong>解题思路：</strong></p>
<ul>
<li><p>导致重复计算的是递归那部分的逻辑，所以优化点在递归这里。</p>
</li>
<li><p>既然存在重复运算，那就意味着其实后面的运算完全可以使用前面已经计算出来的值，所以我们需要引入缓存来保存每次的计算结果。</p>
</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>计算出第 n 项的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> </span>n 表示每一项的下标值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;number&#125;</span> </span>下标为 n 的位置的值 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 存放每次计算结果的 Map 结构</span></span><br><span class="line"><span class="comment">// 这里也可以用数组，但是在语义方面没有 Map 或对象直接</span></span><br><span class="line"><span class="keyword">let</span> fibValueMap = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calFibValue</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.count(<span class="string">"执行次数："</span>);</span><br><span class="line">    <span class="comment">// 如果缓存中已存在对应的值，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (fibValueMap.has(n)) &#123;</span><br><span class="line">        <span class="keyword">return</span> fibValueMap.get(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> value = n &lt; <span class="number">2</span> ? <span class="number">1</span> : (calFibValue(n - <span class="number">1</span>) + calFibValue(n - <span class="number">2</span>));</span><br><span class="line">    <span class="comment">// 在计算出每一项的之后，需要及时存入 Map</span></span><br><span class="line">    fibValueMap.set(n, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>打印计算结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> </span>n 代表要打印多少项</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printRes</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; n; index++) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(calFibValue(index));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用打印方法</span></span><br><span class="line">printRes(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行次数：: 26</span></span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong></p>
<p>根据打印出来的 count 来看，优化后的递归次数是优化前的 1/10 左右，这个结果就很惊喜了。</p>
<p>这次面试官应该可以满意了吧。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>万变不离其宗，只要将解题思路理清了，代码实现只是一个结果而已。在平常的工作学习中，我们要有意识地培养自己的发散性思维，从多角度去看待问题，你可能会发现不一样的风景哦！希望能够对大家有所启发哦！</p>
<p>在面试中，为了突显自己的独特气质或者人家面试题目就有具体要求的，我们使用一些看起来高大上的思路，这无可厚非。</p>
<p>但是呢，在平常的工作中，我还是更建议大家：在性能相近的情况下，能使用基础方法解决的一般不要用“高档”方法，因为基础方法出错的概率小很多。就比如今天这道题，其实基础解法的性能是最好的。</p>
<p>少写 BUG，我们才能有更多的时间来摸鱼，不是吗？</p>
<p>~</p>
<p>~ 本文完，感谢阅读！</p>
<p>~</p>
<blockquote>
<p>学习有趣的知识，结识有趣的朋友，塑造有趣的灵魂！</p>
<p>我是〖编程三昧〗的作者 <strong>隐逸王</strong>，我的公众号是『编程三昧』，欢迎关注，希望大家多多指教！</p>
<p>你来，怀揣期望，我有墨香相迎！ 你归，无论得失，唯以余韵相赠！</p>
<p>知识与技能并重，内力和外功兼修，理论和实践两手都要抓、两手都要硬！</p>
</blockquote>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210625%20/18-59-01-TOFScw.jpeg" alt="发散思维"></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>代码实现</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6 中的 Symbol 是什么？</title>
    <url>/yinyiwang/2021/07/05/ES6-%E4%B8%AD%E7%9A%84-Symbol-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>记得刚找工作那会，几种数据类型是必问题，当时的答案一般都是七种——字符串（String）、数字(Number)、布尔(Boolean)、数组(Array)、对象(Object)、空（Null）、未定义（Undefined），时至今日，某些网络教程上还是这样的分类：</p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210624%20/17-53-24-Fpqfvk.png" alt="不完整的分类"></p>
<p>其实，随着 ECMAScript 的发展和完善，在 ES6(2015) 和 ES11(2020) 中，又分别增加了 Symbol 和 BigInt 两种类型，所以，完整的分类应该是下面这样的：</p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210624%20/18-02-52-ySP1Bs.png" alt="完整的数据类型"></p>
<p>今天，我们就来看看 Symbol 到底是什么类型，为何要引入这样一个类型。</p>
<a id="more"></a>

<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们都应该有个清晰的认识：任何新技术或者新概念的出现，必然是为了解决某一痛点的。</p>
<p>想想吧，我们为了起一个漂亮的、符合语义规则的属性名而绞尽脑汁时的痛苦，还要承受属性名可能冲突的折磨，那是一段不堪回首的往事！</p>
<p>而 Symbol 的出现正是为了拯救我们的头发，让它们不至于牺牲在这些琐碎的小事上，它们每一根都是那么珍贵，它们的归宿应该在更具价值的地方！</p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210624%20/18-23-03-qoG5UA.jpeg" alt="头发证的会掉完"></p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>symbol 是一种基本数据类型。Symbol() 函数会返回 symbol 类型的值，该类型具有静态属性和静态方法。它的静态属性会暴露几个内建的成员对象；它的静态方法会暴露全局的 symbol 注册，且类似于内建对象类，但作为构造函数来说它并不完整，因为它不支持语法：”<code>new Symbol()</code>“。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>直接使用 <code>Symbol()</code> 创建新的 symbol 类型，并用一个可选的字符串作为其描述。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Symbol</span>([description])</span><br></pre></td></tr></table></figure>

<ul>
<li>description     (可选)    字符串类型。对symbol的描述，可用于调试但不是访问symbol本身。请注意，即使传入两个相同的字符串，得到的 symbol 也不相等。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> symbol1 = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> symbol2 = <span class="built_in">Symbol</span>(<span class="number">42</span>);</span><br><span class="line"><span class="keyword">const</span> symbol3 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> symbol1);</span><br><span class="line"><span class="comment">// expected output: "symbol"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(symbol2 === <span class="number">42</span>);</span><br><span class="line"><span class="comment">// expected output: false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(symbol3.toString());</span><br><span class="line"><span class="comment">// expected output: "Symbol(foo)"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>(<span class="string">'foo'</span>) === <span class="built_in">Symbol</span>(<span class="string">'foo'</span>));</span><br><span class="line"><span class="comment">// expected output: false</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的代码创建了三个新的 symbol 类型。 注意，<code>Symbol(&quot;foo&quot;)</code>  不会强制将字符串 “foo” 转换成 symbol 类型。它每次都会创建一个新的 symbol 类型。</p>
</blockquote>
<p>下面带有 new 运算符的语法将抛出 TypeError 运算符的语法将抛出错误：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sym = <span class="keyword">new</span> <span class="built_in">Symbol</span>(); <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>

<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>正如歌词“每个人都有他的脾气”所说，Symbol 也有它自己的特性：</p>
<ol>
<li><strong>没有两个 Symbol 的值是相等的</strong>。就像“世上没有两片相同的叶子”一样，任何两个 Symbol 数据的值都不会相等。</li>
<li><strong>Symbol 数据值可以作为对象属性名</strong>。高手一出手，就知有没有。这一下子就奠定了 Symbol 的江湖地位。要知道，在之前，对象的属性名是字符串的专属权利，就连数字也会被同化为字符串，可现在居然被 Symbol 虎口夺食，字符串大概也只能黯然伤神了吧。</li>
</ol>
<h2 id="用涂"><a href="#用涂" class="headerlink" title="用涂"></a>用涂</h2><p>根据 Symbol 的特性，它有以下通途。</p>
<h3 id="命名冲突"><a href="#命名冲突" class="headerlink" title="命名冲突"></a>命名冲突</h3><p>JavaScript 内置了一个 symbol ，那就是 ES6 中的 Symbol.iterator。拥有 Symbol.iterator 函数的对象被称为 可迭代对象 ，就是说你可以在对象上使用 for/of 循环。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fibonacci = &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">yield</span> b;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            temp = a;</span><br><span class="line">            a = a + b;</span><br><span class="line">            b = temp;</span><br><span class="line">            <span class="keyword">yield</span> b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prints every Fibonacci number less than 100</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> fibonacci) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么这里要用 Symbol.iterator  而不是字符串？假设不用 Symbol.iterator ，可迭代对象需要有一个字符串属性名 ‘iterator’，就像下面这个可迭代对象的类：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> (obj) &#123;</span><br><span class="line">        <span class="built_in">Object</span>.assign(<span class="keyword">this</span>, obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    iterator() &#123;</span><br><span class="line">        <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= keys.length) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">yield</span> keys[i++];</span><br><span class="line">        &#125;)();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MyClass  的实例是可迭代对象，可以遍历对象上面的属性。但是上面的类有个潜在的缺陷，假设有个恶意用户给 MyClass 构造函数传了一个带有 iterator 属性的对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> MyClass(&#123; <span class="attr">iterator</span>: <span class="string">'not a function'</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>这样你在 obj 上使用 for/of 的话，JavaScript 会抛出 TypeError: obj is not iterable 异常。</p>
<p>可以看出，传入对象的  iterator 函数覆盖了类的  iterator 属性。</p>
<p>这有点类似原型污染的安全问题，无脑复制用户数据会对一些特殊属性，比如 <strong>proto</strong> 和 constructor 带来问题。</p>
<p>这里的核心在于，symbol 让对象的内部数据和用户数据井水不犯河水。</p>
<p>由于 sysmbol 无法在  JSON 里表示，因此不用担心给 Express API 传入带有不合适的 Symbol.iterator 属性的数据。另外，对于那种混合了内置函数和用户数据的对象，你可以用 symbol 来确保用户数据不会跟内置属性冲突。</p>
<h3 id="私有属性"><a href="#私有属性" class="headerlink" title="私有属性"></a>私有属性</h3><p>由于任何两个 symbol 都是不相等的，在 JavaScript 里可以很方便地用来模拟私有属性。symbol`  不会出现在 Object.keys() 的结果中，因此除非你明确地 export 一个 symbol，或者用 Object.getOwnPropertySymbols() 函数获取，否则其他代码无法访问这个属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getObj</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> symbol = <span class="built_in">Symbol</span>(<span class="string">'test'</span>);</span><br><span class="line">    <span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">    obj[symbol] = <span class="string">'test'</span>;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = getObj();</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(obj); <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 除非有这个 symbol 的引用，否则无法访问该属性</span></span><br><span class="line">obj[<span class="built_in">Symbol</span>(<span class="string">'test'</span>)]; <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 getOwnPropertySymbols() 依然可以拿到 symbol 的引用</span></span><br><span class="line"><span class="keyword">const</span> [symbol] = <span class="built_in">Object</span>.getOwnPropertySymbols(obj);</span><br><span class="line">obj[symbol]; <span class="comment">// 'test'</span></span><br></pre></td></tr></table></figure>

<p>还有一个原因是 symbol 不会出现在 <code>JSON.stringify()</code> 的结果里，确切地说是<code>JSON.stringify()</code>会忽略<code>symbol</code>属性名和属性值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> symbol = <span class="built_in">Symbol</span>(<span class="string">'test'</span>);</span><br><span class="line"><span class="keyword">const</span> obj = &#123; [symbol]: <span class="string">'test'</span>, <span class="attr">test</span>: symbol &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.stringify(obj); <span class="comment">// "&#123;&#125;"</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>symbol 具有以下特性：</p>
<ul>
<li>每个 symbol 都是独一无二的。</li>
<li>symbol 可用作对象名称。</li>
</ul>
<p>~</p>
<p>~</p>
<p>~ 本文完，感谢阅读！</p>
<p>~</p>
<blockquote>
<p>学习有趣的知识，结识有趣的朋友，塑造有趣的灵魂！</p>
<p>我是〖编程三昧〗的作者 <strong>隐逸王</strong>，我的公众号是『编程三昧』，欢迎关注，希望大家多多指教！</p>
<p>你来，怀揣期望，我有墨香相迎！ 你归，无论得失，唯以余韵相赠！</p>
<p>知识与技能并重，内力和外功兼修，理论和实践两手都要抓、两手都要硬！</p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript - ES6</category>
      </categories>
      <tags>
        <tag>Symbol</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS 选择器总结</title>
    <url>/yinyiwang/2021/07/05/CSS-%E9%80%89%E6%8B%A9%E5%99%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<blockquote>
<p>CSS 是用于网页设计可用的最强大的工具之一。使用它我们可以在几分钟内改变一个网站的界面，而不用改变页面的标签。</p>
</blockquote>
<p>好一段时间不用 CSS ，有一些基础知识的记忆有点模糊了，今天再做一次总结记录，方便日后回顾复习。</p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210613%20/20-30-45-EFPj9a.png" alt="iShot2021-06-13 20.28.32"></p>
<a id="more"></a>

<h2 id="选择器分类"><a href="#选择器分类" class="headerlink" title="选择器分类"></a>选择器分类</h2><p>在 CSS 中，选择器可分为以下几类：</p>
<ul>
<li>基本选择器（通配选择器、元素选择器、类选择器、ID 选择器、群组选择器）</li>
<li>层次选择器</li>
<li>属性选择器</li>
<li>伪类选择器</li>
<li>伪元素</li>
</ul>
<p>基本选择器比较好记，这里就不浪费篇幅，主要是记录一下后三、几种选择器。</p>
<h2 id="层次选择器"><a href="#层次选择器" class="headerlink" title="层次选择器"></a>层次选择器</h2><table>
<thead>
<tr>
<th><strong>选择器</strong></th>
<th><strong>类型</strong></th>
<th><strong>功能描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>E  F</td>
<td>后代选择器（包含选择器）</td>
<td>选择匹配的F元素，且匹配的F元素被包含在匹配的E元素内</td>
</tr>
<tr>
<td>E&gt;F</td>
<td>子元素选择器</td>
<td>选择匹配的F元素，且匹配的F元素所匹配的E元素的子元素</td>
</tr>
<tr>
<td>E+F</td>
<td>相邻兄弟选择器</td>
<td>选择匹配的F元素，且匹配的F元素紧位于匹配的E元素的后面</td>
</tr>
<tr>
<td>E~F</td>
<td>通用选择器</td>
<td>选择匹配的F元素，且位于匹配的E元素后的所有匹配的F元素</td>
</tr>
</tbody></table>
<ul>
<li>在后代选择器中，规则左边的选择器一端包括两个或多个用空格分隔的选择器。选择器之间的空格是一种结合符（combinator）。每个空格结合符可以解释为“… 在 … 找到”、“… 作为 … 的一部分”、“… 作为 … 的后代”，但是要求必须从右向左读选择器。</li>
<li>如果不希望选择任意的后代元素，而是希望缩小范围，只选择某个元素的<strong>直接子元素</strong>，请使用子元素选择器（Child selector）。</li>
<li>如果需要选择紧接在另一个元素后的元素，而且二者有相同的父元素，可以使用相邻兄弟选择器（Adjacent sibling selector）。</li>
</ul>
<h2 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h2><table>
<thead>
<tr>
<th><strong>选择器</strong></th>
<th><strong>功能描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>[<em>attribute</em>]</td>
<td>用于选取带有指定属性的元素。</td>
</tr>
<tr>
<td>[<em>attribute</em>=<em>value</em>]</td>
<td>用于选取带有指定属性和值的元素。</td>
</tr>
<tr>
<td>[<em>attribute</em>~=<em>value</em>]</td>
<td>用于选取属性值中包含指定词汇的元素。</td>
</tr>
<tr>
<td>[<em>attribute</em>|=<em>value</em>]</td>
<td>用于选取带有以指定值开头的属性值的元素，该值必须是整个单词。</td>
</tr>
<tr>
<td>[<em>attribute</em>^=<em>value</em>]</td>
<td>匹配属性值以指定值开头的每个元素。</td>
</tr>
<tr>
<td>[<em>attribute</em>$=<em>value</em>]</td>
<td>匹配属性值以指定值结尾的每个元素。</td>
</tr>
<tr>
<td>[<em>attribute*</em>=<em>value</em>]</td>
<td>匹配属性值中包含指定值的每个元素。</td>
</tr>
</tbody></table>
<p>如果希望选择有某个属性的元素，而不论属性值是什么，可以使用简单属性选择器：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href]</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>还可以根据多个属性进行选择，只需将属性选择器链接在一起即可:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href]</span><span class="selector-attr">[title]</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>除了选择拥有某些属性的元素，还可以进一步缩小选择范围，只选择有特定属性值的元素:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href=<span class="string">'www.abc.com'</span>]</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>也可以把多个属性-值选择器链接在一起来选择一个文档：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href=<span class="string">"www.abc.com"</span>]</span><span class="selector-attr">[title=<span class="string">"abc"</span>]</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h2><h3 id="动态伪类选择器"><a href="#动态伪类选择器" class="headerlink" title="动态伪类选择器"></a>动态伪类选择器</h3><table>
<thead>
<tr>
<th><strong>选择器</strong></th>
<th><strong>类型</strong></th>
<th><strong>功能描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>E:link</td>
<td>链接伪类选择器</td>
<td>选择匹配的E元素，而且匹配元素被定义了超链接并未被访问过。常用于链接锚点上</td>
</tr>
<tr>
<td>E:visited</td>
<td>链接伪类选择器</td>
<td>选择匹配的E元素，而且匹配元素被定义了超链接并已被访问过。常用于链接锚点上</td>
</tr>
<tr>
<td>E:active</td>
<td>用户行为选择器</td>
<td>选择匹配的E元素，且匹配元素被激活。常用于链接锚点和按钮上</td>
</tr>
<tr>
<td>E:hover</td>
<td>用户行为选择器</td>
<td>选择匹配的E元素，且用户鼠标停留在元素E上。</td>
</tr>
<tr>
<td>E:focus</td>
<td>用户行为选择器</td>
<td>选择匹配的E元素，而且匹配元素获取焦点</td>
</tr>
</tbody></table>
<h3 id="目标伪类选择器"><a href="#目标伪类选择器" class="headerlink" title="目标伪类选择器"></a>目标伪类选择器</h3><table>
<thead>
<tr>
<th><strong>选择器</strong></th>
<th><strong>功能描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>E:target</td>
<td>选择匹配E的所有元素，且匹配元素被相关URL指向</td>
</tr>
</tbody></table>
<h3 id="UI元素状态伪类选择器"><a href="#UI元素状态伪类选择器" class="headerlink" title="UI元素状态伪类选择器"></a>UI元素状态伪类选择器</h3><table>
<thead>
<tr>
<th><strong>选择器</strong></th>
<th><strong>类型</strong></th>
<th><strong>功能描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>E:checked</td>
<td>选中状态伪类选择器</td>
<td>匹配选中的复选按钮或者单选按钮表单元素</td>
</tr>
<tr>
<td>E:enabled</td>
<td>启用状态伪类选择器</td>
<td>匹配所有启用的表单元素</td>
</tr>
<tr>
<td>E:disabled</td>
<td>不可用状态伪类选择器</td>
<td>匹配所有禁用的表单元素</td>
</tr>
</tbody></table>
<h3 id="结构伪类选择器"><a href="#结构伪类选择器" class="headerlink" title="结构伪类选择器"></a>结构伪类选择器</h3><table>
<thead>
<tr>
<th><strong>选择器</strong></th>
<th><strong>功能描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>E:first-child</td>
<td>作为父元素的第一个子元素的元素E。与E:nth-child(1)等同</td>
</tr>
<tr>
<td>E:last-child</td>
<td>作为父元素的最后一个子元素的元素E。与E:nth-last-child(1)等同</td>
</tr>
<tr>
<td>E:root</td>
<td>选择匹配元素E所在文档的根元素。在HTML文档中，根元素始终是html，此时该选择器与html类型选择器匹配的内容相同</td>
</tr>
<tr>
<td>E F:nth-child(n)</td>
<td>选择父元素E的第n个子元素F。其中n可以是整数（1，2，3）、关键字（even，odd）、可以是公式（2n+1）,而且n值起始值为1，而不是0.</td>
</tr>
<tr>
<td>E F:nth-last-child(n)</td>
<td>选择父元素E的倒数第n个子元素F。此选择器与E:nth-child(n)选择器计算顺序刚好相反，但使用方法都是一样的，其中：nth-last-child(1)始终匹配最后一个元素，与last-child等同</td>
</tr>
<tr>
<td>E:nth-of-type(n)</td>
<td>选择父元素内具有指定类型的第n个E元素</td>
</tr>
<tr>
<td>E:nth-last-of-type(n)</td>
<td>选择父元素内具有指定类型的倒数第n个E元素</td>
</tr>
<tr>
<td>E:first-of-type</td>
<td>选择父元素内具有指定类型的第一个E元素，与E:nth-of-type(1)等同</td>
</tr>
<tr>
<td>E:last-of-type</td>
<td>选择父元素内具有指定类型的最后一个E元素，与E:nth-last-of-type(1)等同</td>
</tr>
<tr>
<td>E:only-child</td>
<td>选择父元素只包含一个子元素，且该子元素匹配E元素</td>
</tr>
<tr>
<td>E:only-of-type</td>
<td>选择父元素只包含一个同类型子元素，且该子元素匹配E元素</td>
</tr>
<tr>
<td>E:empty</td>
<td>选择没有子元素的元素，而且该元素也不包含任何文本节点</td>
</tr>
</tbody></table>
<h3 id="否定伪类选择器"><a href="#否定伪类选择器" class="headerlink" title="否定伪类选择器"></a>否定伪类选择器</h3><table>
<thead>
<tr>
<th><strong>选择器</strong></th>
<th><strong>功能描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>E:not(F)</td>
<td>匹配所有除元素F外的E元素</td>
</tr>
</tbody></table>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>CSS 可以说是前端的基本技能，希望我们都能够通过 CSS 为自己绘制色彩缤纷的前端生涯！</p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210613%20/20-39-31-5hZePq.jpeg" alt="R306077b248fb71ff74b4425dad52507d"></p>
<p>~</p>
<p>~</p>
<p>~ 本文完</p>
<blockquote>
<p>学习有趣的知识，结识有趣的朋友，塑造有趣的灵魂！</p>
<p>大家好！我是〖编程三昧〗的作者 <strong>隐逸王</strong>，我的公众号是『编程三昧』，欢迎关注，希望大家多多指教！</p>
<p>知识与技能并重，内力和外功兼修，理论和实践两手都要抓、两手都要硬！</p>
</blockquote>
]]></content>
      <categories>
        <category>CSS - CSS 选择器</category>
      </categories>
      <tags>
        <tag>CSS 选择器</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 获取字符串中出现最多次的字符</title>
    <url>/yinyiwang/2021/07/05/JavaScript-%E8%8E%B7%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%9C%80%E5%A4%9A%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/</url>
    <content><![CDATA[<blockquote>
<p>问渠那得清如许，为有源头活水来。</p>
</blockquote>
<p>想要保持自己的技术活力，最有效的手段就是通过不断地输入来提供足够的养分。我们也不必刻意追求高深的或者新鲜的知识点，通过对一个基础问题的全方位多维度解析，同样也会收获不小。</p>
<a id="more"></a>

<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210625%20/18-58-21-En8h2e.jpeg" alt="发散思维"></p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>假设有这么一道题目：<code>请获取字符串 &quot;bianchengsanmei,xuexiyouqudezhishi,jieshiyouqudepengyou,suzaoyouqudelinghun.&quot; 中重复次数最多的字符及其重复次数</code>。</p>
<p>今天我们就来解一下这道题。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这种题目的解法比较开放，实现手段也可能多种多样，其中的区别在于代码的运行性能有高有低（时间复杂度和空间复杂度不同）。</p>
<p>在这里需要注意的只有一点：符合最大次数的字符可能<strong>不止一个</strong>。</p>
<h2 id="使用对象"><a href="#使用对象" class="headerlink" title="使用对象"></a>使用对象</h2><p><strong>解题思路：</strong></p>
<ul>
<li>遍历字符串，以各个字符为 key，重复次数为 value，存入一个对象。</li>
<li>遍历对象，得到 value 的最大值。</li>
<li>遍历对象，根据得到的最大 value 值，获取到对应的字符 key。</li>
<li>输出结果。</li>
</ul>
<p><strong>代码实现如下：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> testStr = <span class="string">"bianchengsanmei,xuexiyouqudezhishi,jieshiyouqudepengyou,suzaoyouqudelinghun.ii"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取各个字符及其重复次数的映射对象</span></span><br><span class="line"><span class="keyword">let</span> wordsObj = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; testStr.length; index++) &#123;</span><br><span class="line">    <span class="keyword">const</span> word = testStr[index];</span><br><span class="line">    word <span class="keyword">in</span> wordsObj ? wordsObj[word]++ : wordsObj[word] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取最大的重复次数</span></span><br><span class="line"><span class="keyword">let</span> maxNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> word <span class="keyword">in</span> wordsObj) &#123;</span><br><span class="line">    <span class="keyword">const</span> num = wordsObj[word];</span><br><span class="line">    <span class="keyword">if</span> (num &gt;= maxNum) &#123;</span><br><span class="line">        maxNum = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取最大重复次数对应的字符，并输出结果</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> word <span class="keyword">in</span> wordsObj) &#123;</span><br><span class="line">    <span class="keyword">const</span> num = wordsObj[word];</span><br><span class="line">    <span class="keyword">if</span> (num === maxNum) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`重复次数最多的字符是：<span class="subst">$&#123; word &#125;</span>，重复次数为：<span class="subst">$&#123; maxNum &#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出现次数最多的字符是：i，出现次数为：10</span></span><br><span class="line"><span class="comment">// 出现次数最多的字符是：u，出现次数为：10</span></span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong></p>
<ul>
<li>这应该是很多人第一时间能够想到的解法，很符合“面向过程”的编程思想。</li>
<li>总共有三个循环，存在较大的优化空间。</li>
</ul>
<h2 id="数组-amp-指针"><a href="#数组-amp-指针" class="headerlink" title="数组&amp;指针"></a>数组&amp;指针</h2><p><strong>解题思路：</strong></p>
<ul>
<li>将字符串转为数组并<strong>排序</strong>，使重复字符排在一起。</li>
<li>使用指针思想，得到最大重复次数和对应的字符数组。</li>
<li>输出结果。</li>
</ul>
<p><strong>代码实现如下：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> testStr = <span class="string">"bianchengsanmei,xuexiyouqudezhishi,jieshiyouqudepengyou,suzaoyouqudelinghun.ii"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字符串转为数组并排序</span></span><br><span class="line"><span class="keyword">const</span> testStrArr = testStr.split(<span class="string">""</span>).sort();</span><br><span class="line"><span class="keyword">let</span> startIndex = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> endIndex = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> maxNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> validWords = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用指针法，获取最大重复次数及最大次数对应的字符数组</span></span><br><span class="line"><span class="keyword">while</span> (startIndex &lt; testStrArr.length) &#123;</span><br><span class="line">    <span class="comment">// startIndex 和 endIndex 位置的字符不同</span></span><br><span class="line">    <span class="keyword">if</span> (testStrArr[startIndex] !== testStrArr[endIndex]) &#123;</span><br><span class="line">        <span class="comment">// 计算 startIndex 和 endIndex 之间的字符个数</span></span><br><span class="line">        <span class="keyword">const</span> rangeNum = endIndex - startIndex;</span><br><span class="line">        <span class="keyword">if</span> (rangeNum &gt; maxNum) &#123;</span><br><span class="line">            maxNum = rangeNum;</span><br><span class="line">            <span class="comment">// 如果出现了新的最大次数，则给存放符合条件字符的数组重新赋值</span></span><br><span class="line">            validWords = [testStrArr[startIndex]];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rangeNum === maxNum) &#123;</span><br><span class="line">            <span class="comment">// 如果新的次数和最大次数相等，则将该字符 push 进字符数组</span></span><br><span class="line">            validWords.push(testStrArr[startIndex]);</span><br><span class="line">        &#125;</span><br><span class="line">        startIndex = endIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    endIndex++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; validWords.length; index++) &#123;</span><br><span class="line">    <span class="keyword">const</span> word = validWords[index];</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`重复次数最多的是：<span class="subst">$&#123; word &#125;</span>，重复次数为：<span class="subst">$&#123; maxNum &#125;</span>`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong></p>
<p>本方法的难点和精髓在于使用了指针法，一次循环就获取到了我们想要的结果。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>主流的解题思路大概就这两种，其他的很多解法都可以看作是这两种思路的变种。</p>
<p>万变不离其宗，只要将解题思路理清了，代码实现只是一个结果而已。在平常的工作学习中，我们要有意识地培养自己的发散性思维，从多角度去看待问题，你可能会发现不一样的风景哦！</p>
<p>希望能够对大家有所启发哦！</p>
<p>~</p>
<p>~ 本文完，感谢阅读！</p>
<p>~</p>
<blockquote>
<p>学习有趣的知识，结识有趣的朋友，塑造有趣的灵魂！</p>
<p>我是〖编程三昧〗的作者 <strong>隐逸王</strong>，我的公众号是『编程三昧』，欢迎关注，希望大家多多指教！</p>
<p>你来，怀揣期望，我有墨香相迎！ 你归，无论得失，唯以余韵相赠！</p>
<p>知识与技能并重，内力和外功兼修，理论和实践两手都要抓、两手都要硬！</p>
</blockquote>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210625%20/18-59-01-TOFScw.jpeg" alt="发散思维"></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>代码实现</tag>
      </tags>
  </entry>
  <entry>
    <title>Proxy 对象简介</title>
    <url>/yinyiwang/2021/07/05/Proxy-%E5%AF%B9%E8%B1%A1%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>关于Vue3 中的数据响应式功能，我们大家应该都知道，它是通过 ES6的代理模式——Proxy 对象实现的，今天我们来简单认识下何为 Proxy 对象。</p>
<a id="more"></a>

<h3 id="Proxy-的定义"><a href="#Proxy-的定义" class="headerlink" title="Proxy 的定义"></a>Proxy 的定义</h3><p>Proxy 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。</p>
<p><code>proxy</code>修改的是程序默认形为，就形同于在编程语言层面上做修改，属于元编程(<code>meta</code> <code>programming</code>)，即对编程语言进行编程。</p>
<blockquote>
<ul>
<li><strong>元编程（英语：Metaprogramming</strong>，又译超编程，是指某类计算机程序的编写，这类计算机程序编写或者操纵其它程序（或者自身）作为它们的数据，或者在运行时完成部分本应在编译时完成的工作.</li>
</ul>
</blockquote>
<p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p>
<h3 id="Proxy-的基本语法"><a href="#Proxy-的基本语法" class="headerlink" title="Proxy 的基本语法"></a>Proxy 的基本语法</h3><p>ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure>

<ul>
<li>target：  要使用 <code>Proxy</code> 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。</li>
<li>handler： 一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 <code>proxy</code> 的行为。</li>
</ul>
<h3 id="Proxy-使用示例"><a href="#Proxy-使用示例" class="headerlink" title="Proxy 使用示例"></a>Proxy 使用示例</h3><p>下面是关于 Proxy 使用的一个基本示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">"superMan"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(man, &#123;</span><br><span class="line">  <span class="keyword">get</span>(target, property, receiver) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`正在获取 <span class="subst">$&#123;property&#125;</span> 属性`</span>)</span><br><span class="line">    <span class="keyword">return</span> target[property];</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(proxy.name);</span><br><span class="line"><span class="built_in">console</span>.log(proxy.age);</span><br></pre></td></tr></table></figure>

<p>在以上示例中， Proxy 构造函数接受 <code>person</code> 对象为代理目标，创建了一个代理对象。<strong>在创建代理对象时，我们定义了一个 get 捕获器，用于捕获代理目标属性读取的操作。</strong> 捕获器的作用就是用于拦截用户对目标对象属性读取的相关操作，在这些操作传播到目标对象之前，会先调用对应的捕获器函数，从而拦截并修改相应的行为。</p>
<p>在设置了 get 捕获器之后，当成功运行以上的示例代码，控制台会输出以下结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">正在获取 name 属性</span><br><span class="line">superman</span><br><span class="line">正在读取 age 属性</span><br><span class="line"><span class="literal">undefined</span></span><br></pre></td></tr></table></figure>

<p>通过观察以上输出结果，我们可以发现 <strong>get 捕获器</strong> 不仅可以拦截已知属性的读取操作，也可以拦截未知属性的读取操作。</p>
<h3 id="Proxy-实例当做原型对象"><a href="#Proxy-实例当做原型对象" class="headerlink" title="Proxy 实例当做原型对象"></a>Proxy 实例当做原型对象</h3><p>Proxy 实例也可以作为其他对象的原型对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function(target, property) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">35</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(proxy);</span><br><span class="line">obj.time  <span class="comment">// 35</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>proxy</code>对象是<code>obj</code>对象的原型，<code>obj</code>对象本身并没有<code>time</code>属性，所以根据原型链，会在<code>proxy</code>对象上读取该属性，导致被拦截。</p>
<h2 id="Proxy-实例的方法"><a href="#Proxy-实例的方法" class="headerlink" title="Proxy 实例的方法"></a>Proxy 实例的方法</h2><p>在创建 Proxy 对象时，除了定义 <strong>get 捕获器</strong> 之外，我们还可以定义其他的捕获器，比如 set、apply 、 has或者 deleteProperty  等。</p>
<h4 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h4><p><code>get</code>方法用于拦截某个属性的读取操作，可以接受三个参数，依次为目标对象、属性名和 proxy 实例本身（严格地说，是操作行为所针对的对象），其中最后一个参数可选。</p>
<h4 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h4><p><code>set</code>方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身，其中最后一个参数可选。</p>
<h4 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h4><p><code>apply</code>方法拦截函数的调用、<code>call</code>和<code>apply</code>操作。</p>
<p><code>apply</code>方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（<code>this</code>）和目标对象的参数数组。</p>
<h3 id="has"><a href="#has" class="headerlink" title="has()"></a>has()</h3><p><code>has</code>方法用来拦截<code>HasProperty</code>操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是<code>in</code>运算符。</p>
<p><code>has</code>方法可以接受两个参数，分别是目标对象、需查询的属性名。</p>
<h3 id="deleteProperty"><a href="#deleteProperty" class="headerlink" title="deleteProperty()"></a>deleteProperty()</h3><p><code>deleteProperty</code>方法用于拦截<code>delete</code>操作，如果这个方法抛出错误或者返回<code>false</code>，当前属性就无法被<code>delete</code>命令删除。</p>
<h3 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty()"></a>defineProperty()</h3><p><code>defineProperty</code>方法拦截了<code>Object.defineProperty</code>操作。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Proxy就是拦截层，你给出被拦截的对象，外界访问这个对象必须先通过拦截层，即访问Proxy的实例对象。通过Proxy为外界访问进行过滤和改写，如赋值时需满足某些条件。</p>
<blockquote>
<p>学习有趣的知识，结识有趣的朋友，塑造有趣的灵魂！</p>
<p>大家好！我是〖编程三昧〗的作者 <strong>隐逸王</strong>，我的公众号是『编程三昧』，欢迎关注，希望大家多多指教！</p>
<p>知识与技能并重，内力和外功兼修，理论和实践两手都要抓、两手都要硬！</p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript - ES6 - Proxy</category>
      </categories>
      <tags>
        <tag>Proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>Service worker 的概念和用法</title>
    <url>/yinyiwang/2021/07/05/Service-worker-%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210604%20/19-27-12-XqBN9x.jpg" alt="查看源图像"></p>
<p>Service workers 本质上充当 Web 应用程序、浏览器与网络（可用时）之间的代理服务器。这个 API 旨在创建有效的离线体验，它会拦截网络请求并根据网络是否可用采取来适当的动作、更新来自服务器的的资源。它还提供入口以推送通知和访问后台同步 API。</p>
<a id="more"></a>

<h2 id="Service-worker-的概念和用法"><a href="#Service-worker-的概念和用法" class="headerlink" title="Service worker 的概念和用法"></a>Service worker 的概念和用法</h2><p>Service worker 是一个注册在指定源和路径下的事件驱动 <code>worker</code>。它采用 JavaScript 控制关联的页面或者网站，拦截并修改访问和资源请求，细粒度地缓存资源。你可以完全控制应用在特定情形（最常见的情形是网络不可用）下的表现。</p>
<p>Service worker 运行在<code>worker</code>上下文，因此它不能访问 DOM。相对于驱动应用的主 JavaScript 线程，它运行在其他线程中，所以不会造成阻塞。它设计为完全异步，同步API（如 <code>XHR</code> 和 <code>localStorage</code>）不能在 service worker 中使用。</p>
<p>出于安全考量，Service workers 只能由 <strong>HTTPS</strong> 承载，毕竟修改网络请求的能力暴露给中间人攻击会非常危险。在 Firefox 浏览器的用户隐私模式，Service Worke不可用。</p>
<blockquote>
<p><strong>注意：</strong>Service workers可以更细致地控制每一件事情，支持当操作出错时终止操作</p>
</blockquote>
<blockquote>
<p><strong>注意：</strong>Service workers大量使用 <code>Promise</code>，因为通常它们会等待响应后继续，并根据响应返回一个成功或者失败的操作。Promise 非常适合这种场景。</p>
</blockquote>
<h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>使用  <code>ServiceWorkerContainer.register()</code> 方法首次注册 service worker。如果注册成功，service worker 就会被下载到客户端并尝试安装或激活（见下文），这将作用于整个域内用户可访问的 URL，或者其特定子集。</p>
<h3 id="下载、安装和激活"><a href="#下载、安装和激活" class="headerlink" title="下载、安装和激活"></a>下载、安装和激活</h3><p>此时，你的服务工作者( service worker )将遵守以下生命周期：</p>
<ol>
<li>下载</li>
<li>安装</li>
<li>激活</li>
</ol>
<p>用户首次访问 service worker 控制的网站或页面时，service worker 会立刻被下载。</p>
<p>之后，在以下情况将会触发更新:</p>
<ul>
<li>一个前往作用域内页面的导航</li>
<li>在 service worker 上的一个事件被触发并且过去 24 小时没有被下载</li>
</ul>
<p>无论它与现有 service worker 不同（字节对比），还是第一次在页面或网站遇到 service worker，如果下载的文件是新的，安装就会尝试进行。</p>
<p>如果这是首次启用 service worker，页面会首先尝试安装，安装成功后它会被激活。</p>
<p>如果现有 service worker 已启用，新版本会在后台安装，但不会被激活，这个时序称为 worker in waiting。直到所有已加载的页面不再使用旧的 service worker 才会激活新的 service worker。只要页面不再依赖旧的 service worker，新的 service worker 会被激活（成为active worker）。</p>
<p>你可以监听 <code>InstallEvent</code>，事件触发时的标准行为是准备 service worker 用于使用，例如使用内建的 storage API 来创建缓存，并且放置应用离线时所需资源。</p>
<p>还有一个 activate 事件，触发时可以清理旧缓存和旧的 service worker 关联的东西。</p>
<p>Servcie worker 可以通过  <code>FetchEvent</code> 事件去响应请求。通过使用  <code>FetchEvent.respondWith</code> 方法，你可以任意修改对于这些请求的响应。</p>
<p><strong>注意</strong>: 因为 <code>oninstall</code> 和 <code>onactivate</code> 完成前需要一些时间，service worker 标准提供一个 <code>waitUntil</code> 方法，当 <code>oninstall</code> 或者 <code>onactivate</code> 触发时被调用，接受一个 promise。在这个 promise 被成功 resolve 以前，功能性事件不会分发到 service worker。</p>
<h2 id="其他使用场景"><a href="#其他使用场景" class="headerlink" title="其他使用场景"></a>其他使用场景</h2><p>Service workers 也可以用来做这些事情：</p>
<ul>
<li>后台数据同步</li>
<li>响应来自其它源的资源请求</li>
<li>集中接收计算成本高的数据更新，比如地理位置和陀螺仪信息，这样多个页面就可以利用同一组数据</li>
<li>在客户端进行 CoffeeScript，LESS，CJS/AMD 等模块编译和依赖管理（用于开发目的）</li>
<li>后台服务钩子</li>
<li>自定义模板用于特定URL模式</li>
<li>性能增强，比如预取用户可能需要的资源，比如相册中的后面数张图片</li>
</ul>
<p>未来 service workers 能够用来做更多使web平台接近原生应用的事。 值得关注的是，其他标准也能并且将会使用 service worker，例如:</p>
<ul>
<li>后台同步：启动一个service worker即使没有用户访问特定站点，也可以更新缓存</li>
<li>响应推送：启动一个service worker向用户发送一条信息通知新的内容可用</li>
<li>对时间或日期作出响应</li>
<li>进入地理围栏</li>
</ul>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul>
<li><code>Cache</code></li>
</ul>
<p>表示用于 <code>Request</code>/<code>Response</code>对象对的存储，作为<code>ServiceWorker</code>生命周期的一部分被缓存。</p>
<ul>
<li><code>CacheStorage</code></li>
</ul>
<p>表示<code>Cache</code>对象的存储。提供一个所有命名缓存的主目录，<code>ServiceWorker</code>可以访问并维护名字字符串到<code>Cache</code>对象的映射。</p>
<ul>
<li><code>Client</code></li>
</ul>
<p>表示 service worker client 的作用域。一个 service worker client 可以是浏览器上下文的一个文档，也可以是一个由活动worker控制的<code>SharedWorker</code>。</p>
<ul>
<li><code>Clients</code></li>
</ul>
<p>表示一个<code>Client</code>对象容器，是访问当前源的活动service worker clients的主要途径。</p>
<ul>
<li><code>ExtendableEvent</code></li>
</ul>
<p>扩展被分发到 <code>ServiceWorkerGlobalScope</code> 的 <code>install</code> 和 <code>activate</code> 事件时序，作为 service worker 生命周期的一部分。这会确保任何功能型事件（如<code>FetchEvent</code>）不被分发到 <code>ServiceWorker</code>，直到它更新了数据库架构、删除过期缓存项等等以后。</p>
<ul>
<li><code>ExtendableMessageEvent</code></li>
</ul>
<p>在 <code>ServiceWorker</code> 上触发的消息事件的事件对象（当在 <code>ServiceWorkerGlobalScope</code> 上从另一个上下文接收到通道消息时）——延长了此类事件的生命周期。</p>
<ul>
<li><code>FetchEvent</code></li>
</ul>
<p>传递给 <code>ServiceWorkerGlobalScope.onfetch</code> 处理函数的参数，<code>FetchEvent</code> 代表一个在 <code>ServiceWorker</code> 的 <code>ServiceWorkerGlobalScope</code> 中分发的请求动作。它包含关于请求和响应的结果信息，并且提供 <code>FetchEvent.respondWith()</code> 方法，这个方法允许我们提供任意的响应返回到控制页面。</p>
<ul>
<li><code>InstallEvent</code></li>
</ul>
<p>传递给 <code>oninstall</code> 处理函数的参数，<code>InstallEvent</code> 接口代表一个在 <code>ServiceWorker</code> 的<code>ServiceWorkerGlobalScope</code> 中分发的安装动作，作为 <code>ExtendableEvent</code> 的子事件，它保证诸如 <code>FetchEvent</code> 的功能性事件在安装过程中不会被分发。</p>
<ul>
<li><code>NavigationPreloadManager</code></li>
</ul>
<p>提供使用 Service Worker 管理资源预加载的方法。</p>
<ul>
<li><code>Navigator.serviceWorker</code></li>
</ul>
<p>返回一个 <code>ServiceWorkerContainer</code> 对象，可以提供入口用于注册、删除、更新以及与在相关 document 中 <code>ServiceWorker</code> 通信的对象。</p>
<ul>
<li><code>NotificationEvent</code></li>
</ul>
<p>传递给<code>onnotificationclick</code> 处理函数的参数，<code>NotificationEvent</code> 接口代表在 <code>ServiceWorker</code> 里 <code>ServiceWorkerGlobalScope</code> 中分发的单击事件通知。</p>
<ul>
<li><code>ServiceWorker</code></li>
</ul>
<p>表示一个service worker。多个浏览的上下文(例如pages,workers等等)都能通过相同的ServiceWorker 对象相关联。</p>
<ul>
<li><code>ServiceWorkerContainer</code></li>
</ul>
<p>提供一个在网络生态中把 service worker 作为一个整体的对象，包括辅助注册，反注册以及更新服务工作者，并且访问 service worker 的状态以及他们的注册信息。</p>
<ul>
<li><code>ServiceWorkerGlobalScope</code></li>
</ul>
<p>表示 service worker 的全局执行上下文。</p>
<ul>
<li><code>ServiceWorkerMessageEvent</code> </li>
</ul>
<p>包含关于一个发送给以 <code>navigator.serviceWorker</code> 为目标的事件信息。</p>
<ul>
<li><code>ServiceWorkerRegistration</code></li>
</ul>
<p>表示service worker的注册。</p>
<ul>
<li><code>ServiceWorkerState</code> </li>
</ul>
<p>与它自己的 <code>ServiceWorker</code> 的状态相关联。</p>
<ul>
<li><code>SyncEvent</code> </li>
</ul>
<p>传递给同步函数的参数，SyncEvent 接口代表在 ServiceWorker 里<code>ServiceWorkerGlobalScope</code> 分发的同步动作。</p>
<ul>
<li><code>SyncManager</code> </li>
</ul>
<p>提供一个接口用于注册和返回<code>SyncRegistration</code>对象。</p>
<ul>
<li><code>WindowClient</code></li>
</ul>
<p>表示在浏览器上下文中记录的service worker客户端的作用域，被活动的工作者控制。是 <code>Client</code> 对象的特殊类型，包含一些附加的方法和可用的属性。</p>
<blockquote>
<p>学习有趣的知识，结识有趣的朋友，塑造有趣的灵魂！</p>
<p>大家好！我是〖编程三昧〗的作者 <strong>隐逸王</strong>，我的公众号是『编程三昧』，欢迎关注，希望大家多多指教！</p>
</blockquote>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210604%20/19-26-03-txvEvM.png" alt="扫码_搜索联合传播样式-白色版"></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>service worker</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 基本命令总结</title>
    <url>/yinyiwang/2021/07/05/Git-%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Git 是我们日常工作中使用频率极高的工具，各种指令让人眼花缭乱，今天，我们就在这里总结一下它的一些基本指令，算是做一份操作笔记吧。</p>
<a id="more"></a>

<h2 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h2><h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h3><p>把要提交的文件的信息添加到暂存区中。当使用 git commit 时，将依据暂存区中的内容来进行文件的提交。</p>
<p>它通常将现有路径的当前内容作为一个整体添加，但是通过一些选项，它也可以用于添加内容，只对所应用的工作树文件进行一些更改，或删除工作树中不存在的路径了。</p>
<p>“索引”保存工作树内容的快照，并且将该快照作为下一个提交的内容。 因此，在对工作树进行任何更改之后，并且在运行 <code>git commit</code> 命令之前，必须使用 <code>git add</code> 命令将任何新的或修改的文件添加到索引。</p>
<p>该命令可以在提交之前多次执行。它只在运行 <code>git add</code> 命令时添加指定文件的内容; 如果希望随后的更改包含在下一个提交中，那么必须再次运行 <code>git add</code> 将新的内容添加到索引。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 把指定的文件添加到暂存区中</span></span><br><span class="line">$ git add &lt;文件路径&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加所有修改、已删除的文件到暂存区中</span></span><br><span class="line">$ git add -u [&lt;文件路径&gt;]</span><br><span class="line">$ git add --update [&lt;文件路径&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加所有修改、已删除、新增的文件到暂存区中，省略 &lt;文件路径&gt; 即为当前目录</span></span><br><span class="line">$ git add -A [&lt;文件路径&gt;]</span><br><span class="line">$ git add --all [&lt;文件路径&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有修改、已删除但没有提交的文件，进入一个子命令系统</span></span><br><span class="line">$ git add -i [&lt;文件路径&gt;]</span><br><span class="line">$ git add --interactive [&lt;文件路径&gt;]</span><br></pre></td></tr></table></figure>

<h3 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h3><p>操作 Git 的分支命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出本地的所有分支，当前所在分支以 "*" 标出</span></span><br><span class="line">$ git branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出本地的所有分支并显示最后一次提交，当前所在分支以 "*" 标出</span></span><br><span class="line">$ git branch -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建新分支，新的分支基于上一次提交建立</span></span><br><span class="line">$ git branch &lt;分支名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改分支名称</span></span><br><span class="line"><span class="comment"># 如果不指定原分支名称则为当前所在分支</span></span><br><span class="line">$ git branch -m [&lt;原分支名称&gt;] &lt;新的分支名称&gt;</span><br><span class="line"><span class="comment"># 强制修改分支名称</span></span><br><span class="line">$ git branch -M [&lt;原分支名称&gt;] &lt;新的分支名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定的本地分支</span></span><br><span class="line">$ git branch -d &lt;分支名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制删除指定的本地分支</span></span><br><span class="line">$ git branch -D &lt;分支名称&gt;</span><br></pre></td></tr></table></figure>

<h3 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h3><p>更新工作树中的文件以匹配索引或指定树中的版本。如果没有给出路径 - <code>git checkout</code> 还会更新 <code>HEAD</code> ，将指定的分支设置为当前分支。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 切换到已存在的指定分支</span></span><br><span class="line">$ git checkout &lt;分支名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建并切换到指定的分支，保留所有的提交记录</span></span><br><span class="line"><span class="comment"># 等同于 "git branch" 和 "git checkout" 两个命令合并</span></span><br><span class="line">$ git checkout -b &lt;分支名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建并切换到指定的分支，删除所有的提交记录</span></span><br><span class="line">$ git checkout --orphan &lt;分支名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换掉本地的改动，新增的文件和已经添加到暂存区的内容不受影响</span></span><br><span class="line">$ git checkout &lt;文件路径&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>git checkout</code> 是 git 最常用的命令之一，同时也是一个很危险的命令，因为这条命令会重写工作区。</p>
</blockquote>
<h3 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h3><p>将存储库克隆到新创建的目录中，为克隆的存储库中的每个分支创建远程跟踪分支(使用 <code>git branch -r</code> 可见)，并从克隆检出的存储库作为当前活动分支的初始分支。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认在当前目录下创建和版本库名相同的文件夹并下载版本到该文件夹下</span></span><br><span class="line">$ git <span class="built_in">clone</span> &lt;远程仓库的网址&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定本地仓库的目录</span></span><br><span class="line">$ git <span class="built_in">clone</span> &lt;远程仓库的网址&gt; &lt;本地目录&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># -b 指定要克隆的分支，默认是master分支</span></span><br><span class="line">$ git <span class="built_in">clone</span> &lt;远程仓库的网址&gt; -b &lt;分支名称&gt; &lt;本地目录&gt;</span><br></pre></td></tr></table></figure>

<h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><p>将索引的当前内容与描述更改的用户和日志消息一起存储在新的提交中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 把暂存区中的文件提交到本地仓库，调用文本编辑器输入该次提交的描述信息</span></span><br><span class="line">$ git commit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把暂存区中的文件提交到本地仓库中并添加描述信息</span></span><br><span class="line">$ git commit -m <span class="string">"&lt;提交的描述信息&gt;"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把所有修改、已删除的文件提交到本地仓库中</span></span><br><span class="line"><span class="comment"># 不包括未被版本库跟踪的文件，等同于先调用了 "git add -u"</span></span><br><span class="line">$ git commit -a -m <span class="string">"&lt;提交的描述信息&gt;"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改上次提交的描述信息</span></span><br><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure>

<h3 id="git-config"><a href="#git-config" class="headerlink" title="git config"></a>git config</h3><p>主要是用来配置 Git 的相关参数，其主要操作有：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看配置信息</span></span><br><span class="line"><span class="comment"># --local：仓库级，--global：全局级，--system：系统级</span></span><br><span class="line">$ git config &lt;--<span class="built_in">local</span> | --global | --system&gt; -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前生效的配置信息</span></span><br><span class="line">$ git config -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑配置文件</span></span><br><span class="line"><span class="comment"># --local：仓库级，--global：全局级，--system：系统级</span></span><br><span class="line">$ git config &lt;--<span class="built_in">local</span> | --global | --system&gt; -e</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加配置项</span></span><br><span class="line"><span class="comment"># --local：仓库级，--global：全局级，--system：系统级</span></span><br><span class="line">$ git config &lt;--<span class="built_in">local</span> | --global | --system&gt; --add &lt;name&gt; &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取配置项</span></span><br><span class="line">$ git config &lt;--<span class="built_in">local</span> | --global | --system&gt; --get &lt;name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除配置项</span></span><br><span class="line">$ git config &lt;--<span class="built_in">local</span> | --global | --system&gt; --<span class="built_in">unset</span> &lt;name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置提交记录中的用户信息</span></span><br><span class="line">$ git config --global user.name &lt;用户名&gt;</span><br><span class="line">$ git config --global user.email &lt;邮箱地址&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更改Git缓存区的大小</span></span><br><span class="line"><span class="comment"># 如果提交的内容较大，默认缓存较小，提交会失败</span></span><br><span class="line"><span class="comment"># 缓存大小单位：B，例如：524288000（500MB）</span></span><br><span class="line">$ git config --global http.postBuffer &lt;缓存大小&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用 git status/git diff 命令时以高亮或彩色方式显示改动状态</span></span><br><span class="line">$ git config --global color.ui <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置可以缓存密码，默认缓存时间15分钟</span></span><br><span class="line">$ git config --global credential.helper cache</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置密码的缓存时间</span></span><br><span class="line"><span class="comment"># 缓存时间单位：秒</span></span><br><span class="line">$ git config --global credential.helper <span class="string">'cache --timeout=&lt;缓存时间&gt;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置长期存储密码</span></span><br><span class="line">$ git config --global credential.helper store</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Git 一共有3个配置文件：</p>
<ol>
<li>仓库级的配置文件：在仓库的 <code>.git/.gitconfig</code>，该配置文件只对所在的仓库有效。</li>
<li>全局配置文件：Mac 系统在 <code>~/.gitconfig</code>，Windows 系统在 <code>C:\Users\&lt;用户名&gt;\.gitconfig</code>。</li>
<li>系统级的配置文件：在 Git 的安装目录下（Mac 系统下安装目录在 <code>/usr/local/git</code>）的 <code>etc</code> 文件夹中的 <code>gitconfig</code>。</li>
</ol>
</blockquote>
<h3 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h3><p>用于显示提交和工作树等之间的更改。</p>
<p>此命令比较的是工作目录中当前文件和暂存区域快照之间的差异,也就是修改之后还没有暂存起来的变化内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 比较当前文件和暂存区中文件的差异，显示没有暂存起来的更改</span></span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较暂存区中的文件和上次提交时的差异</span></span><br><span class="line">$ git diff --cached</span><br><span class="line">$ git diff --staged</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较当前文件和上次提交时的差异</span></span><br><span class="line">$ git diff HEAD</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看从指定的版本之后改动的内容</span></span><br><span class="line">$ git diff &lt;commit ID&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较两个分支之间的差异</span></span><br><span class="line">$ git diff &lt;分支名称&gt; &lt;分支名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看两个分支分开后各自的改动内容</span></span><br><span class="line">$ git diff &lt;分支名称&gt;...&lt;分支名称&gt;</span><br></pre></td></tr></table></figure>

<h3 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h3><p>从远程仓库获取最新的版本到本地的 tmp 分支上。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将远程仓库所有分支的最新版本全部取回到本地</span></span><br><span class="line">$ git fetch &lt;远程仓库的别名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将远程仓库指定分支的最新版本取回到本地</span></span><br><span class="line">$ git fetch &lt;远程主机名&gt; &lt;分支名&gt;</span><br></pre></td></tr></table></figure>

<h3 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h3><p>初始化项目所在目录，初始化后会在当前目录下出现一个名为 .git 的目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化本地仓库，在当前目录下生成 .git 文件夹</span></span><br><span class="line">$ git init</span><br></pre></td></tr></table></figure>

<h3 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h3><p>显示提交的记录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打印所有的提交记录</span></span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印从第一次提交到指定的提交的记录</span></span><br><span class="line">$ git <span class="built_in">log</span> &lt;commit ID&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印指定数量的最新提交的记录</span></span><br><span class="line">$ git <span class="built_in">log</span> -&lt;指定的数量&gt;</span><br></pre></td></tr></table></figure>

<h3 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h3><p>用于将两个或两个以上的开发历史加入(合并)一起。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 把指定的分支合并到当前所在的分支下，并自动进行新的提交</span></span><br><span class="line">$ git merge &lt;分支名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把指定的分支合并到当前所在的分支下，不进行新的提交</span></span><br><span class="line">$ git merge --no-commit &lt;分支名称&gt;</span><br></pre></td></tr></table></figure>

<h3 id="git-mv"><a href="#git-mv" class="headerlink" title="git mv"></a>git mv</h3><p>重命名文件或者文件夹。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重命名指定的文件或者文件夹</span></span><br><span class="line">$ git mv &lt;源文件/文件夹&gt; &lt;目标文件/文件夹&gt;</span><br></pre></td></tr></table></figure>

<h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h3><p>从远程仓库获取最新版本并合并到本地。<br> 首先会执行 <code>git fetch</code>，然后执行 <code>git merge</code>，把获取的分支的 HEAD 合并到当前分支。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从远程仓库获取最新版本。</span></span><br><span class="line">$ git pull</span><br></pre></td></tr></table></figure>

<h3 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h3><p>把本地仓库的提交推送到远程仓库。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 把本地仓库的分支推送到远程仓库的指定分支</span></span><br><span class="line">$ git push &lt;远程仓库的别名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定的远程仓库的分支</span></span><br><span class="line">$ git push &lt;远程仓库的别名&gt; :&lt;远程分支名&gt;</span><br><span class="line">$ git push &lt;远程仓库的别名&gt; --delete &lt;远程分支名&gt;</span><br></pre></td></tr></table></figure>

<h3 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h3><p>操作远程库。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出已经存在的远程仓库</span></span><br><span class="line">$ git remote</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出远程仓库的详细信息，在别名后面列出URL地址</span></span><br><span class="line">$ git remote -v</span><br><span class="line">$ git remote --verbose</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加远程仓库</span></span><br><span class="line">$ git remote add &lt;远程仓库的别名&gt; &lt;远程仓库的URL地址&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改远程仓库的别名</span></span><br><span class="line">$ git remote rename &lt;原远程仓库的别名&gt; &lt;新的别名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定名称的远程仓库</span></span><br><span class="line">$ git remote remove &lt;远程仓库的别名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改远程仓库的 URL 地址</span></span><br><span class="line">$ git remote <span class="built_in">set</span>-url &lt;远程仓库的别名&gt; &lt;新的远程仓库URL地址&gt;</span><br></pre></td></tr></table></figure>

<h3 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h3><p>还原提交记录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重置暂存区，但文件不受影响</span></span><br><span class="line"><span class="comment"># 相当于将用 "git add" 命令更新到暂存区的内容撤出暂存区，可以指定文件</span></span><br><span class="line"><span class="comment"># 没有指定 commit ID 则默认为当前 HEAD</span></span><br><span class="line">$ git reset [&lt;文件路径&gt;]</span><br><span class="line">$ git reset --mixed [&lt;文件路径&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 HEAD 的指向改变，撤销到指定的提交记录，文件未修改</span></span><br><span class="line">$ git reset &lt;commit ID&gt;</span><br><span class="line">$ git reset --mixed &lt;commit ID&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 HEAD 的指向改变，撤销到指定的提交记录，文件未修改</span></span><br><span class="line"><span class="comment"># 相当于调用 "git reset --mixed" 命令后又做了一次 "git add"</span></span><br><span class="line">$ git reset --soft &lt;commit ID&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 HEAD 的指向改变，撤销到指定的提交记录，文件也修改了</span></span><br><span class="line">$ git reset --hard &lt;commit ID&gt;</span><br></pre></td></tr></table></figure>

<h3 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h3><p>生成一个新的提交来撤销某次提交，此次提交之前的所有提交都会被保留。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成一个新的提交来撤销某次提交</span></span><br><span class="line">$ git revert &lt;commit ID&gt;</span><br></pre></td></tr></table></figure>

<h3 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h3><p>删除文件或者文件夹。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 移除跟踪指定的文件，并从本地仓库的文件夹中删除</span></span><br><span class="line">$ git rm &lt;文件路径&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除跟踪指定的文件夹，并从本地仓库的文件夹中删除</span></span><br><span class="line">$ git rm -r &lt;文件夹路径&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除跟踪指定的文件，在本地仓库的文件夹中保留该文件</span></span><br><span class="line">$ git rm --cached</span><br></pre></td></tr></table></figure>

<h3 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h3><p>用于显示工作目录和暂存区的状态。使用此命令能看到那些修改被暂存到了, 哪些没有, 哪些文件没有被 Git tracked 到。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看本地仓库的状态</span></span><br><span class="line">$ git status</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>git status</code> 不显示已经 <code>commit</code> 到项目历史中去的信息。</p>
<p>看项目历史的信息要使用 <code>git log</code>。</p>
</blockquote>
<h3 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h3><p>操作标签的命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打印所有的标签</span></span><br><span class="line">$ git tag</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加轻量标签，指向提交对象的引用，可以指定之前的提交记录</span></span><br><span class="line">$ git tag &lt;标签名称&gt; [&lt;commit ID&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加带有描述信息的附注标签，可以指定之前的提交记录</span></span><br><span class="line">$ git tag -a &lt;标签名称&gt; -m &lt;标签描述信息&gt; [&lt;commit ID&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到指定的标签</span></span><br><span class="line">$ git checkout &lt;标签名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看标签的信息</span></span><br><span class="line">$ git show &lt;标签名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定的标签</span></span><br><span class="line">$ git tag -d &lt;标签名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将指定的标签提交到远程仓库</span></span><br><span class="line">$ git push &lt;远程仓库的别名&gt; &lt;标签名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将本地所有的标签全部提交到远程仓库</span></span><br><span class="line">$ git push &lt;远程仓库的别名&gt; –tags</span><br></pre></td></tr></table></figure>

<p>~</p>
<p>~ 本文完，感谢阅读！</p>
<p>~</p>
<blockquote>
<p>学习有趣的知识，结识有趣的朋友，塑造有趣的灵魂！</p>
<p>我是〖编程三昧〗的作者 <strong>隐逸王</strong>，我的公众号是『编程三昧』，欢迎关注，希望大家多多指教！</p>
<p>你来，怀揣期望，我有墨香相迎！ 你归，无论得失，唯以余韵相赠！</p>
<p>知识与技能并重，内力和外功兼修，理论和实践两手都要抓、两手都要硬！</p>
</blockquote>
]]></content>
      <categories>
        <category>开发工具 - Git</category>
      </categories>
      <tags>
        <tag>Git 命令</tag>
      </tags>
  </entry>
  <entry>
    <title>setTimeout，请原谅我一直以来对你的忽视(〒︿〒)</title>
    <url>/yinyiwang/2021/07/05/setTimeout%EF%BC%8C%E8%AF%B7%E5%8E%9F%E8%B0%85%E6%88%91%E4%B8%80%E7%9B%B4%E4%BB%A5%E6%9D%A5%E5%AF%B9%E4%BD%A0%E7%9A%84%E5%BF%BD%E8%A7%86-%E3%80%92%EF%B8%BF%E3%80%92/</url>
    <content><![CDATA[<blockquote>
<p>纸上得来终觉浅，绝知此事要躬行。哪怕是平时一个不起眼的小知识，我们也需要以认真的态度去学习，否则，说不定什么时候就会踩到坑，伤害到彼此！</p>
</blockquote>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210619%20/19-32-16-ECNYfD.jpeg" alt="cb68a71e6054ba5f4359e6746f5f9f2d"></p>
<a id="more"></a>

<h2 id="前戏"><a href="#前戏" class="headerlink" title="前戏"></a>前戏</h2><p>不管文章水不水，前戏都必须做足，否则写不下去啊，O(∩_∩)O哈哈~</p>
<p>之前发布了《前端 JavaScript 之『防抖』的简单代码实现》这篇文章之后，有一位朋友发了这么一条评论：</p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210619%20/17-54-31-RNYA7H.png" alt="评论"></p>
<p>我在写代码时有一个习惯：就是对已经销毁的变量随手赋一个 null，比如这样的：</p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210619%20/17-59-22-rRE4W5.png" alt="赋值为 null"></p>
<p>听说这样销毁的更彻底哦o(￣▽￣)ｄ。</p>
<p>针对上面这位朋友的建议，我也不确定是不是正确，好像平时也确实很少见到在 cleatTimeout 之后再赋值为 null 的操作。</p>
<p>对于不能确定的问题，我只坚信一个原则——实践是检验真理的唯一标准，既然有了困惑，那就动手验证好了。没错，我就是这么直接，请不要惊讶！︿(￣︶￣)︿</p>
<h2 id="意外"><a href="#意外" class="headerlink" title="意外"></a>意外</h2><p>本来以为是很简单的一次验证而已，洒洒水啦！可是，谁想却发生了意外，不信你看：</p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210619%20/18-17-07-wWOs5o.gif" alt="意外"></p>
<p>What?! setTimeout 的返回值是一个数字！！就问你：惊不惊喜意不意外？</p>
<p>好歹做了几年开发了，我居然不知道这个事，简直弱爆了！不过话说回来，谁平时会闲着没事去打印它的返回值啊，我们用的是它的功能好不好。</p>
<p>为什么会出现这么个结果呢？我们来看看 MDN 上怎么说：</p>
<blockquote>
<p>返回值<code>timeoutID</code>是一个正整数，表示定时器的编号。这个值可以传递给<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WindowOrWorkerGlobalScope/clearTimeout" target="_blank" rel="noopener"><code>clearTimeout()</code></a>来取消该定时器。</p>
</blockquote>
<p>看来这是常识性问题，只怪我平时没注意啊，看来平时要加强基础知识的储备了！</p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210619%20/18-36-24-Ec1sJ4.png" alt="泪崩"></p>
<p>至于为什么 timer 的值一直在增加，MDN 上是这样解释的：</p>
<blockquote>
<p>在同一个对象上（一个window或者worker），<code>setTimeout()</code>或者<code>setInterval()</code>在后续的调用不会重用同一个定时器编号。但是不同的对象使用独立的编号池。</p>
</blockquote>
<p>timer 每次执行的本质是生成了一个新的延时器，属于不同对象，所以编号发生了改变。</p>
<p>本来还想要再看看 setInterval 的，但是看到这个解释，我就打消了验证的念头，那必然又是一次”惊喜“。</p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>经过了前面这个意外，让我知道了自己的无知。但意外也是最好的鞭策，即使惭愧，但是开头所说的验证还是得往下走。</p>
<p>现在我们知道了一个真理：<strong>setTimeout 的返回值是一个代表延时器对象唯一身份标识的数字</strong>，那么在 clearTimeout() 之后，它的值到底会变成什么呢？请看大屏幕：</p>
<p> <img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210619%20/18-52-48-jjpSVF.gif" alt="销毁延时器"></p>
<p>我们看到，在调用 clearTimeout() 方法销毁延时器后，timer 的值并未被清空。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过上面的验证，我们可以得出以下结论：</p>
<ol>
<li>延时器方法 setTimeout() 的返回值是一个代表定时器唯一身份标识的编号；</li>
<li>这个编号是定时器一生成就带的，定时器执行过程中，编号不会发生变化；</li>
<li>计时器 setInterval 和 延时器 setTimeout 共用一个编号池，且所有编号都不会重复；</li>
<li>在调用了定时器销毁方法（clearTimeout 和 clearInterval）后，定时器编号不会被清空。</li>
</ol>
<p>以上总结适用于所有定时器（计时器和延时器）。</p>
<p>嗯，看来我随手赋一个 null 的做法还是比较合理的，毕竟是起到了那么一丝丝的作用的（￣︶￣）↗。</p>
<p>随手赋 null 是一个好习惯！(￣▽￣)~*</p>
<p>随手赋 null 是一个好习惯！(￣▽￣)~*</p>
<p>随手赋 null 是一个好习惯！(￣▽￣)~*</p>
<p>其实，今天这个验证也证实了另一个道理：我们平时最忽视的，往往是我们自以为最熟悉的，伤害了对方而不自知！</p>
<p>你品，你细细品！</p>
<p>~</p>
<p>~</p>
<p>~ 本文完，感谢阅读！</p>
<blockquote>
<p>学习有趣的知识，结识有趣的朋友，塑造有趣的灵魂！</p>
<p>大家好！我是〖编程三昧〗的作者 <strong>隐逸王</strong>，我的公众号是『编程三昧』，欢迎关注，希望大家多多指教！</p>
<p>知识与技能并重，内力和外功兼修，理论和实践两手都要抓、两手都要硬！</p>
</blockquote>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210619%20/19-30-03-nxPOnK.jpeg" alt="程序员"></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>定时器</tag>
      </tags>
  </entry>
  <entry>
    <title>WebSockets之WebSocket对象</title>
    <url>/yinyiwang/2021/07/05/WebSockets%E4%B9%8BWebSocket%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="WebSocket-对象简介"><a href="#WebSocket-对象简介" class="headerlink" title="WebSocket 对象简介"></a>WebSocket 对象简介</h1><blockquote>
<p><strong>WebSockets</strong> 是一种先进的技术。它可以在用户的浏览器和服务器之间打开交互式通信会话。使用此API，您可以向服务器发送消息并接收事件驱动的响应，而无需通过轮询服务器的方式以获得响应。</p>
</blockquote>
<a id="more"></a>

<h2 id="何为-WebSocket-对象？"><a href="#何为-WebSocket-对象？" class="headerlink" title="何为 WebSocket 对象？"></a>何为 WebSocket 对象？</h2><p>WebSocket 对象是 WebSockets 的接口之一，用于连接WebSocket服务器的主要接口，之后可以在这个连接上发送 和接受数据。</p>
<p><code>WebSocket</code> 对象提供了用于创建和管理  WebSocket  连接，以及可以通过该连接发送和接收数据的 API。</p>
<p>使用<code>WebSocket()</code>构造函数来构造一个<code>WebSocket</code> ：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> aWebSocket = <span class="keyword">new</span> WebSocket(url [, protocols]);</span><br></pre></td></tr></table></figure>

<p>参数解析：</p>
<ul>
<li>url: 要连接的URL；这应该是WebSocket服务器将响应的URL。</li>
<li>protocols(可选)： 一个协议字符串或者一个包含协议字符串的数组。这些字符串用于指定子协议，这样单个服务器可以实现多个WebSocket子协议（例如，您可能希望一台服务器能够根据指定的协议（protocol）处理不同类型的交互）。如果不指定协议字符串，则假定为空字符串。</li>
</ul>
<h2 id="WebSocket-对象的常量"><a href="#WebSocket-对象的常量" class="headerlink" title="WebSocket 对象的常量"></a>WebSocket 对象的常量</h2><table>
<thead>
<tr>
<th><strong>Constant</strong></th>
<th><strong>Value</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>WebSocket.CONNECTING</code></td>
<td><code>0</code></td>
</tr>
<tr>
<td><code>WebSocket.OPEN</code></td>
<td><code>1</code></td>
</tr>
<tr>
<td><code>WebSocket.CLOSING</code></td>
<td><code>2</code></td>
</tr>
<tr>
<td><code>WebSocket.CLOSED</code></td>
<td><code>3</code></td>
</tr>
</tbody></table>
<h2 id="WebSocket-对象的属性"><a href="#WebSocket-对象的属性" class="headerlink" title="WebSocket 对象的属性"></a>WebSocket 对象的属性</h2><h3 id="WebSocket-binaryType"><a href="#WebSocket-binaryType" class="headerlink" title="WebSocket.binaryType"></a><strong><code>WebSocket.binaryType</code></strong></h3><p>返回 WebSocket 连接所传输二进制数据的类型。</p>
<p>语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> binaryType = aWebSocket.binaryType;</span><br></pre></td></tr></table></figure>

<p> 返回值：DOMString （一个UTF-16字符串）</p>
<ul>
<li><code>&quot;blob&quot;</code>： 如果传输的是 <code>Blob</code> 类型的数据。</li>
<li><code>&quot;arraybuffer&quot;</code>： 如果传输的是 <code>ArrayBuffer</code> 类型的数据。</li>
</ul>
<h3 id="WebSocket-bufferedAmount（只读）"><a href="#WebSocket-bufferedAmount（只读）" class="headerlink" title="WebSocket.bufferedAmount（只读）"></a><strong><code>WebSocket.bufferedAmount</code></strong>（只读）</h3><p>用于返回已经被<code>send()</code>方法放入队列中但还没有被发送到网络中的数据的字节数。</p>
<p>一旦队列中的所有数据被发送至网络，则该属性值将被重置为0。</p>
<p>但是，若在发送过程中连接被关闭，则属性值不会重置为0。如果你不断地调用<code>send()</code>，则该属性值会持续增长。</p>
<p>语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bufferedAmount = aWebSocket.bufferedAmount;</span><br></pre></td></tr></table></figure>

<p>返回值：整数。</p>
<h3 id="WebSocket-extensions（只读）"><a href="#WebSocket-extensions（只读）" class="headerlink" title="WebSocket.extensions（只读）"></a><strong><code>WebSocket.extensions</code></strong>（只读）</h3><p>返回服务器已选择的扩展值。目前，链接可以协定的扩展值只有空字符串或者一个扩展列表。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> extensions = aWebSocket.extensions;</span><br></pre></td></tr></table></figure>

<p>返回值：<code>DOMString</code>。</p>
<h3 id="WebSocket-onclose"><a href="#WebSocket-onclose" class="headerlink" title="WebSocket.onclose"></a><strong><code>WebSocket.onclose</code></strong></h3><p>返回一个事件监听器，这个事件监听器将在 WebSocket 连接的 <code>readyState</code>  变为 <code>CLOSED</code>时被调用，它接收一个名字为“close”的 <code>CloseEvent</code> 事件。</p>
<p>语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">WebSocket.onclose = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"WebSocket is closed now."</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>返回值：<code>EventListener</code>。</p>
<h3 id="WebSocket-onerror"><a href="#WebSocket-onerror" class="headerlink" title="WebSocket.onerror"></a><strong><code>WebSocket.onerror</code></strong></h3><p>该属性中，你可以定义一个发生错误时执行的回调函数，此事件的事件名为”error”</p>
<p>语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">WebSocket.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">"WebSocket error observed:"</span>, event);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>返回值： <code>EventListener</code>。</p>
<h3 id="WebSocket-onmessage"><a href="#WebSocket-onmessage" class="headerlink" title="WebSocket.onmessage"></a><code>WebSocket.onmessage</code></h3><p>该属性是一个当收到来自服务器的消息时被调用的 event handler。它由一个MessageEvent调用。</p>
<p>语法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">aWebSocket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.debug(<span class="string">"WebSocket message received:"</span>, event);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>返回值： <code>EventListener</code>。</p>
<h3 id="WebSocket-onopen"><a href="#WebSocket-onopen" class="headerlink" title="WebSocket.onopen"></a><strong><code>WebSocket.onopen</code></strong></h3><p>该属性定义一个事件处理程序，当<code>WebSocket</code> 的连接状态<code>readyState</code> 变为<code>1</code>时调用;这意味着当前连接已经准备好发送和接受数据。这个事件处理程序通过 <code>事件</code>（建立连接时）触发。</p>
<p>语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">aWebSocket.onopen = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"WebSocket is open now."</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>返回值： <code>EventListener</code>。</p>
<h3 id="WebSocket-protocol（只读）"><a href="#WebSocket-protocol（只读）" class="headerlink" title="WebSocket.protocol（只读）"></a><strong><code>WebSocket.protocol</code></strong>（只读）</h3><p>用于返回服务器端选中的子协议的名字；这是一个在创建 <code>WebSocket</code> 对象时，在参数<code>protocols</code>中指定的字符串，当没有已建立的链接时为空串。</p>
<p>语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> protocol = aWebSocket.protocol;</span><br></pre></td></tr></table></figure>

<p>返回值：<code>DOMString</code>。</p>
<h3 id="WebSocket-readyState（只读）"><a href="#WebSocket-readyState（只读）" class="headerlink" title="WebSocket.readyState（只读）"></a><code>WebSocket.readyState</code>（只读）</h3><p>返回当前 <code>WebSocket</code> 的链接状态，只读。</p>
<p>语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> readyState = WebSocket.readyState;</span><br></pre></td></tr></table></figure>

<p>值：</p>
<ul>
<li>0 (<code>WebSocket.CONNECTING</code>)    正在链接中</li>
<li>1 (<code>WebSocket.OPEN</code>)    已经链接并且可以通讯</li>
<li>2 (<code>WebSocket.CLOSING</code>)    连接正在关闭</li>
<li>3 (<code>WebSocket.CLOSED</code>)    连接已关闭或者没有链接成功</li>
</ul>
<h3 id="WebSocket-url（只读）"><a href="#WebSocket-url（只读）" class="headerlink" title="WebSocket.url（只读）"></a><strong><code>WebSocket.url</code></strong>（只读）</h3><p>返回值为当构造函数创建 <code>WebSocket</code> 实例对象时URL的绝对路径。</p>
<p>语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> url = aWebSocket.url;</span><br></pre></td></tr></table></figure>

<p> 返回值：<code>DOMString</code>。</p>
<h2 id="WebSocket-对象的方法"><a href="#WebSocket-对象的方法" class="headerlink" title="WebSocket 对象的方法"></a>WebSocket 对象的方法</h2><h3 id="WebSocket-close"><a href="#WebSocket-close" class="headerlink" title="WebSocket.close()"></a><strong><code>WebSocket.close()</code></strong></h3><p>方法关闭 <code>WebSocket</code>连接或连接尝试（如果有的话）。 如果连接已经关闭,则此方法不执行任何操作。</p>
<p>语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">WebSocket.close();</span><br></pre></td></tr></table></figure>

<p>参数：</p>
<ul>
<li><code>code</code> （可选）一个数字状态码，它解释了连接关闭的原因。如果没有传这个参数，默认使用1005。</li>
<li><code>reason</code> （可选）一个人类可读的字符串，它解释了连接关闭的原因。这个UTF-8编码的字符串不能超过123个字节。</li>
</ul>
<h3 id="WebSocket-send"><a href="#WebSocket-send" class="headerlink" title="WebSocket.send()"></a><strong><code>WebSocket.send()</code></strong></h3><p>方法将需要通过 WebSocket 链接传输至服务器的数据排入队列，并根据所需要传输的data bytes的大小来增加 <code>bufferedAmount</code>的值 。若数据无法传输（例如数据需要缓存而缓冲区已满）时，套接字会自行关闭。</p>
<p>语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">WebSocket.send(<span class="string">"Hello server!"</span>);</span><br></pre></td></tr></table></figure>

<p>参数:</p>
<p><code>data</code>用于传输至服务器的数据。它必须是以下类型之一：</p>
<ul>
<li><code>USVString</code>     文本字符串。字符串将以 UTF-8 格式添加到缓冲区，并且 <code>bufferedAmount</code> 将加上该字符串以 UTF-8 格式编码时的字节数的值</li>
<li><code>ArrayBuffer</code>     您可以使用一有类型的数组对象发送底层二进制数据；其二进制数据内存将被缓存于缓冲区，<code>bufferedAmount</code> 将加上所需字节数的值。</li>
<li><code>Blob</code>     Blob 类型将队列 blob 中的原始数据以二进制中传输。 <code>bufferedAmount</code> 将加上原始数据的字节数的值。</li>
<li><code>ArrayBufferView</code>    您可以以二进制帧的形式发送任何 <strong>JavaScript 类数组对象</strong> ；其二进制数据内容将被队列于缓冲区中。值 <code>bufferedAmount</code> 将加上必要字节数的值。</li>
</ul>
<h2 id="WebSocket-对象的事件"><a href="#WebSocket-对象的事件" class="headerlink" title="WebSocket 对象的事件"></a>WebSocket 对象的事件</h2><p>WebSocket 对象使用 <code>addEventListener()</code> 或将一个事件监听器赋值给本接口的 <code>on*eventname*</code> 属性，来监听下面的事件。</p>
<h3 id="close-event"><a href="#close-event" class="headerlink" title="close event"></a>close event</h3><p>当与 WebSocket 的连接关闭时，会触发 close 事件。</p>
<p>您可能想知道连接何时关闭，以便您可以更新 UI，或者保存与已关闭连接有关的数据。例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">exampleSocket.addEventListener(<span class="string">'close'</span>, (event) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'The connection has been closed successfully.'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="error-event"><a href="#error-event" class="headerlink" title="error event"></a>error event</h3><p>当<code>websocket</code>的连接由于一些错误事件的发生 (例如无法发送一些数据)而被关闭时，一个<code>error</code>事件将被引发。例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create WebSocket connection</span></span><br><span class="line"><span class="comment">// 创建一个 WebSocket 连接</span></span><br><span class="line"><span class="keyword">const</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost:8080'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Listen for possible errors</span></span><br><span class="line"><span class="comment">// 监听可能发生的错误</span></span><br><span class="line">socket.addEventListener(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'WebSocket error: '</span>, event);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="message-event"><a href="#message-event" class="headerlink" title="message event"></a>message event</h3><p><code>message</code> 事件会在 <code>WebSocket</code> 接收到新消息时被触发。例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个 WebSocket 连接</span></span><br><span class="line"><span class="keyword">const</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost:8080'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听消息</span></span><br><span class="line">socket.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Message from server '</span>, event.data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="open-event"><a href="#open-event" class="headerlink" title="open event"></a>open event</h3><p>当一个 <code>WebSocket</code> 连接成功时触发。也可以通过 <code>onopen</code>属性来设置。例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create WebSocket connection.</span></span><br><span class="line"><span class="keyword">const</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost:8080'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Connection opened</span></span><br><span class="line">socket.addEventListener(<span class="string">'open'</span>, (event) =&gt; &#123;</span><br><span class="line">  socket.send(<span class="string">'Hello Server!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<blockquote>
<p>学习有趣的知识，结识有趣的朋友，塑造有趣的灵魂！</p>
<p>大家好！我是〖编程三昧〗的作者 <strong>隐逸王</strong>，我的公众号是『编程三昧』，欢迎关注，希望大家多多指教！</p>
</blockquote>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210603%20/20-18-27-sHach8.png" alt=""></p>
]]></content>
      <categories>
        <category>JavaScript - websocket</category>
      </categories>
      <tags>
        <tag>websocket</tag>
      </tags>
  </entry>
  <entry>
    <title>vim操作模式简介</title>
    <url>/yinyiwang/2021/07/05/vim%E6%93%8D%E4%BD%9C%E6%A8%A1%E5%BC%8F%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h3 id="何为-vim？"><a href="#何为-vim？" class="headerlink" title="何为 vim？"></a>何为 vim？</h3><p>vim 是从 vi 发展出来的一个文本编辑器。代码补全、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用，和 Emacs 并列成为类 Unix 系统用户最喜欢的文本编辑器。</p>
<p>vim 的设计理念是命令的组合。用户学习了各种各样的文本间移动/跳转的命令和其他的普通模式的编辑命令，并且能够灵活组合使用的话，能够比那些没有模式的编辑器更加高效的进行文本编辑。</p>
<p>同时 vim 与很多快捷键设置和正则表达式类似,可以辅助记忆。并且 vim 针对程序员做了优化。</p>
<a id="more"></a>

<h3 id="vim-的三种操作模式"><a href="#vim-的三种操作模式" class="headerlink" title="vim 的三种操作模式"></a>vim 的三种操作模式</h3><p>vim 有三种操作模式，分别是命令模式（Command mode）、输入模式（Insert mode）和底线命令模式（Last line mode）。</p>
<p>三种模式切换快捷键：</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>命令模式</td>
<td>ESC</td>
</tr>
<tr>
<td>输入模式</td>
<td>i或a</td>
</tr>
<tr>
<td>底线命令模式</td>
<td>:</td>
</tr>
</tbody></table>
<h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><p>在命令模式中控制光标移动和输入命令，可对文本进行复制、粘贴、删除和查找等工作。</p>
<p>使用命令 <code>vim filename</code> 后进入编辑器视图后，默认模式就是命令模式，此时敲击键盘字母会被识别为一个命令，例如在键盘上连续敲击两次d，就会删除光标所在行。</p>
<p>以下是在命令模式中常用的快捷操作：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>光标左移</td>
<td>h</td>
</tr>
<tr>
<td>光标右移</td>
<td>l（小写L）</td>
</tr>
<tr>
<td>光标上移</td>
<td>k</td>
</tr>
<tr>
<td>光标下移</td>
<td>j</td>
</tr>
<tr>
<td>光标移动到下一个单词</td>
<td>w</td>
</tr>
<tr>
<td>光标移动到上一个单词</td>
<td>b</td>
</tr>
<tr>
<td>移动游标到第n行</td>
<td>nG</td>
</tr>
<tr>
<td>移动游标到第一行</td>
<td>gg</td>
</tr>
<tr>
<td>移动游标到最后一行</td>
<td>G</td>
</tr>
<tr>
<td>快速回到上一次光标所在位置</td>
<td>Ctrl+o</td>
</tr>
<tr>
<td>删除当前字符</td>
<td>x</td>
</tr>
<tr>
<td>删除前一个字符</td>
<td>X</td>
</tr>
<tr>
<td>删除整行</td>
<td>dd</td>
</tr>
<tr>
<td>删除一个单词</td>
<td>dw或daw</td>
</tr>
<tr>
<td>删除至行尾</td>
<td>d$或D</td>
</tr>
<tr>
<td>删除至行首</td>
<td>d^</td>
</tr>
<tr>
<td>删除到文档末尾</td>
<td>dG</td>
</tr>
<tr>
<td>删除至文档首部</td>
<td>d1G</td>
</tr>
<tr>
<td>删除n行</td>
<td>ndd</td>
</tr>
<tr>
<td>删除n个连续字符</td>
<td>nx</td>
</tr>
<tr>
<td>将光标所在位置字母变成大写或小写</td>
<td>~</td>
</tr>
<tr>
<td>复制游标所在的整行</td>
<td>yy（3yy表示复制3行）</td>
</tr>
<tr>
<td>粘贴至光标后（下）</td>
<td>p</td>
</tr>
<tr>
<td>粘贴至光标前（上）</td>
<td>P</td>
</tr>
<tr>
<td>剪切</td>
<td>dd</td>
</tr>
<tr>
<td>交换上下行</td>
<td>ddp</td>
</tr>
<tr>
<td>替换整行，即删除游标所在行并进入插入模式</td>
<td>cc</td>
</tr>
<tr>
<td>撤销一次或n次操作</td>
<td>u{n}</td>
</tr>
<tr>
<td>撤销当前行的所有修改</td>
<td>U</td>
</tr>
<tr>
<td>恢复撤销操作</td>
<td>Ctrl+r</td>
</tr>
<tr>
<td>整行将向右缩进</td>
<td>&gt;&gt;</td>
</tr>
<tr>
<td>整行将向左退回</td>
<td>&lt;&lt;</td>
</tr>
<tr>
<td>若档案没有更动，则不储存离开，若档案已经被更动过，则储存后离开</td>
<td>ZZ</td>
</tr>
</tbody></table>
<h4 id="输入模式"><a href="#输入模式" class="headerlink" title="输入模式"></a>输入模式</h4><p>在命令模式下按i或a键就进入了输入模式，在输入模式下，您可以正常的使用键盘按键对文本进行插入和删除等操作。</p>
<p>以下是输入模式常用的快捷键操作：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>换行</td>
<td>Enter</td>
</tr>
<tr>
<td>删除光标前一个字符</td>
<td>Space</td>
</tr>
<tr>
<td>删除光标后一个字符</td>
<td>Delete</td>
</tr>
<tr>
<td>在文本中移动光标</td>
<td>方向键</td>
</tr>
<tr>
<td>移动光标到行首/行尾</td>
<td>Home/End</td>
</tr>
<tr>
<td>切换光标为输入/替换模式</td>
<td>Insert</td>
</tr>
<tr>
<td>退出输入模式，切换到命令模式</td>
<td>Esc</td>
</tr>
</tbody></table>
<h4 id="底线命令模式"><a href="#底线命令模式" class="headerlink" title="底线命令模式"></a>底线命令模式</h4><p>在命令模式下按<code>:</code>键就进入了底线命令模式，在底线命令模式中可以输入单个或多个字符的命令。</p>
<p>以下是底线命令模式中常用的快捷操作：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>保存</td>
<td>:w</td>
</tr>
<tr>
<td>退出</td>
<td>:q</td>
</tr>
<tr>
<td>保存并退出</td>
<td>:wq（<code>:wq!</code>表示强制保存退出）</td>
</tr>
<tr>
<td>将文件另存为其他文件名</td>
<td>:w new_filename</td>
</tr>
<tr>
<td>显示行号</td>
<td>:set nu</td>
</tr>
<tr>
<td>取消行号</td>
<td>:set nonu</td>
</tr>
<tr>
<td>使本行内容居中</td>
<td>:ce</td>
</tr>
<tr>
<td>使本行文本靠右</td>
<td>:ri</td>
</tr>
<tr>
<td>使本行内容靠左</td>
<td>:le</td>
</tr>
<tr>
<td>向光标之下寻找一个名称为word的字符串</td>
<td>:/word</td>
</tr>
<tr>
<td>向光标之上寻找一个字符串名称为word的字符串</td>
<td>:?word</td>
</tr>
<tr>
<td>重复前一个搜寻的动作</td>
<td>:n</td>
</tr>
<tr>
<td>从第一行到最后一行寻找word1字符串，并将该字符串取代为word2</td>
<td><code>:1,$s/word1/word2/g</code>或<code>:%s/word1/word2/g</code></td>
</tr>
</tbody></table>
<p>我们可以参考以下图示来理解这三种模式：</p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210601%20/18-16-14-zD26lP.png" alt="img"></p>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>在本示例将使用vim在文本文件中写入一首唐诗。</p>
<ol>
<li><h5 id="新建一个文件并进入vim命令模式。"><a href="#新建一个文件并进入vim命令模式。" class="headerlink" title="新建一个文件并进入vim命令模式。"></a>新建一个文件并进入vim命令模式。</h5></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim 静夜思.txt</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210601%20/18-21-12-NFNeja.png" alt="image-20210601182109882"></p>
<blockquote>
<p>直接输入 <strong>vim 文件名</strong> 就能够进入 vi 的一般模式了。请注意，记得 vi 后面一定要加文件名，不管该文件存在与否！</p>
</blockquote>
<ol start="2">
<li><h5 id="按下i进入输入模式，输入《静夜思》的诗名。"><a href="#按下i进入输入模式，输入《静夜思》的诗名。" class="headerlink" title="按下i进入输入模式，输入《静夜思》的诗名。"></a>按下<code>i</code>进入输入模式，输入《静夜思》的诗名。</h5></li>
</ol>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210601%20/18-25-25-nrei2t.png" alt="image-20210601182524439"></p>
<blockquote>
<p>在一般模式之中，只要按下 i, o, a 等字符就可以进入输入模式了！<br>在编辑模式当中，你可以发现在左下角状态栏中会出现 –INSERT- 的字样，那就是可以输入任意字符的提示。<br>这个时候，键盘上除了 <strong>Esc</strong> 这个按键之外，其他的按键都可以视作为一般的输入按钮了，所以你可以进行任何的编辑。</p>
</blockquote>
<ol start="3">
<li><h5 id="按下-ECS-键回到命令模式，并输入底线命令-ce，使诗名居中。"><a href="#按下-ECS-键回到命令模式，并输入底线命令-ce，使诗名居中。" class="headerlink" title="按下 ECS 键回到命令模式，并输入底线命令:ce，使诗名居中。"></a>按下 ECS 键回到命令模式，并输入底线命令<code>:ce</code>，使诗名居中。</h5></li>
</ol>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210601%20/18-26-12-le7WUU.png" alt="image-20210601182610170"></p>
<ol start="4">
<li><h5 id="按下o键换行并进入输入模式，输入第一行诗。"><a href="#按下o键换行并进入输入模式，输入第一行诗。" class="headerlink" title="按下o键换行并进入输入模式，输入第一行诗。"></a>按下<code>o</code>键换行并进入输入模式，输入第一行诗。</h5></li>
</ol>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210601%20/18-29-12-qX8VDR.png" alt="image-20210601182910542"></p>
<ol start="5">
<li><h5 id="按下-ECS-键回到命令模式，并输入底线命令-ce，使第一行诗居中。"><a href="#按下-ECS-键回到命令模式，并输入底线命令-ce，使第一行诗居中。" class="headerlink" title="按下 ECS 键回到命令模式，并输入底线命令:ce，使第一行诗居中。"></a>按下 ECS 键回到命令模式，并输入底线命令<code>:ce</code>，使第一行诗居中。</h5></li>
</ol>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210601%20/18-30-02-D5XAEI.png" alt="image-20210601183000687"></p>
<ol start="6">
<li><h5 id="按下o键换行并进入输入模式，输入第二行诗。"><a href="#按下o键换行并进入输入模式，输入第二行诗。" class="headerlink" title="按下o键换行并进入输入模式，输入第二行诗。"></a>按下<code>o</code>键换行并进入输入模式，输入第二行诗。</h5></li>
</ol>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210601%20/18-31-01-IkfdTe.png" alt="image-20210601183100061"></p>
<ol start="7">
<li><h5 id="按下-ECS-键回到命令模式，并输入底线命令-ce，使第二行诗居中。"><a href="#按下-ECS-键回到命令模式，并输入底线命令-ce，使第二行诗居中。" class="headerlink" title="按下 ECS 键回到命令模式，并输入底线命令:ce，使第二行诗居中。"></a>按下 ECS 键回到命令模式，并输入底线命令<code>:ce</code>，使第二行诗居中。</h5></li>
</ol>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210601%20/18-31-28-nRnVNF.png" alt="image-20210601183126651"></p>
<ol start="8">
<li><h5 id="在命令模式中执行底线命令-wq离开-vim。"><a href="#在命令模式中执行底线命令-wq离开-vim。" class="headerlink" title="在命令模式中执行底线命令:wq离开 vim。"></a>在命令模式中执行底线命令<code>:wq</code>离开 vim。</h5></li>
</ol>
<blockquote>
<p>学习有趣的知识，结识有趣的朋友，塑造有趣的灵魂！</p>
</blockquote>
<blockquote>
<p>大家好，我是编程三昧的作者隐逸王，我的公众号是编程三昧，希望大家多多指教！</p>
</blockquote>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack 简介</title>
    <url>/yinyiwang/2021/07/05/webpack-%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<blockquote>
<p>构建其实是工程化、自动化思想在前端开发中的体现，把一系列流程用代码去实现，让代码自动化地执行这一系列复杂的流程。 构建给前端开发注入了更大的活力，解放了我们的生产力。</p>
</blockquote>
<p>Webpack 凭借强大的功能与良好的使用体验，已经成为目前最流行，社区最活跃的构建工具，是现代 Web 开发必须掌握的技能之一。</p>
<a id="more"></a>

<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在当下的前端环境里，各种框架和工具层出不穷，比如 React、Vue、Angular 等，极大的提高了我们的开发效率，但是，他们都有一个共同点：源代码无法直接运行，必须经过转换之后才可执行。</p>
<p>而转换代码的这个过程我们可以称之为<strong>构建</strong>，被用来进行构建的工具我们叫做<strong>构建工具</strong>，而 Webpack 便是其中的佼佼者。</p>
<p>构建工具的常规作用：</p>
<ul>
<li>代码转换：TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等。</li>
<li>文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等。</li>
<li>代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载。</li>
<li>模块合并：在采用模块化的项目里会有很多个模块和文件，需要构建功能把模块分类合并成一个文件。</li>
<li>自动刷新：监听本地源代码的变化，自动重新构建、刷新浏览器。</li>
<li>代码校验：在代码被提交到仓库前需要校验代码是否符合规范，以及单元测试是否通过。</li>
<li>自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统。</li>
</ul>
<h2 id="Webpack-的概念"><a href="#Webpack-的概念" class="headerlink" title="Webpack 的概念"></a>Webpack 的概念</h2><p>Webpack 是使用 NodeJs 开发出来的一个构建工具，本质上，它是一个现代 JavaScript 应用程序的<strong>静态模块打包器</strong>（module bundler）。</p>
<p>当 Webpack 处理应用程序时，它会递归地构建一个<strong>依赖关系图</strong>（dependency graph），其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 <strong>bundle</strong>。</p>
<p>在 Webpack 里一切文件皆模块，通过 Loader 转换文件，通过 Plugin 注入钩子，最后输出由多个模块组合成的文件。</p>
<p>Webpack 专注于构建模块化项目。借用 Webpack 官网首页的图片来看一下它到底是什么：</p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210611%20/18-19-00-gwHsaA.png" alt="Wepack"></p>
<blockquote>
<p>一切文件：JavaScript、CSS、SCSS、图片、模板，在 Webpack 眼中都是一个个模块，这样的好处是能清晰地描述出各个模块之间的依赖关系，以方便 Webpack 对模块进行组合和打包。 经过 Webpack 的处理，最终会输出浏览器能使用的静态资源。</p>
</blockquote>
<h2 id="Webpack-的基本配置"><a href="#Webpack-的基本配置" class="headerlink" title="Webpack 的基本配置"></a>Webpack 的基本配置</h2><p>以下是 Webpack 的基本配置，主要包含了 webpack 的四个<strong>核心概念</strong>：</p>
<ul>
<li>入口(entry)</li>
<li>输出(output)</li>
<li>loader</li>
<li>插件(plugins)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// 模式配置</span></span><br><span class="line">    mode: <span class="string">"production"</span>, <span class="comment">// "production" | "development" | "none"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入口文件</span></span><br><span class="line">    entry: <span class="string">"./app/entry"</span>, <span class="comment">// string | object | array</span></span><br><span class="line"></span><br><span class="line">    output: &#123;</span><br><span class="line">        <span class="comment">// webpack 如何输出结果的相关选项</span></span><br><span class="line">        path: path.resolve(__dirname,</span><br><span class="line">            <span class="string">"dist"</span>), <span class="comment">// string</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        <span class="comment">// 关于模块配置</span></span><br><span class="line">        rules: [</span><br><span class="line">            <span class="comment">// 模块规则（配置 loader、解析器等选项）</span></span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.jsx?$/</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插件</span></span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Webpack-的优缺点"><a href="#Webpack-的优缺点" class="headerlink" title="Webpack 的优缺点"></a>Webpack 的优缺点</h2><p>优点：</p>
<ul>
<li>专注于处理模块化的项目，能做到开箱即用一步到位；</li>
<li>通过 Plugin 扩展，完整好用又不失灵活；</li>
<li>使用场景不仅限于 Web 开发；</li>
<li>社区庞大活跃，经常引入紧跟时代发展的新特性，能为大多数场景找到已有的开源扩展；</li>
<li>良好的开发体验。</li>
</ul>
<p>缺点：</p>
<ul>
<li>只能采用模块化开发</li>
</ul>
<h2 id="选择-Webpack-的原因"><a href="#选择-Webpack-的原因" class="headerlink" title="选择 Webpack 的原因"></a>选择 Webpack 的原因</h2><p>Webpack 能成为众多构建工具中的佼佼者，主要有以下原因：</p>
<ul>
<li>大多数团队在开发新项目时会采用紧跟时代的技术，这些技术几乎都会采用“模块化+新语言+新框架”，Webpack 可以为这些新项目提供一站式的解决方案；</li>
<li>Webpack 有良好的生态链和维护团队，能提供良好的开发体验和保证质量；</li>
<li>Webpack 被全世界的大量 Web 开发者使用和验证，能找到各个层面所需的教程和经验分享。</li>
</ul>
<p>（本文完）</p>
<blockquote>
<p>学习有趣的知识，结识有趣的朋友，塑造有趣的灵魂！</p>
<p>大家好！我是〖编程三昧〗的作者 <strong>隐逸王</strong>，我的公众号是『编程三昧』，欢迎关注，希望大家多多指教！</p>
<p>知识与技能并重，内力和外功兼修，理论和实践两手都要抓、两手都要硬！</p>
</blockquote>
]]></content>
      <categories>
        <category>工具</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是算法的时间复杂度和空间复杂度？</title>
    <url>/yinyiwang/2021/07/05/%E4%BB%80%E4%B9%88%E6%98%AF%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%9F/</url>
    <content><![CDATA[<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210630%20/20-45-48-xbSQ9g.png" alt="iShot2021-06-30 20.45.18"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>针对某一类问题的解决，我们可能需要借助算法来实现，实现的手段也可能是各式各样的。虽然最终都解决了问题，但是各个解决手段，也就是算法还是存在优劣之分的。</p>
<p>既然存在比较，那肯定就有一个标准供来参考，那么我们在评价一个算法的优劣时参考的标准是什么呢？</p>
<p>算法的优劣主要从它执行时所占用的「时间」和「空间」两个方面来进行评定，也就是我们常听到的「时间复杂度」和「空间复杂度」。</p>
<ul>
<li>时间复杂度：执行算法所需要的计算工作量，可以估算出程序对处理器的使用程度。</li>
<li>空间复杂度：执行当前算法所需要的内存空间，可以估算出程序对处理器的使用程度。</li>
</ul>
<a id="more"></a>

<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>谈到是时间复杂度，我们很多人的第一反应就是将算法执行一遍，打印出其执行的时间就是它所消耗的时间，其实这样是不可行的，因为：</p>
<ul>
<li>解决一个问题的算法可能有很多种，一一实现的工作量无疑是巨大的，得不偿失；</li>
<li>不同计算机的软、硬件环境不同，即便使用同一台计算机，不同时间段其系统环境也不相同，程序的运行时间很可能会受影响，严重时甚至会导致误判。</li>
</ul>
<p>实际场景中，我们更喜欢用一个估值来表示算法所编程序的运行时间。所谓估值，即估计的、并不准确的值。注意，虽然估值无法准确的表示算法所编程序的运行时间，但它的得来并非凭空揣测，需要经过缜密的计算后才能得出。</p>
<blockquote>
<p>表示一个算法所编程序运行时间的多少，用的并不是准确值（事实上也无法得出），而是根据合理方法得到的预估值。</p>
</blockquote>
<p>我们一般用“<strong>大 O 符号表示法</strong>”来表示时间复杂度：T(n) = O(f(n)) </p>
<ul>
<li>n 是影响复杂度变化的因子</li>
<li>f(n) 是复杂度具体的算法</li>
<li>O 表示正比例关系</li>
</ul>
<p>这个公式的全称是：<strong>算法的渐进时间复杂度</strong>。</p>
<blockquote>
<p>大 O 符号表示法并不是用于来真实代表算法的执行时间的，它是用来表示代码执行时间的增长变化趋势的。</p>
</blockquote>
<p>我们来看一个常见的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; n; index++)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，这段程序中仅有 2 行代码，其中：</p>
<ul>
<li>for 循环从 index 的值为 0 一直逐增至 n（注意，循环退出的时候 index 值为 n），因此 for 循环语句执行了 n+1 次；</li>
<li>而循环内部仅有一条语句，index 的值每增 1 该语句就执行一次，一直到 index 的值为 n-1，因此，打印语句一共执行了 n 次。</li>
</ul>
<p>因此，整段代码中所有语句共执行了 (n+1)+n 次，即 2n+1 次。数据结构中，每条语句的执行次数，又被称为该语句的频度。整段代码的总执行次数，即整段代码的频度。</p>
<h3 id="常见的时间复杂度量级"><a href="#常见的时间复杂度量级" class="headerlink" title="常见的时间复杂度量级"></a>常见的时间复杂度量级</h3><ul>
<li>常数阶O(1)</li>
<li>对数阶O(logN)</li>
<li>线性阶O(n)</li>
<li>平方阶O(n^2)</li>
<li>立方阶O(n^3)</li>
<li>K次方阶O(n^k)</li>
<li>指数阶(2^n)</li>
</ul>
<blockquote>
<p>这里仅介绍了以最坏情况下的频度作为时间复杂度，而在某些实际场景中，还可以用最好情况下的频度和最坏情况下的频度的平均值来作为算法的时间复杂度。</p>
</blockquote>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>和时间复杂度类似，一个算法的空间复杂度，也常用大 O 记法表示。空间复杂度比较常用的有：</p>
<ul>
<li>O(1)</li>
<li>O(n)</li>
<li>O(n²)</li>
</ul>
<p>要知道每一个算法所编写的程序，运行过程中都需要占用大小不等的存储空间，例如：</p>
<ul>
<li><p>程序代码本身所占用的存储空间；</p>
</li>
<li><p>程序中如果需要输入输出数据，也会占用一定的存储空间；</p>
</li>
<li><p>程序在运行过程中，可能还需要临时申请更多的存储空间。</p>
</li>
</ul>
<p>首先，程序自身所占用的存储空间取决于其包含的代码量，如果要压缩这部分存储空间，就要求我们在实现功能的同时，尽可能编写足够短的代码。</p>
<p>程序运行过程中输入输出的数据，往往由要解决的问题而定，即便所用算法不同，程序输入输出所占用的存储空间也是相近的。</p>
<p>事实上，对算法的空间复杂度影响最大的，往往是程序运行过程中所申请的临时存储空间。不同的算法所编写出的程序，其运行时申请的临时存储空间通常会有较大不同。</p>
<p>如果程序所占用的存储空间和输入值无关，则该程序的空间复杂度就为 O(1)；反之，如果有关，则需要进一步判断它们之间的关系：</p>
<ul>
<li>如果随着输入值 n 的增大，程序申请的临时空间成线性增长，则程序的空间复杂度用 O(n) 表示;</li>
<li>如果随着输入值 n 的增大，程序申请的临时空间成 n2 关系增长，则程序的空间复杂度用 O(n2) 表示；</li>
<li>如果随着输入值 n 的增大，程序申请的临时空间成 n3 关系增长，则程序的空间复杂度用 O(n3) 表示；</li>
</ul>
<p>比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> m = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; <span class="number">9999</span>; index++)&#123;</span><br><span class="line">	m++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然 m 的值随着 index 的增加在一直变化，可是并未产生新的变量，即程序所占用的空间并未发生变化，所以，它的空间复杂度为 O(1)。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><p>时间复杂度和空间复杂度都是一种经过严谨推算得出的预估值，并不能代表实际情况。</p>
</li>
<li><p>时间复杂度和空间复杂度代表的是一种趋势。</p>
</li>
<li><p>我们一般情况下所说的时间复杂度和空间复杂度，都是最坏情况下的执行趋势，实际情况可能比预估的要好。</p>
</li>
<li><p>多数业务场景下，一个好的算法往往更注重的是时间复杂度的比较，而空间复杂度只要在一个合理的范围内就可以。</p>
</li>
</ol>
<p>~</p>
<p>~ 本文完，感谢阅读！</p>
<p>~</p>
<blockquote>
<p>学习有趣的知识，结识有趣的朋友，塑造有趣的灵魂！</p>
<p>大家好，我是〖<a href="https://juejin.cn/user/2893570333750744/posts" target="_blank" rel="noopener">编程三昧</a>〗的作者 <strong>隐逸王</strong>，我的公众号是『<a href="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210604%20/19-26-03-txvEvM.png" target="_blank" rel="noopener">编程三昧</a>』，欢迎关注，希望大家多多指教！</p>
<p>你来，怀揣期望，我有墨香相迎！ 你归，无论得失，唯以余韵相赠！</p>
<p>知识与技能并重，内力和外功兼修，理论和实践两手都要抓、两手都要硬！</p>
</blockquote>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210630%20/20-46-44-YwjUXF.jpg" alt="自由职业者, 工作空间, Coworking, 办公桌, 办公室, 计算机, 技术, 财经, 市场营销, 工作"></p>
]]></content>
      <categories>
        <category>概念</category>
      </categories>
      <tags>
        <tag>时间复杂度</tag>
        <tag>空间复杂度</tag>
      </tags>
  </entry>
  <entry>
    <title>优化代码逻辑判断</title>
    <url>/yinyiwang/2021/07/05/%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81%E9%80%BB%E8%BE%91%E5%88%A4%E6%96%AD/</url>
    <content><![CDATA[<p>我们日常使用到的逻辑判断语句有 <code>if...else...</code>、<code>switch...case...</code>、<code>do...while...</code>等。</p>
<p>在简单场景下，我们可能对这些语法的性能没有什么感觉，但当遇到复杂的业务场景时，如果处理不善，就会出现大量的逻辑嵌套，可读性差并且难以扩展。</p>
<p>千里之行始于足下，编写高可维护性和高质量的代码，我们就需要从细节处入手，我们今天主要讨论 <code>JavaScript</code> 中如何优化逻辑判断代码。</p>
<a id="more"></a>

<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210607%20/20-36-35-G4gIfP.jpeg" alt="R54dad6197ce9d42a7fd8c7b23e4b5a18"></p>
<h2 id="嵌套层级优化"><a href="#嵌套层级优化" class="headerlink" title="嵌套层级优化"></a>嵌套层级优化</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">supply</span>(<span class="params">fruit, quantity</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> redFruits = [<span class="string">'apple'</span>, <span class="string">'strawberry'</span>, <span class="string">'cherry'</span>, <span class="string">'cranberries'</span>];</span><br><span class="line">    <span class="comment">// 条件 1: 水果存在</span></span><br><span class="line">    <span class="keyword">if</span> (fruit) &#123;</span><br><span class="line">        <span class="comment">// 条件 2: 属于红色水果</span></span><br><span class="line">        <span class="keyword">if</span> (redFruits.includes(fruit)) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'红色水果'</span>);</span><br><span class="line">            <span class="comment">// 条件 3: 水果数量大于 10 个</span></span><br><span class="line">            <span class="keyword">if</span> (quantity &gt; <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'数量大于 10 个'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'没有水果啦!'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面这个例子，我们可以看到：判断流程中规中矩，符合现实世界的映射。但是，因代码层层嵌套，导致阅读和维护都存在困难。</p>
<p>如果传入了 <code>fruit</code> 参数，则每次执行都至少需要经过两步 if 判断，在性能上也存在问题。</p>
<p>我们来对上面的代码进行一下优化处理：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">supply</span>(<span class="params">fruit, quantity</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> redFruits = [<span class="string">'apple'</span>, <span class="string">'strawberry'</span>, <span class="string">'cherry'</span>, <span class="string">'cranberries'</span>];</span><br><span class="line">    <span class="keyword">if</span> (!fruit) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'没有水果啦'</span>);     <span class="comment">// 条件 1: 当 fruit 无效时，提前处理错误</span></span><br><span class="line">    <span class="keyword">if</span> (!redFruits.includes(fruit)) <span class="keyword">return</span>; <span class="comment">// 条件 2: 当不是红色水果时，提前 return</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'红色水果'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 条件 3: 水果数量大于 10 个</span></span><br><span class="line">    <span class="keyword">if</span> (quantity &gt; <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'数量大于 10 个'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要对嵌套层级做了优化，提前终止掉了不符合的条件，将三层嵌套减少到了一层，简化了代码结果结构，增强了可阅读性。</p>
<h2 id="多条件分支的优化"><a href="#多条件分支的优化" class="headerlink" title="多条件分支的优化"></a>多条件分支的优化</h2><p>相信我们很多人对下面这种代码不陌生吧？（想想刚开始写代码那会啊）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pick</span>(<span class="params">color</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 根据颜色选择水果</span></span><br><span class="line">    <span class="keyword">if</span> (color === <span class="string">'red'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">'apple'</span>, <span class="string">'strawberry'</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (color === <span class="string">'yellow'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">'banana'</span>, <span class="string">'pineapple'</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (color === <span class="string">'purple'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">'grape'</span>, <span class="string">'plum'</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们需要知道一点原则：if else 更适合于条件区间判断，而 switch case 更适合于具体枚举值的分支判断。</p>
<p>我们使用 switch…case…进行一下改写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pick</span>(<span class="params">color</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 根据颜色选择水果</span></span><br><span class="line">    <span class="keyword">switch</span> (color) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'red'</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="string">'apple'</span>, <span class="string">'strawberry'</span>];</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'yellow'</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="string">'banana'</span>, <span class="string">'pineapple'</span>];</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'purple'</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="string">'grape'</span>, <span class="string">'plum'</span>];</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>switch...case...</code> 优化之后的代码看上去格式整齐，思路很清晰，但还是很冗长。继续优化：</p>
<ul>
<li>借助 <em>Object</em> 的 {key: value} 结构，我们可以在 <em>Object</em> 中枚举所有的情况，然后将 key 作为索引，直接通过 <em>Object</em>.key 或者 <em>Object</em>[key] 来获取内容:</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fruitColor = &#123;</span><br><span class="line">    red: [<span class="string">'apple'</span>, <span class="string">'strawberry'</span>],</span><br><span class="line">    yellow: [<span class="string">'banana'</span>, <span class="string">'pineapple'</span>],</span><br><span class="line">    purple: [<span class="string">'grape'</span>, <span class="string">'plum'</span>],</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pick</span>(<span class="params">color</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fruitColor[color] || [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <em>Map</em> 数据结构，真正的(key, value) 键值对结构:</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fruitColor = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">    .set(<span class="string">'red'</span>, [<span class="string">'apple'</span>, <span class="string">'strawberry'</span>])</span><br><span class="line">    .set(<span class="string">'yellow'</span>, [<span class="string">'banana'</span>, <span class="string">'pineapple'</span>])</span><br><span class="line">    .set(<span class="string">'purple'</span>, [<span class="string">'grape'</span>, <span class="string">'plum'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pick</span>(<span class="params">color</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fruitColor.get(color) || [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化之后，代码更简洁、更容易扩展。</p>
<p>为了更好的可读性，还可以通过更加语义化的方式定义对象，然后使用 Array.filter 达到同样的效果:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fruits = [</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">'apple'</span>, <span class="attr">color</span>: <span class="string">'red'</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">'strawberry'</span>, <span class="attr">color</span>: <span class="string">'red'</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">'banana'</span>, <span class="attr">color</span>: <span class="string">'yellow'</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">'pineapple'</span>, <span class="attr">color</span>: <span class="string">'yellow'</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">'grape'</span>, <span class="attr">color</span>: <span class="string">'purple'</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">'plum'</span>, <span class="attr">color</span>: <span class="string">'purple'</span>&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pick</span>(<span class="params">color</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fruits.filter(<span class="function"><span class="params">f</span> =&gt;</span> f.color == color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面使用的例子和手段都比较初级，但是其中的思想却值得我们细品，希望大家能够有所收获！</p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210607%20/20-36-58-pQ0j01.png" alt="Rae9e3dd90e39afb101b1ea3b1c9d373b"></p>
<blockquote>
<p>学习有趣的知识，结识有趣的朋友，塑造有趣的灵魂！</p>
<p>大家好！我是〖编程三昧〗的作者 <strong>隐逸王</strong>，我的公众号是『编程三昧』，欢迎关注，希望大家多多指教！</p>
<p>知识与技能并重，内力和外功兼修，理论和实践两手都要抓、两手都要硬！</p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>代码逻辑</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript数组reduce() 方法</title>
    <url>/yinyiwang/2021/07/05/JavaScript%E6%95%B0%E7%BB%84reduce-%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>reduce() 方法为数组中的每一个元素依次执行回调函数（不包括数组中被删除或从未被赋值的元素），返回一个具体的结果。</p>
<a id="more"></a>

<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>reduce() 接收两个参数，其基本语法为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.reduce(callback,[initialValue])</span><br></pre></td></tr></table></figure>

<p><strong>参数解析：</strong></p>
<p><em>callback</em>  执行数组中每个值的函数，包含四个参数：</p>
<ul>
<li><em>previousValue</em>    第一项的值或者上一次叠加的结果值，或者是提供的初始值（initialValue）</li>
<li><em>currentValue</em>    数组中当前被处理的元素</li>
<li><em>index</em>     当前元素在数组中的索引</li>
<li><em>array</em>     数组本身</li>
</ul>
<p><em>initialValue</em> (可选)    作为第一次调用 callback 的第一个参数，可以控制返回值的格式</p>
<p>reduce() 方法可以使用以下这个表达式总结一下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)</span><br></pre></td></tr></table></figure>

<h2 id="基本示例"><a href="#基本示例" class="headerlink" title="基本示例"></a>基本示例</h2><p>我们通过下面这个例子，来直观认识一下 reduce() 的各个参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>];</span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">arr.reduce(<span class="function">(<span class="params">pre, cur, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`第<span class="subst">$&#123; i + <span class="number">1</span> &#125;</span>次执行：pre:<span class="subst">$&#123; pre &#125;</span>,cur:<span class="subst">$&#123; cur &#125;</span>,index:<span class="subst">$&#123; index &#125;</span>`</span>);</span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">return</span> pre + cur;</span><br><span class="line">&#125;, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第1次执行：pre: 10, cur: 2, index: 0</span></span><br><span class="line"><span class="comment">// 第2次执行：pre: 12, cur: 4, index: 1</span></span><br><span class="line"><span class="comment">// 第3次执行：pre: 16, cur: 6, index: 2</span></span><br><span class="line"><span class="comment">// 第4次执行：pre: 22, cur: 8, index: 3</span></span><br><span class="line"><span class="comment">// 第5次执行：pre: 30, cur: 10, index: 4</span></span><br><span class="line"><span class="comment">// 40</span></span><br></pre></td></tr></table></figure>

<p>代码分析：</p>
<ul>
<li>数组中的元素依次执行了回调函数。</li>
<li>因为给 initialValue 赋了初始值 10，所以第一次执行时， pre 的值默认从 10 开始。</li>
<li>每次执行时，pre 的值都是 cur 元素前的所有元素之和。</li>
<li>最后返回数组所有元素累加的和。</li>
</ul>
<p>我们再看一下不传 initialValue 参数的执行结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>];</span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">arr.reduce(<span class="function">(<span class="params">pre, cur, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`第<span class="subst">$&#123; i + <span class="number">1</span> &#125;</span>次执行：pre:<span class="subst">$&#123; pre &#125;</span>,cur:<span class="subst">$&#123; cur &#125;</span>,index:<span class="subst">$&#123; index &#125;</span>`</span>);</span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">return</span> pre + cur;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第1次执行：pre: 2, cur: 4, index: 1</span></span><br><span class="line"><span class="comment">// 22 第2次执行：pre: 6, cur: 6, index: 2</span></span><br><span class="line"><span class="comment">// 22 第3次执行：pre: 12, cur: 8, index: 3</span></span><br><span class="line"><span class="comment">// 22 第4次执行：pre: 20, cur: 10, index: 4</span></span><br><span class="line"><span class="comment">// 30</span></span><br></pre></td></tr></table></figure>

<p>可以看到，这里只执行了四次，且是从数组的第二位开始执行的，数组的第一位默认作为了 pre 的值。</p>
<h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><p>除了上面的基本应用之外，reduce() 方法还有以下应用。</p>
<h3 id="计算数组中每个元素出现的次数"><a href="#计算数组中每个元素出现的次数" class="headerlink" title="计算数组中每个元素出现的次数"></a>计算数组中每个元素出现的次数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">'name'</span>, <span class="string">'age'</span>, <span class="string">'long'</span>, <span class="string">'short'</span>, <span class="string">'long'</span>, <span class="string">'name'</span>, <span class="string">'name'</span>]</span><br><span class="line"></span><br><span class="line">arr.reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(pre, cur)</span><br><span class="line">    <span class="keyword">if</span> (cur <span class="keyword">in</span> pre) &#123;</span><br><span class="line">        pre[cur]++</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pre[cur] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre</span><br><span class="line">&#125;, &#123;&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123; &#125; "name"</span></span><br><span class="line"><span class="comment">// &#123;name: 1&#125; "age"</span></span><br><span class="line"><span class="comment">// &#123;name: 1, age: 1&#125; "long"</span></span><br><span class="line"><span class="comment">// &#123;name: 1, age: 1, long: 1&#125; "short"</span></span><br><span class="line"><span class="comment">// &#123;name: 1, age: 1, long: 1, short: 1&#125; "long"</span></span><br><span class="line"><span class="comment">// &#123;name: 1, age: 1, long: 2, short: 1&#125; "name"</span></span><br><span class="line"><span class="comment">// &#123;name: 2, age: 1, long: 2, short: 1&#125; "name"</span></span><br><span class="line"><span class="comment">// &#123;name: 3, age: 1, long: 2, short: 1&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">'name'</span>, <span class="string">'age'</span>, <span class="string">'long'</span>, <span class="string">'short'</span>, <span class="string">'long'</span>, <span class="string">'name'</span>, <span class="string">'name'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arrResult = arr.reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!pre.includes(cur)) &#123;</span><br><span class="line">        pre.push(cur)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;, [])</span><br><span class="line"></span><br><span class="line"><span class="comment">// ["name", "age", "long", "short"]</span></span><br></pre></td></tr></table></figure>

<h3 id="对象属性求和"><a href="#对象属性求和" class="headerlink" title="对象属性求和"></a>对象属性求和</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = [</span><br><span class="line">    &#123;</span><br><span class="line">        name: <span class="string">'xiaoming'</span>,</span><br><span class="line">        age: <span class="number">18</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        name: <span class="string">'xiaohong'</span>,</span><br><span class="line">        age: <span class="number">17</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        name: <span class="string">'xiaogang'</span>,</span><br><span class="line">        age: <span class="number">19</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">person.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    a = a + b.age;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 54</span></span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>reduce() 方法还有很多其他用途，这里只是列出了最常见的几种，剩下的还需要大家多多探索哦！</p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210612%20/22-02-28-U5XAlt.jpg" alt="reduce_it_colour_0"></p>
<p>~</p>
<p>~</p>
<p>~</p>
<p>~本文完！</p>
<blockquote>
<p>学习有趣的知识，结识有趣的朋友，塑造有趣的灵魂！</p>
<p>大家好！我是〖编程三昧〗的作者 <strong>隐逸王</strong>，我的公众号是『编程三昧』，欢迎关注，希望大家多多指教！</p>
<p>知识与技能并重，内力和外功兼修，理论和实践两手都要抓、两手都要硬！</p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>数组 reduce</tag>
      </tags>
  </entry>
  <entry>
    <title>前端 JS 之 AJAX 简介及使用 </title>
    <url>/yinyiwang/2021/07/05/%E5%89%8D%E7%AB%AF-JS-%E4%B9%8B-AJAX-%E7%AE%80%E4%BB%8B%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>AJAX 是一个缩写，它的全名是 <strong>Asynchronous JavaScript and XML</strong>，意思就是异步 JavaScript 和 XML，即<strong>用JavaScript执行异步网络请求</strong>。</p>
<a id="more"></a>

<p>AJAX 不是一种新技术，而是一个在 2005 年被 Jesse James Garrett 提出的新术语，用来描述一种使用现有技术集合的‘新’方法，包括:</p>
<ul>
<li>HTML 或 XHTML</li>
<li>CSS</li>
<li>JavaScript</li>
<li>DOM</li>
<li>XML</li>
<li>XSLT</li>
<li>XMLHttpRequest</li>
</ul>
<p>尽管 X 在 AJAX 中代表 XML, 但由于 JSON 的许多优势，比如更加轻量以及作为 Javascript 的一部分，目前 JSON 的使用比 XML 更加普遍。JSON 和 XML 都被用于在 AJAX 模型中打包信息。</p>
<h2 id="AJAX-的优势"><a href="#AJAX-的优势" class="headerlink" title="AJAX 的优势"></a>AJAX 的优势</h2><p>传统的网页（不使用 AJAX）如果需要更新内容，必需重载整个网页面。</p>
<p>AJAX 通过在后台与服务器进行少量数据交换，可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</p>
<h2 id="XMLHttpRequest-对象"><a href="#XMLHttpRequest-对象" class="headerlink" title="XMLHttpRequest 对象"></a>XMLHttpRequest 对象</h2><p>XMLHttpRequest（XHR）对象用于与服务器交互。通过 XMLHttpRequest 可以在不刷新页面的情况下请求特定 URL，获取数据。这允许网页在不影响用户操作的情况下，更新页面的局部内容。XMLHttpRequest 在 AJAX 编程中被大量使用。</p>
<h2 id="AJAX-的工作原理"><a href="#AJAX-的工作原理" class="headerlink" title="AJAX 的工作原理"></a>AJAX 的工作原理</h2><p>其工作原理基本经过以下几个步骤：</p>
<ol>
<li>客户端发送请求，请求交给 xhr。</li>
<li>xhr 把请求提交给服务。</li>
<li>服务器进行业务处理。</li>
<li>服务器响应数据交给 xhr 对象。</li>
<li>xhr 对象接收数据，由 JavaScript 把数据写到页面上。</li>
</ol>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210615%20/19-01-42-ru9pUv.png" alt="AJAX 工作原理"></p>
<h2 id="AJAX-的创建步骤"><a href="#AJAX-的创建步骤" class="headerlink" title="AJAX 的创建步骤"></a>AJAX 的创建步骤</h2><p>根据 AJAX 的工作原理，它的创建步骤主要包括：</p>
<ol>
<li>创建 XMLHttpRequest 对象，即创建一个异步调用对象。</li>
<li>创建一个新的 HTTP 请求，并指定该 HTTP 请求的方法、URL 及验证信息。</li>
<li>设置响应 HTTP 请求状态变化的函数。</li>
<li>发送 HTTP 请求。</li>
<li>获取异步调用返回的数据。</li>
<li>使用 JavaScript 和 DOM 实现局部刷新。</li>
</ol>
<h2 id="AJAX-的具体使用"><a href="#AJAX-的具体使用" class="headerlink" title="AJAX 的具体使用"></a>AJAX 的具体使用</h2><p>以下是 使用 AJAX 的完整流程。</p>
<h3 id="1-创建-XMLHttpRequest-对象"><a href="#1-创建-XMLHttpRequest-对象" class="headerlink" title="1. 创建 XMLHttpRequest 对象"></a>1. 创建 XMLHttpRequest 对象</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> request = <span class="keyword">new</span> XMLHttpRequest();</span><br></pre></td></tr></table></figure>

<h3 id="2-创建一个新的-HTTP-请求，并指定该-HTTP-请求的方法、URL-及验证信息"><a href="#2-创建一个新的-HTTP-请求，并指定该-HTTP-请求的方法、URL-及验证信息" class="headerlink" title="2. 创建一个新的 HTTP 请求，并指定该 HTTP 请求的方法、URL 及验证信息"></a>2. 创建一个新的 HTTP 请求，并指定该 HTTP 请求的方法、URL 及验证信息</h3><p>创建 HTTP 请求可以使用 XMLHttpReques t对象的 open() 方法,其语法代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">request.open(method, url, <span class="keyword">async</span>, user, password);</span><br></pre></td></tr></table></figure>

<p>参数解析：</p>
<ul>
<li><em>method</em>    要使用的HTTP方法，比如 “GET”、”POST”、”PUT”、”DELETE” 等。</li>
<li><em>url</em>    表示要向其发送请求的 URL 地址。</li>
<li><em>async (可选)</em>    一个可选的布尔参数，表示是否异步执行操作，默认为 true。如果值为 false，send() 方法直到收到答复前不会返回。如果 true，已完成事务的通知可供事件监听器使用。如果 multipart 属性为 true 则这个必须为 true，否则将引发异常。</li>
<li><em>user (可选</em>    用于认证用途的用户名，默认值为 null。</li>
<li><em>password (可选)</em>    用于认证用途的密码，默认值为 null。</li>
</ul>
<h3 id="3-设置响应-HTTP-请求状态变化的函数和服务端返回信息函数"><a href="#3-设置响应-HTTP-请求状态变化的函数和服务端返回信息函数" class="headerlink" title="3. 设置响应 HTTP 请求状态变化的函数和服务端返回信息函数"></a>3. 设置响应 HTTP 请求状态变化的函数和服务端返回信息函数</h3><p>创建完 HTTP 请求之后，应该就可以将 HTTP 请求发送给 Web 服务器了。然而，发送 HTTP 请求的目的是为了接收从服务器中返回的数据。从创建 XMLHttpRequest 对象开始，到发送数据、接收数据、XMLHttpRequest 对象一共会经历以下 5 种状态：</p>
<ul>
<li>未初始化状态。在创建完 XMLHttpRequest 对象时，该对象处于未初始化状态，此时 XMLHttpRequest 对象的 readyState 属性值为    0。</li>
<li>初始化状态。在创建完 XMLHttpRequest 对象后使用 open() 方法创建了 HTTP 请求时，该对象处于初始化状态。此时 XMLHttpRequest 对象的readyState属性值为 1。</li>
<li>发送数据状态。在初始化 XMLHttpRequest 对象后，使用 send() 方法发送数据时，该对象处于发送数据状态，此时XMLHttpRequest 对象的 readyState 属性值为 2。</li>
<li>接收数据状态。Web 服务器接收完数据并进行处理完毕之后，向客户端传送返回的结果。此时，XMLHttpRequest 对象处于接收数据状态，XMLHttpRequest 对象的 readyState 属性值为 3。</li>
<li>完成状态。XMLHttpRequest 对象接收数据完毕后，进入完成状态，此时 XMLHttpRequest 对象的 readyState 属性值为 4。此时接收完毕后的数据存入在客户端计算机的内存中，可以使用 responseText 属性或 responseXml 属性来获取数据。</li>
</ul>
<p>总的来说，readyState 属性的值有以下几种：</p>
<ul>
<li>0 (未初始化) or (<strong>请求还未初始化</strong>)</li>
<li>1 (正在加载) or (<strong>已建立</strong>服务器链接)</li>
<li>2 (加载成功) or (<strong>请求已接受</strong>)</li>
<li>3 (交互) or (<strong>正在处理请求</strong>)</li>
<li>4 (完成) or (<strong>请求已完成并且响应已准备好</strong>)</li>
</ul>
<p>只读属性 XMLHttpRequest.status 返回了 XMLHttpRequest 响应中的数字状态码。status 的值是一个<code>无符号短整型</code>。在请求完成前，status 的值为 0。值得注意的是，如果 XMLHttpRequest 出错，浏览器返回的 status 也为0：</p>
<ul>
<li>UNSENT（未发送） 0</li>
<li>OPENED（已打开） 0</li>
<li>LOADING（载入中） 200</li>
<li>DONE（完成） 200</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'UNSENT'</span>, xhr.readyState); <span class="comment">// readyState 为 0</span></span><br><span class="line"></span><br><span class="line">xhr.open(<span class="string">'GET'</span>, <span class="string">'/api'</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'OPENED'</span>, xhr.readyState); <span class="comment">// readyState 为 1</span></span><br><span class="line"></span><br><span class="line">xhr.onprogress = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'LOADING'</span>, xhr.readyState); <span class="comment">// readyState 为 3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'DONE'</span>, xhr.readyState); <span class="comment">// readyState 为 4</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>只有在XMLHttpRequest对象完成了以上5个步骤之后，才可以获取从服务器端返回的数据。因此，如果要获得从服务器端返回的数据，就必须要先判断XMLHttpRequest对象的状态：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xmlHttpRequest.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span> &amp;&amp; xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="comment">// do something here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-发送HTTP请求"><a href="#4-发送HTTP请求" class="headerlink" title="4. 发送HTTP请求"></a>4. 发送HTTP请求</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">XMLHttpRequest.send(data);</span><br></pre></td></tr></table></figure>

<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>最后，附上一个简单的完整 AJAX 实例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"ajaxButton"</span> <span class="attr">type</span>=<span class="string">"button"</span>&gt;</span>Make a request<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> httpRequest;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">"ajaxButton"</span>).addEventListener(<span class="string">'click'</span>, makeRequest);</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">makeRequest</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        httpRequest = <span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"></span><br><span class="line">        httpRequest.onreadystatechange = alertContents;</span><br><span class="line"><span class="actionscript">        httpRequest.open(<span class="string">'GET'</span>, <span class="string">'test.html'</span>);</span></span><br><span class="line">        httpRequest.send();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">alertContents</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line">        if (httpRequest.readyState === XMLHttpRequest.DONE) &#123;</span><br><span class="line">            if (httpRequest.status === 200) &#123;</span><br><span class="line">                alert(httpRequest.responseText);</span><br><span class="line"><span class="actionscript">            &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="actionscript">                alert(<span class="string">'There was a problem with the request.'</span>);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210615%20/20-05-51-s68Qg7.png" alt="AJAX-Logo"></p>
<p>~</p>
<p>~</p>
<p>~ 本文完</p>
<p>~</p>
<blockquote>
<p>学习有趣的知识，结识有趣的朋友，塑造有趣的灵魂！</p>
<p>大家好！我是〖编程三昧〗的作者 <strong>隐逸王</strong>，我的公众号是『编程三昧』，欢迎关注，希望大家多多指教！</p>
<p>知识与技能并重，内力和外功兼修，理论和实践两手都要抓、两手都要硬！</p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript - Ajax</category>
      </categories>
      <tags>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title>前端 JavaScript 中 JSON.stringify() 的基本用法</title>
    <url>/yinyiwang/2021/07/05/%E5%89%8D%E7%AB%AF-JavaScript-%E4%B8%AD-JSON-stringify-%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在开发工作中，我们可能会碰到这样的需求：需要将某个对象内容弹窗显示或者保存在文件中，这时候如果你直接弹窗的话，很可能就是下面这样的：<img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210629%20/18-47-30-U0ttLq.png" alt="image-20210629184729132"></p>
<p>因为很多接口它对参数有要求，比如只能是字符串之类的。</p>
<p>这时候，就需要我们将对象转换为字符串进行输出，<code>JSON.stringify()</code> 方法就可以帮我们实现将对象转为字符串的过程。</p>
<a id="more"></a>

<h2 id="方法描述"><a href="#方法描述" class="headerlink" title="方法描述"></a>方法描述</h2><p><code>JSON.stringify()</code> 方法将一个 JavaScript 对象或值转换为 JSON 字符串，如果指定了一个 replacer 函数，则可以选择性地替换值，或者指定的 replacer 是数组，则可选择性地仅包含数组指定的属性。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(value[, replacer [, space]])</span><br></pre></td></tr></table></figure>

<h3 id="参数说明："><a href="#参数说明：" class="headerlink" title="参数说明："></a><strong>参数说明</strong>：</h3><ul>
<li><em>value</em>   将要序列化成 一个 JSON 字符串的值。</li>
<li><em>replacer</em>(可选)    <ul>
<li>如果该参数是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理；</li>
<li>如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中；</li>
<li>如果该参数为 null 或者未提供，则对象所有的属性都会被序列化。</li>
</ul>
</li>
<li><em>space(可选)</em>    指定缩进用的空白字符串，用于美化输出（pretty-print）；如果参数是个数字，它代表有多少的空格；上限为10。<ul>
<li>如果省略space，则将生成返回值文本，而没有任何额外空格。</li>
<li>如果 space是一个数字，则返回值文本在每个级别缩进指定数目的空格。 如果 space 大于 10，则文本缩进 10 个空格。</li>
<li>如果 space是一个非空字符串（例如“\t”），则返回值文本在每个级别中缩进字符串中的字符。</li>
<li>如果 space 是长度大于 10个字符的字符串，则使用前 10 个字符。</li>
</ul>
</li>
</ul>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>一个表示给定值的JSON字符串。</p>
<h3 id="常规用法"><a href="#常规用法" class="headerlink" title="常规用法"></a>常规用法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(&#123;<span class="attr">name</span>: <span class="string">"obj"</span>&#125;))</span><br><span class="line"><span class="comment">// '&#123;"name": "obj"&#125;'</span></span><br></pre></td></tr></table></figure>

<h2 id="repalacer-参数"><a href="#repalacer-参数" class="headerlink" title="repalacer 参数"></a>repalacer 参数</h2><p>replacer 参数可以是一个函数或者一个数组。作为函数，它有两个参数，键（key）和值（value），它们都会被序列化。</p>
<p>在开始时, <code>replacer</code> 函数会被传入一个空字符串作为 <code>key</code> 值，代表着要被 <code>stringify</code> 的这个对象。随后每个对象或数组上的属性会被依次传入。 </p>
<p>函数应当返回JSON字符串中的value, 如下所示:</p>
<ul>
<li>如果返回一个 Number，转换成相应的字符串作为属性值被添加入 JSON 字符串。</li>
<li>如果返回一个 String，该字符串作为属性值被添加入 JSON 字符串。</li>
<li>如果返回一个 Boolean， “true” 或者 “false” 作为属性值被添加入 JSON 字符串。</li>
<li>如果返回任何其他对象，该对象递归地序列化成 JSON 字符串，对每个属性调用 replacer 方法。除非该对象是一个函数，这种情况将不会被序列化成 JSON 字符串。</li>
<li>如果返回 undefined，该属性值不会在 JSON 字符串中输出。</li>
</ul>
<p>有以下对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> data = [</span><br><span class="line">    &#123;</span><br><span class="line">        name: <span class="string">"person1"</span>,</span><br><span class="line">        sex: <span class="number">0</span>,</span><br><span class="line">        age: <span class="number">18</span>,</span><br><span class="line">        isStudent: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        name: <span class="string">"person2"</span>,</span><br><span class="line">        sex: <span class="number">1</span>,</span><br><span class="line">        age: <span class="number">25</span>,</span><br><span class="line">        isStudent: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        name: <span class="string">"person3"</span>,</span><br><span class="line">        sex: <span class="number">0</span>,</span><br><span class="line">        age: <span class="number">15</span>,</span><br><span class="line">        isStudent: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>接下来我们针对这个对象做各种需求实现。</p>
<h3 id="只输出姓名和性别"><a href="#只输出姓名和性别" class="headerlink" title="只输出姓名和性别"></a>只输出姓名和性别</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> res = <span class="built_in">JSON</span>.stringify(data, [<span class="string">"name"</span>, <span class="string">"sex"</span>])</span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br><span class="line"><span class="comment">// `[&#123;"name":"person1","sex":0&#125;,&#123;"name":"person2","sex":1&#125;,&#123;"name":"person3","sex":0&#125;]`</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>JSON.stringify()</code> 提供了分离出自己需要的那部分数据。</p>
</blockquote>
<h3 id="将性别转为中文字符"><a href="#将性别转为中文字符" class="headerlink" title="将性别转为中文字符"></a>将性别转为中文字符</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> res = <span class="built_in">JSON</span>.stringify(data, (key, value) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="string">'sex'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">"女"</span>, <span class="string">'男'</span>][value];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br><span class="line"><span class="comment">// `[&#123;"name":"person1","sex":"女","age":18,"isStudent":true&#125;,&#123;"name":"person2","sex":"男","age":25,"isStudent":false&#125;,&#123;"name":"person3","sex":"女","age":15,"isStudent":true&#125;]`</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>JSON.stringify()</code> 提供了回调函数做一个映射关系。</p>
</blockquote>
<h2 id="space-参数"><a href="#space-参数" class="headerlink" title="space 参数"></a>space 参数</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> res = <span class="built_in">JSON</span>.stringify(data, [<span class="string">"name"</span>, <span class="string">"sex"</span>],<span class="number">4</span>)</span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210629%20/19-40-01-ESzv6Z.png" alt="image-20210629193959927"></p>
<p>这里使用了 4 个空格作为层级缩进。</p>
<blockquote>
<p>注意：使用 “\t” 得到的结果和使用 4 个空格得到的结果看起来很像，但实际不是一回事。</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>JSON.stringify()</code> 方法可以通过参数控制输出的数据和格式，灵活应用它会大大提高我们的工作效率。</p>
<blockquote>
<p>学习有趣的知识，结识有趣的朋友，塑造有趣的灵魂！</p>
<p>我是〖编程三昧〗的作者 <strong>隐逸王</strong>，我的公众号是『编程三昧』，欢迎关注，希望大家多多指教！</p>
<p>你来，怀揣期望，我有墨香相迎！ 你归，无论得失，唯以余韵相赠！</p>
<p>知识与技能并重，内力和外功兼修，理论和实践两手都要抓、两手都要硬！</p>
</blockquote>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210629%20/19-56-35-0TinZ8.png" alt=""></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JSON.stirngify</tag>
      </tags>
  </entry>
  <entry>
    <title>前端 JavaScript 中的三种 for 循环语句总结</title>
    <url>/yinyiwang/2021/07/05/%E5%89%8D%E7%AB%AF-JavaScript-%E4%B8%AD%E7%9A%84%E4%B8%89%E7%A7%8D-for-%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210627%20/19-10-04-qiJP6d.png" alt="循环"></p>
<p>JavaScript 中的 for 循环语句相信大家都已经快用厌了，现在有好多文章都在讲怎么减少代码中的 for 循环语句，但是，你又不得不承认它们真的很有用。今天，我来总结一下前端 JavaScript 中三种 for 循环语句。</p>
<a id="more"></a>

<h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><p>这大概是应用最广的循环语句了吧，简单实用，且大多数时候性能还是在线的，唯一的缺点大概就是<strong>太普通</strong>，没有特色，导致很多人现在不愿用它。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">4</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> index = <span class="number">0</span>; index &lt; array.length; index++) &#123;</span><br><span class="line">    <span class="keyword">const</span> element = array[index];</span><br><span class="line">    <span class="built_in">console</span>.log(element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4, 7, 9, 2, 6</span></span><br></pre></td></tr></table></figure>

<h2 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h2><p><code>for...in</code> 语句可以以任意顺序遍历一个对象的除 Symbol 以外的<strong>可枚举</strong>属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> temp = &#123;<span class="attr">name</span>: <span class="string">"temp"</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Apple</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.color = <span class="string">'red'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Apple.prototype = temp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> Apple();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> prop <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`obj.<span class="subst">$&#123; prop &#125;</span> = <span class="subst">$&#123; obj[prop] &#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// obj.color = red</span></span><br><span class="line"><span class="comment">// obj.name = temp</span></span><br></pre></td></tr></table></figure>

<p>如果你只要考虑对象本身的属性，而不是它的原型，那么使用  <code>getOwnPropertyNames()</code> 或执行 <code>hasOwnProperty()</code> 来确定某属性是否是对象本身的属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> temp = &#123;<span class="attr">name</span>: <span class="string">"temp"</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Apple</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.color = <span class="string">'red'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Apple.prototype = temp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> Apple();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> prop <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(prop)) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`obj.<span class="subst">$&#123; prop &#125;</span> = <span class="subst">$&#123; obj[prop] &#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// obj.color = red</span></span><br></pre></td></tr></table></figure>

<p>当然，也可以用来遍历数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0,1,2,3,4</span></span><br></pre></td></tr></table></figure>

<p>使用 <code>for...in</code> 可以遍历数组，但是会存在以下问题：</p>
<ol>
<li><p>index 索引为字符串型数字（注意，非数字），不能直接进行几何运算。</p>
</li>
<li><p>遍历顺序有可能不是按照实际数组的内部顺序（可能按照随机顺序）。</p>
</li>
</ol>
<p>所以一般不建议使用 <code>for...in</code> 来遍历数组。</p>
<h2 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h2><p><code>for...of</code> 语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> element <span class="keyword">of</span> array) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="comment">// c</span></span><br></pre></td></tr></table></figure>

<p><code>for...of</code> 和 <code>for...in</code> 的区别：</p>
<ul>
<li><p><code>for...in</code> 语句以任意顺序迭代对象的<strong>可枚举属性</strong>。</p>
</li>
<li><p><code>for...of</code> 语句遍历可迭代对象定义<strong>要迭代的数据</strong>。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.objCustom = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;;</span><br><span class="line"><span class="built_in">Array</span>.prototype.arrCustom = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterable = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line">iterable.foo = <span class="string">'hello'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> iterable) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key); <span class="comment">// logs 0, 1, 2, "foo", "arrCustom", "objCustom"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0, 1, 2, "foo", "arrCustom", "objCustom"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3, 5, 7</span></span><br></pre></td></tr></table></figure>

<p>使用 <code>for...of</code> 遍历 Map 结构：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nodes = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">nodes.set(<span class="string">"node1"</span>, <span class="string">"t1"</span>)</span><br><span class="line">    .set(<span class="string">"node2"</span>, <span class="string">"t2"</span>)</span><br><span class="line">    .set(<span class="string">"node3"</span>, <span class="string">"t3"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [node, content] <span class="keyword">of</span> nodes) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(node, content);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// node1 t1</span></span><br><span class="line"><span class="comment">// node2 t2</span></span><br><span class="line"><span class="comment">// node3 t3</span></span><br></pre></td></tr></table></figure>

<p>可以看出，使用 <code>for...of</code> 遍历 Map 结构还是挺方便的，推荐使用！</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>如果普通 for 循环用腻了，推荐使用 <code>for...of</code> 来替代。</li>
<li>这三种循环都可以使用 break 关键字来终止循环，也可以使用 continue 关键字来跳过本次循环。</li>
<li><code>for...of</code> 循环的适用范围最大。</li>
</ol>
<p>~</p>
<p>~ 本文完，感谢阅读！</p>
<p>~</p>
<blockquote>
<p>学习有趣的知识，结识有趣的朋友，塑造有趣的灵魂！</p>
<p>我是〖编程三昧〗的作者 <strong>隐逸王</strong>，我的公众号是『编程三昧』，欢迎关注，希望大家多多指教！</p>
<p>你来，怀揣期望，我有墨香相迎！ 你归，无论得失，唯以余韵相赠！</p>
<p>知识与技能并重，内力和外功兼修，理论和实践两手都要抓、两手都要硬！</p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript - 循环语句</category>
      </categories>
      <tags>
        <tag>for 循环</tag>
      </tags>
  </entry>
  <entry>
    <title>前端 JavaScript 之『防抖节流』</title>
    <url>/yinyiwang/2021/07/05/%E5%89%8D%E7%AB%AF-JavaScript-%E4%B9%8B%E3%80%8E%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81%E3%80%8F/</url>
    <content><![CDATA[<h2 id="往事不堪回首"><a href="#往事不堪回首" class="headerlink" title="往事不堪回首"></a>往事不堪回首</h2><p>犹记在很久之前的某次面试中，和那技术大哥谈的正欢呢，冷不防他来了句：谈一谈防抖和节流吧。</p>
<p>抹了把凉汗，我用颤抖的、不自信的语气回答道：呃，防抖就是应该是防止抖动的意思，节流大概是节省流量吧……</p>
<a id="more"></a>

<p>当时，我的心理活动是这样的：</p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210616%20/18-22-35-n0Sa2Y.jpeg" alt="坏滴很"></p>
<p>当年心理素质是真的差，这个坎没翻过去，最后的结果就是：</p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210616%20/18-30-07-okw6cp.gif" alt="悲伤"></p>
<h2 id="知耻而后勇"><a href="#知耻而后勇" class="headerlink" title="知耻而后勇"></a>知耻而后勇</h2><p>以我不服输的性格，这场子必须找回来！</p>
<p>经过这几年的勤学苦练，我现在自信简直爆棚，如果，时光能够倒流，我相信我可以做到这样：</p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210616%20/18-24-17-HPo4hO.gif" alt="面对疾风"></p>
<p>今天，我要跟「防抖节流」来做个了断，以证明现在的我已不是过去的我，用一个成语来形容，那就是——今非昔比！</p>
<h2 id="知己知彼，方能百战百胜"><a href="#知己知彼，方能百战百胜" class="headerlink" title="知己知彼，方能百战百胜"></a>知己知彼，方能百战百胜</h2><p>古老的法则告诉我们：欲要消灭敌人，必须先要了解敌人。</p>
<h3 id="防抖（debounce）"><a href="#防抖（debounce）" class="headerlink" title="防抖（debounce）"></a>防抖（debounce）</h3><p>从字面意思来看，防抖就是防止抖动的意思。</p>
<p>举个例子：比如说你对象要你帮她拍美照， 结果因为你加班太多身体虚，手抖的厉害，拍出来的照片模糊不清，为免受雷霆之怒，你就需要想想办法。首先，分析一下照片模糊的原因：</p>
<ul>
<li>手抖的厉害（1s 十几次！！？？）</li>
<li>导致相机不能完美的捕捉画面</li>
<li>所以照片模糊。</li>
</ul>
<p>看来，「手抖」才是罪魁祸首啊，那想个办法解决手抖的问题就好了：找一个支架，让它代替手来支撑相机，这样就不「抖」了！</p>
<p>这操作，让我不得不对你竖起大拇指：</p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210616%20/19-54-08-iBFW9Q.jpeg" alt=""></p>
<p>想想看上面这个例子本质上是解决了什么问题？</p>
<p>我觉得应该是解决了<strong>「抖动频率」</strong>的问题——手拿着，一秒会抖好多次；可支架撑着，好长时间都未必会抖一次。可谓是「人不如架」啊！</p>
<p>支架起的就是<strong>防抖</strong>的作用。</p>
<p>回到我们今天的正题上，来看一下防抖的常规解释：<strong>当函数被连续调用时，该函数并不执行，只有当其全部停止调用超过一定时间后才执行1次。</strong></p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210616%20/20-33-06-KelxxH.jpeg" alt="防抖"></p>
<h3 id="节流（throttle）"><a href="#节流（throttle）" class="headerlink" title="节流（throttle）"></a>节流（throttle）</h3><p>现在回头看看我当年的回答，还是摸到了一点门槛（手动缓解尴尬，嘿嘿）。</p>
<p>再来个例子：家里的水龙头，即使你开的再大，它在单位时间里能流出的水就那么多，因为水龙头的规格限制了它单位时间里的流量。</p>
<p>水龙头起到的就是<strong>节流</strong>的作用。</p>
<p>节流的常规解释：<strong>规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效</strong>。</p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210616%20/20-33-33-dPf3r9.png" alt="节流"></p>
<h3 id="常用场景"><a href="#常用场景" class="headerlink" title="常用场景"></a>常用场景</h3><p>防抖节流一般用于以下场景：</p>
<ul>
<li>浏览器窗口的缩放，页面的滑动触发的 <code>resize</code> ，<code>scroll</code></li>
<li>鼠标事件 <code>onmousemove</code> ，<code>onmousedown</code>， <code>onmouseup</code></li>
<li>输入框录入触发的 <code>keyup</code> ，<code>keydown</code>……</li>
</ul>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>防抖是维护一个计时器，规定在 delay 时间后触发函数，但是在 delay 时间内再次触发的话，都会清除当前的 timer 然后重新设置超时调用，即重新计时。这样一来，只有最后一次操作能被触发。</p>
<p>节流是通过判断是否到达一定时间来触发函数，若没到规定时间则使用计时器延后，而下一次事件则会重新设定计时器。</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>函数防抖是某一段时间内只执行一次，而函数节流是间隔时间执行，不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天就先来了解一下「防抖」和「节流」的基础知识，详细代码实现待后续。</p>
<p>~</p>
<p>~</p>
<p>~ 未完待续</p>
<blockquote>
<p>学习有趣的知识，结识有趣的朋友，塑造有趣的灵魂！</p>
<p>大家好！我是〖编程三昧〗的作者 <strong>隐逸王</strong>，我的公众号是『编程三昧』，欢迎关注，希望大家多多指教！</p>
<p>知识与技能并重，内力和外功兼修，理论和实践两手都要抓、两手都要硬！</p>
</blockquote>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210616%20/20-45-17-6ya6Kf.jpg" alt="mianshi"></p>
]]></content>
      <categories>
        <category>JavaScript - throttle - debounce</category>
      </categories>
      <tags>
        <tag>防抖节流</tag>
      </tags>
  </entry>
  <entry>
    <title>前端 JavaScript 之『防抖』的简单代码实现</title>
    <url>/yinyiwang/2021/07/05/%E5%89%8D%E7%AB%AF-JavaScript-%E4%B9%8B%E3%80%8E%E9%98%B2%E6%8A%96%E3%80%8F%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="前戏"><a href="#前戏" class="headerlink" title="前戏"></a>前戏</h2><p>经过上一篇文章的总结，我们知道：短时间内高频率地触发事件，可能会导致不良后果。</p>
<p>具体到我们开发界来说，如果数据一致处于一种高频率更新的状态，那么可能会引发的问题如下：</p>
<ul>
<li>前后端数据交互频率过高，导致流量浪费。</li>
<li>界面高频率渲染更新，引发页面延迟、卡顿或假死等状况，影响体验。</li>
</ul>
<a id="more"></a>

<p>在进入正题之前，我们先来看下面这个例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">""</span> <span class="attr">class</span>=<span class="string">"example-form"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"name"</span>&gt;</span>名称<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> </span></span><br><span class="line"><span class="tag">               <span class="attr">name</span>=<span class="string">"name"</span> </span></span><br><span class="line"><span class="tag">               <span class="attr">id</span>=<span class="string">"name"</span> </span></span><br><span class="line"><span class="tag">               <span class="attr">placeholder</span>=<span class="string">"please input your name"</span></span></span><br><span class="line"><span class="tag">         &gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"res"</span>&gt;</span>输入<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">type</span>=<span class="string">"multipart"</span> </span></span><br><span class="line"><span class="tag">                  <span class="attr">name</span>=<span class="string">"res"</span> </span></span><br><span class="line"><span class="tag">                  <span class="attr">id</span>=<span class="string">"res"</span> </span></span><br><span class="line"><span class="tag">                  <span class="attr">placeholder</span>=<span class="string">"这里是每一次输入的结果"</span></span></span><br><span class="line"><span class="tag">        &gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> inputEle = <span class="built_in">document</span>.querySelector(<span class="string">"#name"</span>);</span><br><span class="line">    <span class="keyword">const</span> resEle = <span class="built_in">document</span>.querySelector(<span class="string">"#res"</span>);</span><br><span class="line">    inputEle.addEventListener(<span class="string">"input"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.value);</span><br><span class="line">        resEle.value += <span class="string">`\n<span class="subst">$&#123; <span class="keyword">this</span>.value &#125;</span>`</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210617%20/18-04-32-ppAL3g.gif" alt="频繁触发"></p>
<p>在输入框的 input 事件中，将该输入框的当前值输出在多行文本框中。可以看到，每输入一个拼音字母，都会有一条输出记录，触发频率取决于人的打字速度。</p>
<h2 id="新需求"><a href="#新需求" class="headerlink" title="新需求"></a>新需求</h2><p>假如，现在有这么一个新需求，要我们在 input 事件中加入新的逻辑：将输入框的当前值发往后台进行存储。</p>
<p>可以想象，这种情况下的前后端交互频率该有多高，其中很多数据都是没有必要即刻发送保存的，纯属浪费流量。</p>
<p>我们可以考虑对这个需求进行一下优化，只要控制一下交互频率就好，主要有以下两个方向：</p>
<ul>
<li>每隔几秒发送一次数据 —— 节流</li>
<li>每当用户停止输入之后，开始计时，一定时间后发送一次数据 —— 防抖</li>
</ul>
<h2 id="实现防抖"><a href="#实现防抖" class="headerlink" title="实现防抖"></a>实现防抖</h2><p>首先，我们从防抖的方向进行实现：只有当用户停止输入一段时间后，才会将输入内容输出在多行文本框中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> resEle = <span class="built_in">document</span>.querySelector(<span class="string">"#res"</span>);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">changeOutputVal</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        resEle.value += <span class="string">`\n<span class="subst">$&#123; value &#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay = <span class="number">1000</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(args);</span><br><span class="line">            <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">                clearTimeout(timer);</span><br><span class="line">                timer = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                fn.apply(<span class="keyword">this</span>, args);</span><br><span class="line">            &#125;, delay);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> outputRes = debounce(changeOutputVal, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> inputEle = <span class="built_in">document</span>.querySelector(<span class="string">"#name"</span>);</span><br><span class="line"></span><br><span class="line">    inputEle.addEventListener(<span class="string">"input"</span>, (eve) =&gt; &#123;</span><br><span class="line">        outputRes(eve.target.value);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码说明：</p>
<ol>
<li>每一次事件被触发，都会清除当前的 timer 然后重新设置超时调用，即重新计时。 这就会导致每一次高频事件都会取消前一次的超时调用，导致事件处理程序不能被触发；</li>
<li>只有当高频事件停止，最后一次事件触发的超时调用才能在delay时间后执行。</li>
</ol>
<p>运行效果如下：</p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210617%20/20-29-25-R4l3jg.gif" alt=""></p>
<p>可以看到，在加入防抖代码之后，input 事件并不会每次输入都会输出在多行文本，而是会在用户停止输入 delay 时间之后触发输出，频率确实低了很多。从某种程度上来说，的确优化了页面显示效果，给人的视觉感受比较舒服。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>巧用防抖函数的，既可以优化性能，又能优化显示效果，一举两得。</p>
<p>~</p>
<p>~</p>
<p>代码比较粗糙，也比较基础，后面会逐步向着复杂的方向迭代，望各位看官海涵🙏</p>
<p>~</p>
<p>~</p>
<p>~ 本文完</p>
<blockquote>
<p>学习有趣的知识，结识有趣的朋友，塑造有趣的灵魂！</p>
<p>大家好！我是〖编程三昧〗的作者 <strong>隐逸王</strong>，我的公众号是『编程三昧』，欢迎关注，希望大家多多指教！</p>
<p>知识与技能并重，内力和外功兼修，理论和实践两手都要抓、两手都要硬！</p>
</blockquote>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210616%20/20-45-17-6ya6Kf.jpg" alt="mianshi"></p>
]]></content>
      <categories>
        <category>JavaScript - debounce</category>
      </categories>
      <tags>
        <tag>防抖函数</tag>
      </tags>
  </entry>
  <entry>
    <title>前端 JavaScript 复制粘贴的奥义——Clipboard 对象概述</title>
    <url>/yinyiwang/2021/07/05/%E5%89%8D%E7%AB%AF-JavaScript-%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4%E7%9A%84%E5%A5%A5%E4%B9%89%E2%80%94%E2%80%94Clipboard-%E5%AF%B9%E8%B1%A1%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作为一名资深搬砖工，你要问我用得最熟练的技能是什么，那我敢肯定且自豪的告诉你：是 <code>Ctrl+C</code> ！是 <code>Ctrl+V</code>！</p>
<p>不信？你来看看我键盘上的 Ctrl、C 和 V 键，那油光发亮的包浆程度，不盘个三五年是绝对达不到的！</p>
<a id="more"></a>

<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210622%20/14-18-10-tq9MQP.jpeg" alt="cv"></p>
<p>编程界的江湖上曾经流传着一句话：CV da fa 好，CV da fa 妙！主要看疗效，谁用谁知道！（为防河蟹，且用拼音凑合着）</p>
<p>从这句话就可以看出编程界的同仁们对 CV 的追捧和狂热，简直是席卷大街小巷、风靡大江南北！一时之间，不知让多少 IT 英雄们“竞折腰”，即使到了现在，它依然是编程入门的必修技能！</p>
<p>那么，CV 到底有什么魔力，能让人这么着迷，一代又一代的传承不息呢？</p>
<p>今天，让我们一起来揭开前端 JavaScript 开发界 CV 的面纱，一睹真容（套路）！</p>
<h2 id="旧法"><a href="#旧法" class="headerlink" title="旧法"></a>旧法</h2><p>世界上最好的语言—— JavaScript，必然是有着访问系统剪切板的功能的，主要依靠 <code>Document.execCommand()</code>  接口实现复制、粘贴、剪切等功能。</p>
<ul>
<li><code>document.execCommand(&#39;copy&#39;)</code></li>
<li><code>document.execCommand(&#39;cut&#39;)</code></li>
<li><code>document.execCommand(&#39;paste&#39;)</code></li>
</ul>
<h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> inputEle = <span class="built_in">document</span>.querySelector(<span class="string">'#input'</span>);</span><br><span class="line">inputEle.select();</span><br><span class="line"><span class="built_in">document</span>.execCommand(<span class="string">'copy'</span>);</span><br></pre></td></tr></table></figure>

<p>首先获取到这个 input 元素，然后选中 input 中的内容，再调用复制接口，将 input 内容复制到剪切板。</p>
<blockquote>
<p>注意，复制操作最好放在事件监听函数里面，由用户触发（比如用户点击按钮）。</p>
</blockquote>
<h3 id="粘贴"><a href="#粘贴" class="headerlink" title="粘贴"></a>粘贴</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pasteText = <span class="built_in">document</span>.querySelector(<span class="string">'#output'</span>);</span><br><span class="line">pasteText.focus();</span><br><span class="line"><span class="built_in">document</span>.execCommand(<span class="string">'paste'</span>);</span><br></pre></td></tr></table></figure>

<p>首先让 input 元素获得焦点，然后调用粘贴接口，将剪切板内容粘贴到 input。</p>
<h3 id="剪切"><a href="#剪切" class="headerlink" title="剪切"></a>剪切</h3><p>用法同<strong>复制</strong>。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>从上面的示例来看，剪切板 API 用着很简单，但它有以下不足：</p>
<ol>
<li>它不够灵活，只能将选中的内容复制到剪贴板，无法向剪贴板任意写入内容。</li>
<li>它是同步操作，如果复制/粘贴大量数据，页面会出现卡顿。</li>
<li>有些浏览器还会跳出提示框，要求用户许可，这时在用户做出选择前，页面会失去响应。</li>
</ol>
<h2 id="进化-——Clipboard"><a href="#进化-——Clipboard" class="headerlink" title="进化 ——Clipboard"></a>进化 ——Clipboard</h2><p>为了使 JavaScript 更加灵活的操作剪切板，也是为了顺应 JS 发展的历史潮流，Clipboard API 应运而生。它是下一代的剪贴板操作方法，比传统的<code>document.execCommand()</code>方法更强大、更合理。</p>
<p>Clipboard 接口实现了 Clipboard API，如果用户授予了相应的权限，就能提供系统剪贴板的读写访问。在 Web 应用程序中，Clipboard API 可用于实现剪切、复制和粘贴功能。</p>
<p>它的所有操作都是异步的，返回 Promise 对象，不会造成页面卡顿。而且，它可以将任意内容（比如图片）放入剪贴板。</p>
<p>该 API 被设计用来取代使用 <code>document.execCommand()</code> 的剪贴板访问方式。</p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p><code>navigator.clipboard</code> 属性返回 Clipboard 对象，所有操作都通过这个对象进行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  	<span class="keyword">const</span> text = <span class="keyword">await</span> navigator.clipboard.readText();</span><br><span class="line">  	<span class="built_in">console</span>.log(text);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>如果<code>navigator.clipboard</code>属性返回<code>undefined</code>，就说明当前浏览器不支持这个 API。</p>
<h3 id="安全限制"><a href="#安全限制" class="headerlink" title="安全限制"></a>安全限制</h3><ol>
<li>Chrome 浏览器规定，只有 HTTPS 协议的页面才能使用这个 API。不过，开发环境（<code>localhost</code>）允许使用非加密协议。</li>
<li>调用时需要明确获得用户的许可。权限的具体实现使用了 Permissions API，跟剪贴板相关的有两个权限：<code>clipboard-write</code>（写权限）和<code>clipboard-read</code>（读权限）。“写权限”自动授予脚本，而“读权限”必须用户明确同意给予。也就是说，写入剪贴板，脚本可以自动完成，但是读取剪贴板时，浏览器会弹出一个对话框，询问用户是否同意读取。</li>
</ol>
<blockquote>
<p>脚本读取的总是当前页面的剪贴板。这带来的一个问题是，如果把相关的代码粘贴到开发者工具中直接运行，可能会报错，因为这时的当前页面是开发者工具的窗口，而不是网页页面。</p>
</blockquote>
<blockquote>
<p>如果用户没有适时使用 Permissions API) 授予相应权限和<code>&quot;clipboard-read&quot;</code> 或 <code>&quot;clipboard-write&quot;</code> 权限，调用 <code>Clipboard</code> 对象的方法不会成功。</p>
</blockquote>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>Clipboard 对象提供了四个方法，用来读写剪贴板。它们都是异步方法，返回 Promise 对象。</p>
<ul>
<li><code>read()</code>    从剪贴板读取数据（比如图片），返回一个 Promise对象。</li>
<li><code>readText()</code>    从操作系统读取文本，返回一个 Promise对象。</li>
<li><code>write()</code>    写入任意数据至操作系统剪贴板。</li>
<li><code>writeText()</code>   写入文本至操作系统剪贴板。</li>
</ul>
<h3 id="浏览器兼容性"><a href="#浏览器兼容性" class="headerlink" title="浏览器兼容性"></a>浏览器兼容性</h3><p>目前，各个浏览器厂商正在逐步开始支持 Clipboard 对象及其方法，兼容性如下：</p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210622%20/16-27-15-oqrjIe.png" alt="iShot2021-06-22 16.24.50"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对上面所说的做一个总结：</p>
<ol>
<li>Clipboard 对象的方法，返回一个 Promise 对象</li>
<li>Clipboard 的使用存在一定的安全限制，需要注意。</li>
<li>在控制台运行 Clipboard 可能会报错。</li>
</ol>
<p>~</p>
<p>~</p>
<p>~ 本文完，感谢阅读！</p>
<p>~</p>
<blockquote>
<p>学习有趣的知识，结识有趣的朋友，塑造有趣的灵魂！</p>
<p>我是〖编程三昧〗的作者 <strong>隐逸王</strong>，我的公众号是『编程三昧』，欢迎关注，希望大家多多指教！</p>
<p>你来，怀揣期望，我有墨香相迎！ 你归，无论得失，唯以余韵相赠！</p>
<p>知识与技能并重，内力和外功兼修，理论和实践两手都要抓、两手都要硬！</p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript - Clipboard</category>
      </categories>
      <tags>
        <tag>剪切板</tag>
        <tag>Clipboard</tag>
      </tags>
  </entry>
  <entry>
    <title>戏说代理模式</title>
    <url>/yinyiwang/2021/07/05/%E6%88%8F%E8%AF%B4%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>你看到的是我想让你看到的，你听到的是我想让你听到的！   ——代理模式的自白</p>
</blockquote>
<h2 id="前戏不能少"><a href="#前戏不能少" class="headerlink" title="前戏不能少"></a>前戏不能少</h2><p>前戏一：在生活中，我们常常会见到这么一种现象：有些父母抱着”望子成龙，望女成凤“的心态，将孩子所有的事务（衣食住行，吃喝拉撒）全都包圆了，可以说事无巨细。</p>
<a id="more"></a>

<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210605%20/14-25-22-TJRZcB.jpeg" alt="包圆了"></p>
<p>前戏二：在古代，男女成婚之前是不能相互见面的，他们之间的很多信息都是通过媒人相互传递的，是丑是美，是高是矮还不是靠媒人的那张嘴。</p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210605%20/14-30-04-lNeXon.jpeg" alt="媒人"></p>
<p>通过上面这两个前戏，大家有没有一些感觉？</p>
<p>这孩子废了……</p>
<p>万恶的封建社会……</p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210605%20/14-40-20-kSD3M0.jpeg" alt="Ra8f56ee7705d048a657a579b995770da"></p>
<p>咳咳！！敲黑板了，请注意：我们今天讨论的是科学知识之<strong>代理模式</strong>，不是社会话题！</p>
<h2 id="言归正传"><a href="#言归正传" class="headerlink" title="言归正传"></a>言归正传</h2><p>我之所以来段前戏，绝不是为了哗众取宠，我是有<strong>深意</strong>的！</p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210605%20/15-21-43-gMkLUM.png" alt="image-20210605152141946"></p>
<p>我们先来看看 <strong>代理*模式</strong>的定义：</p>
<blockquote>
<p>由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。</p>
</blockquote>
<p>假如我们把文章开头两个例子看做代理模式，那么结合定义，我们可以将上图中的父母和媒人当做”代理对象“。</p>
<h2 id="关于代理模式"><a href="#关于代理模式" class="headerlink" title="关于代理模式"></a>关于代理模式</h2><p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210605%20/16-20-24-CtNI8U.png" alt="R7a1d854014980f2d649382e338fbf7aa"></p>
<p><strong>优点</strong></p>
<ul>
<li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用。</li>
<li>代理对象可以扩展目标对象的功能。</li>
<li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>代理模式会造成系统设计中类的数量增加。</li>
<li>在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢。</li>
<li>增加了系统的复杂度。</li>
</ul>
<p><strong>分类</strong></p>
<ul>
<li>静态代理  由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了。</li>
<li>动态代理  在程序运行时，运用反射机制动态创建而成</li>
</ul>
<p><strong>组成</strong></p>
<ul>
<li>抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。</li>
<li>真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。</li>
<li>代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。</li>
</ul>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>今天我们主要是对代理模式有个比较简单的认知，后续会展开来说，感谢阅读！</p>
<blockquote>
<p>学习有趣的知识，结识有趣的朋友，塑造有趣的灵魂！</p>
<p>大家好！我是〖编程三昧〗的作者 <strong>隐逸王</strong>，我的公众号是『编程三昧』，欢迎关注，希望大家多多指教！</p>
<p>知识与技能并重，内力和外功兼修！</p>
</blockquote>
]]></content>
      <categories>
        <category>编程 - 代理模式</category>
      </categories>
      <tags>
        <tag>代理模式</tag>
      </tags>
  </entry>
  <entry>
    <title>前端 JavaScript 之『节流』的简单代码实现</title>
    <url>/yinyiwang/2021/07/05/%E5%89%8D%E7%AB%AF-JavaScript-%E4%B9%8B%E3%80%8E%E8%8A%82%E6%B5%81%E3%80%8F%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="前戏"><a href="#前戏" class="headerlink" title="前戏"></a>前戏</h2><p>首先，总结一下上一篇文章——《前端 JavaScript 之『防抖』的简单代码实现》的内容：「防抖」就是在高频率触发事件停止触发后，延时执行某个处理逻辑。</p>
<p>防抖虽然在一定程度上对性能起到了优化效果，但是，我们也要看到它的局限性：如果高频率事件一直触发，那么回调函数中的逻辑就一直得不到执行。</p>
<a id="more"></a>

<p>大家都知道，掘金的编辑器带有草稿箱的效果，即你输入的内容会保存下来，即使我们退出编辑器页面了，再次进入还是可以找回前面输入的内容，这是因为编辑器的 input 事件中执行了发送内容的防抖函数。如下图所示：</p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210618%20/22-52-53-MSdbxm.gif" alt=""></p>
<p>现在假设：你的打字速度很快，基本上不带喘口气的，那么是否会导致很长时间都保存不了一次数据？如果这时候你再以迅雷不及掩耳之势关闭掉浏览器，是不是你所写的内容就保存不下来了？</p>
<p>那么我们是否可以想办法避免上面这种情况呢？</p>
<p>在这种需求背景下，我们今天的主人公——「节流」开始粉墨登场。</p>
<p>节流的含义大家应该都知道了：<strong>每隔固定的时间都会执行一次回函函数中的逻辑</strong>。</p>
<p>不使用节流函数，我们来看一下下面这个功能的执行效果：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">""</span> <span class="attr">class</span>=<span class="string">"example-form"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"name"</span>&gt;</span></span><br><span class="line">                名称</span><br><span class="line">            <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"input-ele"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">id</span>=<span class="string">"name"</span> <span class="attr">placeholder</span>=<span class="string">"please input your name"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">autocomplete</span>=<span class="string">"off"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"res"</span>&gt;</span></span><br><span class="line">                输入</span><br><span class="line">            <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">class</span>=<span class="string">"input-ele"</span> <span class="attr">type</span>=<span class="string">"multipart"</span> <span class="attr">name</span>=<span class="string">"res"</span> <span class="attr">id</span>=<span class="string">"res"</span> <span class="attr">readonly</span></span></span><br><span class="line"><span class="tag">                <span class="attr">placeholder</span>=<span class="string">"这里是每一次输入的结果"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> inputEle = <span class="built_in">document</span>.querySelector(<span class="string">"#name"</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> resEle = <span class="built_in">document</span>.querySelector(<span class="string">"#res"</span>);</span></span><br><span class="line"><span class="actionscript">        inputEle.addEventListener(<span class="string">"input"</span>, <span class="function"><span class="keyword">function</span> <span class="params">(event)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.value);</span></span><br><span class="line"><span class="javascript">            resEle.value += <span class="string">`\n<span class="subst">$&#123; <span class="keyword">this</span>.value &#125;</span>`</span></span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>实现的效果如下：</p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210619%20/11-38-15-hNJycp.gif" alt=""></p>
<p>即使我们想要执行输出逻辑，但是也不能接受这么高频率的输出，一个是造成了输出内容冗余，二是渲染强度高，不太划算。</p>
<h2 id="新需求"><a href="#新需求" class="headerlink" title="新需求"></a>新需求</h2><p>假如，现在有这么一个新需求，要我们在 input 事件中加入新的逻辑：每隔一段时间后，都会执行一次回调函数中的逻辑。</p>
<p>这个需求是不是挺符合节流函数的使用场景的，那我们赶紧来实现一个吧。</p>
<h2 id="实现节流"><a href="#实现节流" class="headerlink" title="实现节流"></a>实现节流</h2><p>根据节流函数的定义：以固定的低频率执行代码逻辑，具体到我们上面的额需求来说，只要打开页面，不管你有没有输入，都会每隔几秒就执行一次保存数据的逻辑。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> resEle = <span class="built_in">document</span>.querySelector(<span class="string">"#res"</span>);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">changeOutputVal</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        resEle.value += <span class="string">`\n<span class="subst">$&#123; value &#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fun, delay</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> last, deferTimer</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">args</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> that = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">let</span> _args = <span class="built_in">arguments</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">            <span class="keyword">if</span> (last &amp;&amp; now &lt; last + delay) &#123;</span><br><span class="line">                clearTimeout(deferTimer);</span><br><span class="line">                deferTimer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                    last = now;</span><br><span class="line">                    fun.apply(that, _args);</span><br><span class="line">                &#125;, delay)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                last = now;</span><br><span class="line">                fun.apply(that, _args);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> outputRes = throttle(changeOutputVal, <span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> inputEle = <span class="built_in">document</span>.querySelector(<span class="string">"#name"</span>);</span><br><span class="line"></span><br><span class="line">    inputEle.addEventListener(<span class="string">"input"</span>, (eve) =&gt; &#123;</span><br><span class="line">        outputRes(eve.target.value);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码说明：</p>
<ul>
<li>每一次事件被触发，都会判断间隔时间是否大于等于 delay，如果是，则执行输出逻辑；如果否，则清除原先的延时器，重新计算延时时间；</li>
</ul>
<p>运行效果如下：</p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210618%20/23-17-31-hXAvxU.gif" alt=""></p>
<p>可以看到，在加入节流代码之后，输出事件不会每次 input 事件都触发，而是每隔 delay 时间触发一次。</p>
<p>~</p>
<p>~</p>
<p>代码比较粗糙，也比较基础，后面会逐步向着复杂的方向迭代，望各位看官海涵🙏</p>
<p>~</p>
<p>~</p>
<p>~ 本文完</p>
<blockquote>
<p>学习有趣的知识，结识有趣的朋友，塑造有趣的灵魂！</p>
<p>大家好！我是〖编程三昧〗的作者 <strong>隐逸王</strong>，我的公众号是『编程三昧』，欢迎关注，希望大家多多指教！</p>
<p>知识与技能并重，内力和外功兼修，理论和实践两手都要抓、两手都要硬！</p>
</blockquote>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210616%20/20-45-17-6ya6Kf.jpg" alt="mianshi"></p>
]]></content>
      <categories>
        <category>JavaScript - throttle</category>
      </categories>
      <tags>
        <tag>节流函数</tag>
      </tags>
  </entry>
  <entry>
    <title>相信我，你一直没有理解 sort 方法！</title>
    <url>/yinyiwang/2021/07/05/%E7%9B%B8%E4%BF%A1%E6%88%91%EF%BC%8C%E4%BD%A0%E4%B8%80%E7%9B%B4%E6%B2%A1%E6%9C%89%E7%90%86%E8%A7%A3-sort-%E6%96%B9%E6%B3%95%EF%BC%81/</url>
    <content><![CDATA[<blockquote>
<p>纸上得来终觉浅，绝知此事要躬行！</p>
</blockquote>
<p>在上一篇文章中，我们简单介绍了 <code>arr.sort()</code> 方法的基本使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">49</span>, <span class="number">5</span>, <span class="number">14</span>, <span class="number">89</span>, <span class="number">71</span>, <span class="number">3</span>, <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般写法</span></span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;   <span class="comment">// 按照升序排列 </span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line">arr.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果  [3, 5, 10, 14, 49, 71, 89]</span></span><br></pre></td></tr></table></figure>

<p>用归用，照葫芦画瓢不难，大家日常也是这么写的，没毛病！但是如果对一个方法不进行深入研究，那么就很容易踩坑，并且常常会填不了坑！</p>
<p>今天，我们重点聊聊比较函数 <code>compareFunction</code> 相关的知识。</p>
<a id="more"></a>

<p>为了接下来的思路能够更顺畅，在学习比较函数之前，我们先来了解一下有关插入排序的原理。</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<p><strong>算法描述：</strong></p>
<p>一般来说，插入排序都采用 in-place 在数组上实现：</p>
<ul>
<li>从第一个元素开始，该元素可以认为已经被排序；</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li>
<li>将新元素插入到该位置后；</li>
<li>重复步骤2~5。 </li>
</ul>
<p><strong>动图演示</strong>：</p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210609%20/19-07-15-aAqozF.gif" alt="img"></p>
<p>其实可以用一句话总结：<strong>从数组中第二个元素起（第一个元素已默认排序），每个元素都充当一次游标值，依次和它前面的（已排序）的元素相比较，如果游标值小，则将拿来比较的元素向后移一位，继续向前比较；否则，将游标值插入比较值的后面，结束比较。</strong></p>
<h2 id="关于比较函数-compareFunction"><a href="#关于比较函数-compareFunction" class="headerlink" title="关于比较函数 compareFunction"></a>关于比较函数 <code>compareFunction</code></h2><p>如果想要 <code>sort()</code> 方法按照一定的规则进行排序（比如数字大小），那么就需要给它指定比较函数 <code>compareFunction</code>。</p>
<p>如果指明了 <code>compareFunction</code> ，那么数组会按照调用该函数的返回值排序，它有两个参数 <code>a</code> 和 <code>b</code>，返回值如下：</p>
<ul>
<li><p>如果 <code>compareFunction(a, b)</code> 小于 0 ，那么 a 会被排列到 b 之前。</p>
</li>
<li><p>如果 <code>compareFunction(a, b)</code> 等于 0 ， a 和 b 的相对位置不变。</p>
</li>
<li><p>如果 <code>compareFunction(a, b)</code> 大于 0 ， b 会被排列到 a 之前。</p>
</li>
<li><p><code>compareFunction(a, b)</code> 必须总是对相同的输入返回相同的比较结果，否则排序的结果将是不确定的。</p>
</li>
</ul>
<img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210608%20/15-48-16-WecTrT.jpg" alt="question-mark-2318030_1280" style="zoom:50%;" />

<h2 id="compareFunction-初步探究"><a href="#compareFunction-初步探究" class="headerlink" title="compareFunction 初步探究"></a>compareFunction 初步探究</h2><p>我们暂不做什么复杂的分析，先使用控制台打印一下看看 a 和 b 到底是什么：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">49</span>, <span class="number">5</span>, <span class="number">14</span>, <span class="number">89</span>, <span class="number">71</span>, <span class="number">3</span>, <span class="number">10</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"><span class="keyword">let</span> times = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> res = [];</span><br><span class="line">arr.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    res.push(&#123;times, a, b, <span class="string">"a - b"</span>: a - b&#125;);</span><br><span class="line">    times++;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<p><img src="https://gitee.com/yinyiwang/blogImages/raw/master/images/20210608%20/19-47-41-N9xVc0.png" alt="image-20210608194739014"></p>
<p>通过上图，我们可以看到：</p>
<ul>
<li>a 的值在按照原数组中的顺序依次变化，这个排序采用的应该是<strong>插入排序法</strong>。</li>
<li>a 代表的应该是<strong>游标</strong>。</li>
<li>从 b 值的变化上又可以看出，a 首次找位置时采用了<strong>二分法</strong>，a &lt; b 则向前比较， a&gt;b 则向后比较。</li>
</ul>
<p>那么，其机理到底是不是我们所看到这样一个过程，还需要再探究。</p>
<h3 id="compareFunction-深入探究"><a href="#compareFunction-深入探究" class="headerlink" title="compareFunction 深入探究"></a>compareFunction 深入探究</h3><p>要想弄清楚一个问题，还有什么比从根源上着手效率更高的呢？所以我们追根溯源，先来扒一扒 <code>v8引擎</code> 的源码，看看它内部到底是怎么实现 <code>sort</code> 接口的。</p>
<blockquote>
<p>下面的源码来自7.2版本之前的 v8，该版本之后的数组排序实现变化较大，暂不予讨论。</p>
</blockquote>
<p>其中 <a href="https://github.com/v8/v8/blob/ad82a40509c5b5b4680d4299c8f08d6c6d31af3c/src/js/array.js" target="_blank" rel="noopener">array.js</a> 文件下，关于 sort 接口实现的代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">InnerArraySort</span>(<span class="params">array, length, comparefn</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// In-place QuickSort algorithm.</span></span><br><span class="line">    <span class="comment">// For short (length &lt;= 22) arrays, insertion sort is used for efficiency.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!IS_CALLABLE(comparefn)) &#123;</span><br><span class="line">        comparefn = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (x === y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (% _IsSmi(x) &amp;&amp; % _IsSmi(y)) &#123;</span><br><span class="line">                <span class="keyword">return</span> % SmiLexicographicCompare(x, y);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将数组元素转换为字符串</span></span><br><span class="line">            x = TO_STRING(x);</span><br><span class="line">            y = TO_STRING(y);</span><br><span class="line">            <span class="keyword">if</span> (x == y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> x &lt; y ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> InsertionSort = <span class="function"><span class="keyword">function</span> <span class="title">InsertionSort</span>(<span class="params">a, from, to</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="keyword">from</span> + <span class="number">1</span>; i &lt; to; i++) &#123;</span><br><span class="line">            <span class="keyword">var</span> element = a[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j = i - <span class="number">1</span>; j &gt;= <span class="keyword">from</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">var</span> tmp = a[j];</span><br><span class="line">                <span class="comment">// 调用比较函数 a: tmp, b: element</span></span><br><span class="line">                <span class="keyword">var</span> order = comparefn(tmp, element);</span><br><span class="line">                <span class="keyword">if</span> (order &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    a[j + <span class="number">1</span>] = tmp;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            a[j + <span class="number">1</span>] = element;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** some code here **/</span> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> QuickSort = <span class="function"><span class="keyword">function</span> <span class="title">QuickSort</span>(<span class="params">a, from, to</span>) </span>&#123;</span><br><span class="line">        <span class="comment">/*** some code here **/</span> </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ArraySort</span>(<span class="params">comparefn</span>) </span>&#123;</span><br><span class="line">  	CHECK_OBJECT_COERCIBLE(<span class="keyword">this</span>, <span class="string">"Array.prototype.sort"</span>);</span><br><span class="line"></span><br><span class="line">  	<span class="keyword">var</span> array = TO_OBJECT(<span class="keyword">this</span>);</span><br><span class="line">  	<span class="keyword">var</span> length = TO_LENGTH(array.length);</span><br><span class="line">  	<span class="keyword">return</span> InnerArraySort(array, length, comparefn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 源码我就不放了，大家有兴趣研究的话，可以点击上面的链接自行查看</span></span><br></pre></td></tr></table></figure>

<p>代码分析：</p>
<ol>
<li>v8 中实现 sort() 方法时，采用了 ”<strong>插入排序</strong>“ 和 ”<strong>快速排序</strong>“ 两种排序方式。</li>
<li>对于短数组（长度 &lt;= 22）来说，插入排序效率更高。</li>
<li>如果没有传入 <code>comparefn</code> ，则生成一个 <code>comparefn</code> 比较函数。</li>
<li>在自动生成的比较函数中，会将传入的数组元素通过 <code>TO_STRING</code> 方法转换为字符串，再行比较。</li>
<li>对比比较函数中的 b 为游标值，这一点和最新版的 chrome 浏览器表现不同。</li>
</ol>
<p>我们在 sort 方法中传入的函数用在了这里：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> order = comparefn(tmp, element);</span><br></pre></td></tr></table></figure>

<p>根据我们传入函数的返回值，数组进行排序操作：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (order &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    a[j + <span class="number">1</span>] = tmp;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果返回值<code>（a-b）</code>大于0，即 <code>a &gt; b</code>, 则将当前拿来比较的值 a 复制给它的下一位，并继续使用游标值 b 向前进行比较。</li>
<li>如果返回值小于等于 0 ，则结束比较，并将游标值 b 填在最后一次比较值 a 的后面。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>不管是旧版本还是最新版本的 v8，它们的 <code>sort()</code> 方法的返回结果都没有发生变化，只是内部的实现机理有了改变（肯定是向着更优的方向改变）。</p>
<p>为了是 <code>sort()</code> 的返回结果符合预期，我们给它传入了一个函数作为比较规则。</p>
<p>在比较函数中，因 v8 版本不同，实现机制有差异，导致它的参数意义也不大相同，所以我们暂时无需关心它里面参数的具体含义。</p>
<p>比较函数如果写完全的话，应该是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.sort(<span class="function">(<span class="params">a,b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res = a - b;</span><br><span class="line">    <span class="keyword">return</span> res &gt; <span class="number">0</span> ? <span class="number">1</span> : (res &lt; <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">0</span> );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>即比较函数的返回值严格来说只有三个：-1、0 和 1 。</p>
<p>我们主需要记住 <code>return a - b</code> 是<strong>升序排列</strong>，<code>return b - a</code> 是<strong>降序排列</strong>即可。</p>
<p>~本文完</p>
<blockquote>
<p>学习有趣的知识，结识有趣的朋友，塑造有趣的灵魂！</p>
<p>大家好！我是〖编程三昧〗的作者 <strong>隐逸王</strong>，我的公众号是『编程三昧』，欢迎关注，希望大家多多指教！</p>
<p>知识与技能并重，内力和外功兼修，理论和实践两手都要抓、两手都要硬！</p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript - 数组</category>
      </categories>
      <tags>
        <tag>数组 sort</tag>
      </tags>
  </entry>
</search>
